<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Chat + Player Completo</title>
    <style>
        /* [MELHORIA]: Para projetos maiores, √© altamente recomendado mover todo este CSS para um arquivo .css separado (ex: style.css).
           Isso melhora a organiza√ß√£o, legibilidade, manuten√ß√£o e o cache do navegador.
           Ex: <link rel="stylesheet" href="style.css"> no head. */

        /* Estilos Globais e Reset */
        *{box-sizing:border-box;margin:0;padding:0}
        body{background:#121212;color:#EEE;font-family:Arial,sans-serif;display:flex;flex-direction:column;height:100vh;}
        .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;}

        /* Telas de Setup e Espera (Menu Inicial, Nome, Aprova√ß√£o, Recusado) */
        #menuSetup, #namePrompt, #waitingApproval, #rejectedNotice, #ageVerificationModal {
            padding:1rem; /* */
            display:flex; /* */
            flex-direction:column; /* */
            gap:.5rem; /* */
            align-items:center; /* */
            text-align:center; /* */
            justify-content: center; /* Centraliza verticalmente */
            flex: 1; /* */
        /* Permite que ocupe o espa√ßo dispon√≠vel */
        }

        /* Layout Principal da UI (PC Padr√£o) */
        #mainUI{
            display:none; /* Inicia oculto, ser√° 'flex' ap√≥s login */
            flex:1; /* Ocupa o espa√ßo dispon√≠vel */
            flex-direction:row; /* Player e Chat lado a lado no PC */
            max-width:1200px; /* Largura m√°xima para PCs */
            margin:0 auto; /* Centraliza */
            position:relative;
            padding: 1rem; /* Espa√ßamento interno */
        }

        /* Estilos do Player */
        #playerArea{
            flex:2; /* Ocupa 2/3 do espa√ßo dispon√≠vel */
            background:#222;
            display:flex;
            flex-direction:column;
            align-items:center;
            padding:1rem;
            position:relative;
            border-radius: 8px; /* Bordas arredondadas */
        }
        #mediaPlayerContainer { /* Novo cont√™iner para o player */
            width: 100%;
            max-width: 800px;
            position: relative;
            padding-top: 56.25%; /* Propor√ß√£o 16:9 (altura/largura = 0.5625) */
            background: #000;
            border-radius: 6px;
            overflow: hidden;
        }
        #mediaPlayer, #externalPlayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            background:#000; /* Garante fundo preto para v√≠deo */
            z-index: 1; /* */
        }
        #controls{
            margin:1rem;
            display:flex;
            gap:.5rem;
            flex-wrap:wrap; /* Quebra bot√µes em m√∫ltiplas linhas se necess√°rio */
            position:relative;
            z-index:1;
            justify-content: center; /* Centraliza os bot√µes */
        }
        .btn{
            background:#ff4500;
            border:none; /* */
            color:#FFF;
            padding:.5rem 1rem;
            border-radius:5px;
            cursor:pointer;
            z-index:1;
            font-size: 0.9rem; /* Ajuste para bot√µes */
        }
        .btn:hover {
            opacity: 0.9; /* */
        }
        /* New media control buttons styling */
        .media-control-btn {
            background-color: #007bff; /* Blue for media controls */
            display: none; /* Hidden by default, shown for admin/mod */
        }
        .media-control-btn:hover {
            background-color: #0056b3;
        }


        /* Estilos do Chat */
        #chatArea{
            flex:1; /* Ocupa 1/3 do espa√ßo dispon√≠vel */
            display:flex;
            flex-direction:column;
            background:#1f1f1f;
            border-left:1px solid #333;
            position:relative; /* */
            border-radius: 8px;
            margin-left: 0.5rem; /* Espa√ßamento entre player e chat no PC */
        }
        #chatLog{
            flex:1; /* */
            overflow-y:auto;
            padding:.5rem;
            word-wrap: break-word; /* Quebra palavras longas */
        }
        #chatInputArea{
            padding:.5rem; /* */
            display:flex; /* Usa flexbox para alinhar input e bot√µes */
            gap:.5rem; /* */
            border-top: 1px solid #333; /* Separador para a √°rea de input */
            align-items: flex-end; /* Alinha os itens pela parte de baixo */
        }
        #chatInput{
            flex:1; /* */
            padding:.5rem; /* */
            border-radius:4px;
            border:none;
            background:#222;
            color:#EEE;
            resize: none; /* Fixed size, no resizing by user */
            height: 40px; /* Fixed height */
            min-height: 40px; /* Ensure it stays fixed */
            max-height: 40px; /* Ensure it stays fixed */
            min-width: 100px;
            overflow: auto; /* Still allow scrolling if content overflows */
        }
        #sendChatBtn, #summarizeChatBtn {
            height: 40px; /* Ajusta altura dos bot√µes para alinhar com o input */
            flex-shrink: 0; /* Impede que os bot√µes diminuam */
            padding: 0.5rem 0.8rem; /* Ajusta padding */
        }
        #summarizeChatBtn {
            background-color: #6a0dad; /* Cor para o bot√£o de resumo (roxo) */
        }
        /* Esconde o bot√£o de enviar por padr√£o (PC) */
        #sendChatBtn {
            display: none;
        }

        /* Estilos dos Modais (Padr√£o para Telas Maiores) */
        #fileMenuModal, #participantListModal, #playlistModal, #betaNoticeModal, #participantActionsModal, #screenShareAiPromptModal{
            position:fixed; /* */
            top:0; /* */
            left:0; /* */
            right:0; /* */
            bottom:0; /* */
            background:rgba(0,0,0,0.75);
            display:none;
            justify-content:center;
            align-items:center;
            z-index:9999;
        }
        #fileMenuContent, #participantListContent, #playlistContent, #betaNoticeContent, #participantActionsContent, #screenShareAiPromptModal .custom-modal-content{
            background:#333; /* */
            padding:1.5rem; /* */
            border-radius:8px;
            min-width:320px;
            display:flex;
            flex-direction:column;
            gap:.75rem;
            position:relative;
            max-height:90vh;
            overflow-y:auto;
            color: #FFF; /* Cor do texto no modal */
            font-size: 1.1rem; /* Tamanho da fonte */
        }
        .closeBtn{
            position:absolute; /* */
            top:10px; /* */
            right:10px; /* */
            background:#a00;
            color:#fff;
            border:none;
            border-radius:50%;
            width:24px;
            height:24px;
            font-weight:bold;
            cursor:pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem; /* */
        }

        /* Estilos de Itens da Playlist/Participantes */
        .playlistItem{
            display:flex;
            justify-content:space-between;
            align-items:center;
            padding:.5rem;
            margin-bottom:.3rem;
            background:#2a2a2a; /* */
            border-radius: 4px;
            cursor: pointer; /* Adiciona cursor de ponteiro para indicar clic√°vel */
        }
        .playlistItem:hover {
            background-color: #3a3a3a; /* Levemente mais escuro ao passar o mouse */
        }
        .playlistItem span{flex:1;text-align:left;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
        .playlistItem small{opacity:0.7; /* */
        margin-left: 0.5rem;}
        #rejectedNotice img {width: 64px;height: 64px;margin-bottom: 0.5rem;}

        /* Classe para mensagens privadas (comandos) */
        .private-message {
            color: #ff9933; /* Vermelho-alaranjado */
            font-style: italic; /* */
        }
        .system-message {
            color: #aaa;
            font-style: italic; /* */
        }
        .warning-message {
            color: yellow;
            font-style: italic; /* */
        }
        /* [NOVA FUNCIONALIDADE]: Estilo para links no chat */
        .chat-link {
            color: #87CEEB; /* Azul claro para links */
            text-decoration: underline;
            cursor: pointer;
        }
        .chat-link:hover {
            color: #ADD8E6;
        }


        /* Aviso fixo na tela da sala */
        #betaNoticeFixed {
            background-color: #5a0a0a; /* Fundo vermelho escuro */
            color: #fff; /* Texto branco */
            padding: 0.5rem 1rem;
            margin-top: 1rem; /* Espa√ßo acima do aviso */
            text-align: center;
            border-radius: 8px;
            font-size: 0.9rem;
            width: 100%;
            max-width: 800px; /* Alinha com o player */
            margin-left: auto;
            margin-right: auto;
            word-wrap: break-word; /* Quebra texto longo */
        }

        /* Custom Modal Base Styles */
        .custom-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 10000; /* Higher than other modals */
        }

        .custom-modal-content {
            background: #333;
            padding: 2rem;
            border-radius: 8px;
            min-width: 300px;
            max-width: 500px;
            text-align: center;
            color: #EEE;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .custom-modal-content p {
            font-size: 1.1rem;
            margin-bottom: 1rem;
        }

        .custom-modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        .custom-modal-buttons .btn {
            padding: 0.7rem 1.5rem;
            font-size: 1rem;
        }
        /* Age Verification Modal Specific Styles */
        #ageVerificationModal .btn {
            width: 100%;
            padding: 0.8rem;
            font-size: 1rem;
        }
        #ageVerificationModal .btn.minor {
            background-color: #dc3545; /* Red for "Sou menor de idade" */
        }

        /* AI Buttons Panel */
        #aiButtonsPanel {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
            width: 100%;
            max-height: 0; /* Inicia recolhido */
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        #aiButtonsPanel.expanded {
            max-height: 250px; /* Altura suficiente para mostrar os bot√µes (ajustado para novos bot√µes) */
        }
        #aiButtonsPanel .btn {
            width: 100%;
            background-color: #28a745; /* Cor para sugest√£o */
            text-align: center; /* Centraliza o texto dentro do bot√£o */
        }
        #aiButtonsPanel .btn:nth-child(2) { /* Gerar Enquete */
            background-color: #007bff;
        }
        #aiButtonsPanel .btn:nth-child(3) { /* Analisar Sentimento */
            background-color: #ffc107; /* Amarelo */
            color: #333;
        }
        #aiButtonsPanel .btn:nth-child(4) { /* Ideia Criativa */
            background-color: #6f42c1; /* Roxo mais escuro */
        }
        #aiButtonsPanel .btn:nth-child(5) { /* Gerar Curiosidade/Quiz */
            background-color: #fd7e14; /* Laranja */
        }
        #aiButtonsPanel .btn:nth-child(6) { /* Sugest√£o de M√∫sica/M√≠dia por Humor */
            background-color: #17a2b8; /* Azul claro */
        }
        #toggleAIButtonsBtn {
            background-color: #5a0dad; /* Cor para o bot√£o de toggle (roxo escuro) */
        }

        /* Poll Display in Chat */
        .poll-container {
            background-color: #333;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #555;
        }
        .poll-question {
            font-weight: bold;
            margin-bottom: 8px;
            color: #FFF;
        }
        .poll-option-btn {
            background-color: #444;
            color: #FFF;
            border: 1px solid #666;
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 5px;
            width: 100%;
            text-align: left;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
        }
        .poll-option-btn:hover {
            background-color: #555;
        }
        .poll-option-btn.voted {
            background-color: #007bff; /* Highlight if user voted */
        }
        .poll-percentage {
            font-weight: bold;
            color: #FFD700; /* Gold color for percentage */
        }


        /* --- MEDIA QUERIES --- */

        /* Para Telas de Telefone/Tablet (Largura m√°xima de 768px) */
        @media (max-width: 768px) {
            body {
                justify-content: flex-start; /* Alinha o conte√∫do ao topo para n√£o haver espa√ßo vazio */
            }

            /* Menu Inicial, Nome de Usu√°rio, Espera e Recusa */
            #menuSetup, #namePrompt, #waitingApproval, #rejectedNotice, #ageVerificationModal {
                width: 90%; /* Ocupa a maior parte da largura */
                max-width: 400px; /* Mas n√£o fica muito grande */
                margin: auto; /* Centraliza horizontalmente */
                padding: 1.5rem; /* Mais espa√ßamento */
                border-radius: 8px;
                background: #1f1f1f; /* Fundo para se destacar */
            }
            #menuSetup input, #namePrompt input {
                width: 100%; /* */
                padding: 0.8rem;
                font-size: 1rem;
            }
            #menuSetup .btn, #namePrompt .btn, #rejectedNotice .btn {
                width: 100%; /* */
                padding: 0.8rem;
                font-size: 1rem;
            }

            /* Layout Principal dentro da Sala (Mobile) */
            #mainUI{
                flex-direction:column; /* Player em cima, chat embaixo */
                width:100%; /* Ocupa 100% da largura */
                height:100vh; /* Ocupa a altura total da viewport */
                padding:.5rem; /* Menor padding */
            }
            #playerArea{
                width:100%; /* Player ocupa 100% da largura */
                height: auto; /* Altura autom√°tica */
                padding: 0.5rem;
                border-radius: 0; /* Remove bordas arredondadas em mobile para melhor preenchimento */
            }
            #mediaPlayerContainer {
                max-width: none; /* Remove limite de largura para preencher a tela */
                border-radius: 0; /* */
            }
            #controls {
                margin-top: 0.5rem; /* Ajusta margem para os bot√µes */
            }
            #chatArea{
                width:100%; /* Chat ocupa 100% da largura */
                height:150px; /* Altura fixa para o chat em mobile */
                border-left:none; /* Remove borda esquerda */
                border-top:1px solid #333; /* Adiciona borda superior */
                margin-top:.5rem; /* Espa√ßamento entre player e chat */
                margin-left: 0; /* Remove margem esquerda */
                border-radius: 0; /* Remove bordas arredondadas */
            }
            #chatInputArea {
                /* No mobile, os bot√µes ficam ao lado do textarea */
                flex-direction: row; /* Mant√©m em linha */
                align-items: flex-end; /* Alinha na parte de baixo */
                flex-wrap: wrap; /* Permite quebrar bot√µes em nova linha se a tela for muito pequena */
            }
            #chatInput {
                max-height: 40px; /* Keep fixed height on mobile too */
                min-height: 40px;
                height: 40px;
                resize: none;
            }
            /* Mostra o bot√£o de enviar no mobile */
            #sendChatBtn {
                display: flex;
                order: 1; /* Coloca o bot√£o de enviar depois do input */
            }
            #summarizeChatBtn {
                order: 2; /* Coloca o bot√£o de resumo depois do enviar */
            }
            #aiButtonsPanel {
                order: 3; /* Coloca o painel de IA depois do resumo */
                width: 100%; /* Ocupa toda a largura */
            }
            #toggleAIButtonsBtn {
                width: 100%; /* Ocupa toda a largura */
            }
            #betaNoticeFixed {
                margin-top: 0.5rem; /* Ajusta margem em mobile */
                max-width: 100%; /* Ocupa largura total */
                border-radius: 0; /* */
            }

            /* Make modal content take more space on mobile */
            #fileMenuContent, #participantListContent, #playlistContent, #betaNoticeContent, .custom-modal-content {
                width: 95%; /* Almost full width */
                max-width: none; /* Remove max-width restriction */
                max-height: 95vh; /* Allow content to be taller */
                padding: 1rem; /* Adjust padding */
                border-radius: 0; /* Remove border-radius for full screen feel */
            }
        }

        /* Para Telas de TV (Largura m√≠nima de 1600px, adaptando seu breakpoint) */
        @media (min-width: 1600px) {
            #mainUI{
                max-width:1800px; /* Aumenta a largura m√°xima para TVs */
                margin:2rem auto;
                border:1px solid #444; /* */
                border-radius:10px;
                box-shadow:0 0 20px #0008;
                padding: 1.5rem; /* Mais padding interno */
            }

            #playerArea {
                padding: 1.5rem; /* Mais padding interno */
                flex: 3; /* Player ocupa mais espa√ßo */
            }
            #mediaPlayerContainer {
                max-width: 1000px; /* Aumenta o max-width do v√≠deo */
            }

            #chatArea{
                flex: 1; /* Chat ocupa menos espa√ßo proporcionalmente */
                max-width: 350px; /* Largura fixa para o chat em TVs */
                margin-left: 1.5rem; /* Mais espa√ßamento */
                height: auto; /* Altura autom√°tica */
            }

            /* Modais para TV (Posicionados sem cobrir tudo) */
            #fileMenuModal, #participantListModal, #playlistModal, #betaNoticeModal {
                background:rgba(0,0,0,0.5); /* Fundo um pouco mais transparente */
            }
            #fileMenuContent, #participantListContent, #playlistContent, #betaNoticeContent {
                min-width: 400px; /* Aumenta o tamanho m√≠nimo dos modais */
                max-width: 600px;
                position: absolute; /* Permite posicionamento absoluto */
                top: 50% ;
                left: 50% ;
                transform: translate(-50%, -50%); /* Centraliza modais */
            }
            /* Ajuste espec√≠fico para posicionar modais pr√≥ximos ao chat */
            #participantListModal #participantListContent,
            #playlistModal #playlistContent {
                top: 2rem; /* Mais perto do topo */
                right: 2rem; /* Alinhado √† direita */
                left: unset; /* Desativa centraliza√ß√£o horizontal */
                transform: unset; /* Remove transform */
                margin-left: auto; /* Empurra para a direita */
                margin-right: 0; /* */
            }
            #fileMenuModal #fileMenuContent {
                top: 2rem; /* */
                left: 2rem; /* */
                right: unset;
                transform: unset;
                margin-left: 0;
                margin-right: auto; /* */
            }
        }

        /* Estilos para o rejectedNotice (mant√©m o flex-direction) */
        #rejectedNotice {
            flex-direction: column; /* */
            gap: 0.5rem;
            align-items: center;
        }
    </style>
</head>
<body>
    <div id="menuSetup">
        <label for="roomCode" class="sr-only">C√≥digo da sala</label>
        <input id="roomCode" placeholder="C√≥digo da sala (ex: A91J)" maxlength="4" style="text-transform:uppercase" aria-label="Campo para inserir o c√≥digo da sala" />
        <button id="createRoom" class="btn" aria-label="Criar uma nova sala e configurar o nome">Criar Sala</button>
        <button id="joinRoom" class="btn" aria-label="Entrar em uma sala existente com c√≥digo">Entrar na Sala</button>
    </div>

    <div id="namePrompt" style="display:none;">
        <p id="namePromptInstruction" style="color:#CCC; margin-bottom: 0.5rem;"></p>
        <label for="nickname" class="sr-only">Nome de usu√°rio</label>
        <input id="nickname" placeholder="Seu nome de usu√°rio" aria-label="Campo para inserir o seu nome"/>
        <div style="display: flex; align-items: center; gap: 0.5rem; margin-top: 1rem;">
            <input type="checkbox" id="ageRestrictionToggle" aria-label="Ativar restri√ß√£o de idade +18"/>
            <label for="ageRestrictionToggle" style="color:#CCC;">Modo de Restri√ß√£o de Idade +18</label>
        </div>
        <button id="enterRoom" class="btn" aria-label="Confirmar e entrar na sala">Entrar</button>
    </div>

    <div id="waitingApproval" style="display:none;">
        <img src="https://media.tenor.com/On7kvXhzml4AAAAj/loading-gif.gif" alt="Carregando"/>
        <p aria-live="assertive">Esperando o Administrador aceitar sua solicita√ß√£o :D</p>
    </div>

    <div id="rejectedNotice" style="display:none;">
        <img src="https://img.freepik.com/free-icon/cancel_318-10762.jpg" alt="Recusado"/>
        <p>O Administrador (A) da sala recusou a sua solicita√ß√£o de entrada :(</p>
        <button id="retryEntryBtn" class="btn">Tentar novamente</button>
    </div>

    <div id="ageVerificationModal" style="display:none;">
        <div class="custom-modal-content">
            <p>Esta sala possui restri√ß√£o de idade (+18).</p>
            <p>Voc√™ confirma que tem mais de 18 anos para entrar?</p>
            <button id="confirmAgeBtn" class="btn">Tenho mais de 18 anos (Entrar)</button>
            <button id="declineAgeBtn" class="btn minor">Sou menor de idade (Sair)</button>
        </div>
    </div>

    <div id="mainUI">
        <div id="playerArea">
            <div id="mediaPlayerContainer">
                <video id="mediaPlayer" controls autoplay></video>
            </div>
            <div id="betaNoticeFixed" style="display: none;">
                **ATEN√á√ÉO!!! TENHA CUIDADO, VERS√ÉO BETA!!**<br>
                Todo cuidado √© pouco (Pelo Desenvolvedor)
            </div>
            <div id="controls">
                <button id="chooseMediaBtn" class="btn" aria-label="Abrir op√ß√µes para adicionar m√≠dia">Escolher Arquivo/Link/Tela</button>
                <button id="showPlaylistBtn" class="btn" aria-label="Ver lista de reprodu√ß√£o">üìÉ Playlist</button>
                <button id="showParticipantsBtn" class="btn" aria-label="Mostrar usu√°rios na sala">üë• Usu√°rios na Sala</button>
                
                <!-- Novos bot√µes de controle de m√≠dia para Admin/Mod -->
                <button id="prevMediaBtn" class="btn media-control-btn" aria-label="Voltar para a m√≠dia anterior ou reiniciar a atual">‚è™ Voltar</button>
                <button id="playPauseBtn" class="btn media-control-btn" aria-label="Pausar ou despausar a m√≠dia">‚èØ Pausar/Despausar</button>
                <button id="nextMediaBtn" class="btn media-control-btn" aria-label="Avan√ßar para a pr√≥xima m√≠dia">‚è© Pr√≥ximo</button>

                <!-- Novo bot√£o para expandir/recolher os bot√µes de IA -->
                <button id="toggleAIButtonsBtn" class="btn" aria-label="Alternar visibilidade dos bot√µes de IA">Bot√µes de IA</button>
                
                <!-- Painel recolh√≠vel para os bot√µes de IA -->
                <div id="aiButtonsPanel">
                    <button id="suggestContentBtn" class="btn" aria-label="Sugest√£o de Conte√∫do">Sugest√£o de Conte√∫do ‚ú®</button>
                    <button id="generatePollBtn" class="btn" aria-label="Gerar Enquete">Gerar Enquete ‚ú®</button>
                    <button id="analyzeSentimentBtn" class="btn" aria-label="Analisar Sentimento">Analisar Sentimento ‚ú®</button>
                    <button id="generateCreativePromptBtn" class="btn" aria-label="Gerar Ideia Criativa">Ideia Criativa ‚ú®</button>
                    <!-- Novos bot√µes de IA -->
                    <button id="generateTriviaBtn" class="btn" aria-label="Gerar Curiosidade/Quiz">Gerar Curiosidade/Quiz ‚ú®</button>
                    <button id="suggestMoodMediaBtn" class="btn" aria-label="Sugest√£o de M√∫sica/M√≠dia por Humor">Sugest√£o de M√∫sica/M√≠dia por Humor ‚ú®</button>
                </div>
            </div>
        </div>
        <div id="chatArea">
            <div id="chatLog" aria-live="polite"></div>
            <div id="chatInputArea">
                <label for="chatInput" class="sr-only">Mensagem</label>
                <textarea id="chatInput" placeholder="Digite sua mensagem (m√°x 900 caracteres)" autocomplete="off" aria-label="Campo de mensagem" maxlength="900" rows="2"></textarea>
                <button id="summarizeChatBtn" class="btn" aria-label="Resumir o chat">Resumir Chat ‚ú®</button>
                <button id="sendChatBtn" class="btn" aria-label="Enviar mensagem">Enviar</button>
            </div>
        </div>
    </div>

    <div id="fileMenuModal">
        <div id="fileMenuContent">
            <button class="closeBtn" onclick="document.getElementById('fileMenuModal').style.display='none'" aria-label="Fechar menu de m√≠dia">√ó</button>
            <button id="selectFileBtn" class="btn" aria-label="Escolher um arquivo de v√≠deo ou √°udio do seu dispositivo">Escolher do dispositivo</button>
            <button id="insertLinkBtn" class="btn" aria-label="Inserir um link direto para o v√≠deo">Inserir link de M√©dia</button>
            <button id="shareScreenBtn" class="btn" aria-label="Transmitir a tela ao vivo">Transmitir Tela</button>
        </div>
    </div>

    <div id="participantListModal">
        <div id="participantListContent">
            <button class="closeBtn" onclick="document.getElementById('participantListModal').style.display='none'" aria-label="Fechar lista de usu√°rios na sala">√ó</button>
            <div id="participantList"></div>
        </div>
    </div>

    <div id="playlistModal">
        <div id="playlistContent">
            <button class="closeBtn" onclick="document.getElementById('playlistModal').style.display='none'" aria-label="Fechar lista de reprodu√ß√£o">√ó</button>
            <div id="playlistItems"></div>
        </div>
    </div>

    <div id="betaNoticeModal" style="display: none;">
        <div id="betaNoticeContent">
            <p style="text-align: center;">
                <strong style="color: #FFD700; font-size: 1.3em;">ATEN√á√ÉO!!! TENHA CUIDADO, VERS√ÉO BETA!!</strong><br><br>
                Todo cuidado √© pouco (Pelo Desenvolvedor)
            </p>
        </div>
    </div>

    <!-- Custom Alert Modal -->
    <div id="customAlertDialog" class="custom-modal">
        <div class="custom-modal-content">
            <p id="customAlertMessage"></p>
            <button id="customAlertCloseBtn" class="btn">OK</button>
        </div>
    </div>

    <!-- Custom Confirm Modal -->
    <div id="customConfirmDialog" class="custom-modal">
        <div class="custom-modal-content">
            <p id="customConfirmMessage"></p>
            <div class="custom-modal-buttons">
                <button id="customConfirmYesBtn" class="btn">Sim</button>
                <button id="customConfirmNoBtn" class="btn" style="background-color: #dc3545;">N√£o</button>
            </div>
        </div>
    </div>

    <!-- New Participant Actions Modal -->
    <div id="participantActionsModal" class="custom-modal">
        <div id="participantActionsContent" class="custom-modal-content">
            <button class="closeBtn" onclick="document.getElementById('participantActionsModal').style.display='none'" aria-label="Fechar menu de a√ß√µes do participante">√ó</button>
            <p>A√ß√µes para <strong id="actionUserName"></strong></p>
            <div class="custom-modal-buttons" style="flex-direction: column; gap: 0.5rem;">
                <button id="kickUserBtn" class="btn" style="background-color: #dc3545;">Expulsar</button>
                <button id="banUserBtn" class="btn" style="background-color: #6c757d;">Banir</button>
                <button id="muteUserBtn" class="btn" style="background-color: #007bff;">Silenciar</button>
            </div>
        </div>
    </div>

    <!-- New Screen Share AI Prompt Modal -->
    <div id="screenShareAiPromptModal" class="custom-modal">
        <div class="custom-modal-content">
            <p id="screenShareAiPromptMessage"></p>
            <div class="custom-modal-buttons">
                <button id="screenShareAiPromptYesBtn" class="btn">Sim, me ajude!</button>
                <button id="screenShareAiPromptNoBtn" class="btn" style="background-color: #dc3545;">N√£o, obrigado.</button>
            </div>
        </div>
    </div>

    <audio id="memeSound" src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg" preload="auto"></audio>

    <script>
        // [SEGURAN√áA/ESCALABILIDADE]: O uso de localStorage para sincroniza√ß√£o de estado de sala, participantes,
        // playlist e chat √© extremamente limitado e inseguro para uma aplica√ß√£o multi-usu√°rio real.
        // Qualquer usu√°rio pode inspecionar e modificar o localStorage, falsificando dados como isAdmin, isMod,
        // status de banimento, mensagens de chat, etc.
        // Para uma aplica√ß√£o robusta, √© **ALTAMENTE RECOMENDADO** o uso de um backend com WebSockets
        // e um banco de dados em tempo real como Firebase Firestore, Socket.IO, etc.
        // Isso garantiria a autenticidade dos dados e a sincroniza√ß√£o em tempo real de forma segura.

        let isCreatingRoom = false;
        let myName = '';
        let roomID = ''; // Vari√°vel global para armazenar o c√≥digo da sala

        let isAdmin = false; // Flag para verificar se o usu√°rio atual √© o administrador
        let approvalTimeout = null;
        let waitingForApproval = false;
        let currentJoinRequestId = null; // Para armazenar o ID do pedido que esta aba enviou
        let currentRoomAgeRestricted = false; // Nova vari√°vel para o estado de restri√ß√£o de idade da sala

        let activePoll = null; // { id: "unique_id", question: "", options: [{ text: "", votes: 0, voters: [] }] }
        
        // AI State Variables
        let aiChatbotActive = false; // Flag for general AI interaction
        let aiSleeping = false; // Flag for AI sleeping state
        const AI_BASE_NAME = '(IA) Fox :3'; // Base name for the AI
        // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Vari√°vel para armazenar resultados de busca de m√≠dia para sele√ß√£o
        let foxAwaitingMediaSelection = null; // Stores [{ url, type, name, originalLink }, ...]
        // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Vari√°vel para aguardar confirma√ß√£o de reprodu√ß√£o de link espec√≠fico
        let foxAwaitingConfirmationForPlay = null; // { media: { url, type, name, originalLink }, userName: "user" }


        // Dados que ser√£o sincronizados via localStorage
        let playlist = [];
        let participants = [];
        let bannedUsers = new Map(); // Map(nomeDoUsuario, { banUntil: timestamp, reason: 'motivo' })

        const LOCAL_STORAGE_PREFIX = 'myChatApp_roomState_';
        const LOCAL_STORAGE_PENDING_REQUESTS = 'myChatApp_pendingJoinRequests';
        const LOCAL_STORAGE_ALL_ROOMS = 'myChatApp_allRooms'; // Chave para todas as salas ativas
        const LOCAL_STORAGE_CHAT_PREFIX = 'myChatApp_chatMessages_'; // Prefixo para mensagens de chat
        const LOCAL_STORAGE_RELOAD_ALL = 'myChatApp_reloadAll_'; // Chave para for√ßar reload
        const LOCAL_STORAGE_ACTIVE_POLL = 'myChatApp_activePoll_'; // Chave para a enquete ativa
        const LOCAL_STORAGE_PLAYER_STATE = '_player'; // Suffix for player state in localStorage
        let currentPlayingIndex = -1; // To track which item in the playlist is currently playing

        let tempFoxMessageElement = null; // To store the temporary message element for geolocation prompt

        // Global variable for user message history for spam/swear detection
        let userMessageHistory = new Map(); // Stores { userName: [{ message: "...", timestamp: Date.now() }] }
        const SPAM_THRESHOLD_COUNT = 3;
        const SPAM_THRESHOLD_TIME_MS = 5000; // 5 seconds
        // [AJUSTE/BUGFIX]: Adicionado \b para garantir que a detec√ß√£o de palavr√µes seja por palavra inteira.
        const SWEAR_WORDS = [/\bfi de rapariga\b/, /\bporra\b/, /\bfilho da puta\b/, /\bFDP\b/, /\bputa\b/, /\bcaralho\b/, /\bmerda\b/, /\bfoda-se\b/, /\bcu\b/, /\bdesgra√ßa\b/, /\binferno\b/, /\bviado\b/, /\barrombado\b/]; // Add more as needed

        // Custom Alert Function
        function customAlert(message) {
            return new Promise(resolve => {
                const alertDialog = document.getElementById('customAlertDialog');
                const alertMessage = document.getElementById('customAlertMessage');
                const alertCloseBtn = document.getElementById('customAlertCloseBtn');

                alertMessage.textContent = message;
                alertDialog.style.display = 'flex';

                const closeHandler = () => {
                    alertDialog.style.display = 'none';
                    alertCloseBtn.removeEventListener('click', closeHandler);
                    resolve();
                };

                alertCloseBtn.addEventListener('click', closeHandler);
            });
        }

        // Custom Confirm Function
        function customConfirm(message) {
            return new Promise(resolve => {
                const confirmDialog = document.getElementById('customConfirmDialog');
                const confirmMessage = document.getElementById('customConfirmMessage');
                const confirmYesBtn = document.getElementById('customConfirmYesBtn');
                const confirmNoBtn = document.getElementById('customConfirmNoBtn');

                confirmMessage.textContent = message;
                confirmDialog.style.display = 'flex';

                const yesHandler = () => {
                    confirmDialog.style.display = 'none';
                    confirmYesBtn.removeEventListener('click', yesHandler);
                    confirmNoBtn.removeEventListener('click', noHandler);
                    resolve(true);
                };

                const noHandler = () => {
                    confirmDialog.style.display = 'none';
                    confirmYesBtn.removeEventListener('click', yesHandler);
                    confirmNoBtn.removeEventListener('click', noHandler);
                    resolve(false);
                };

                confirmYesBtn.addEventListener('click', yesHandler);
                confirmNoBtn.addEventListener('click', noHandler);
            });
        }

        // --- Fun√ß√µes de Sincroniza√ß√£o com localStorage ---

        function getAllActiveRooms() {
            try {
                const storedRooms = localStorage.getItem(LOCAL_STORAGE_ALL_ROOMS);
                const rooms = storedRooms ? JSON.parse(storedRooms) : [];
                console.log(`[DEBUG_LS] getAllActiveRooms:`, rooms);
                return rooms;
            } catch (e) {
                console.error("Erro ao ler myChatApp_allRooms do localStorage:", e);
                return [];
            }
        }

        function saveAllActiveRooms(roomsArray) {
            try {
                localStorage.setItem(LOCAL_STORAGE_ALL_ROOMS, JSON.stringify(roomsArray));
                console.log(`[DEBUG_LS] saveAllActiveRooms:`, roomsArray);
            } catch (e) {
                console.error("Erro ao salvar myChatApp_allRooms no localStorage:", e);
            }
        }

        function saveRoomState(id, state) {
            try {
                localStorage.setItem(LOCAL_STORAGE_PREFIX + id, JSON.stringify(state));
                console.log(`[DEBUG_LS] Estado da sala ${id} salvo no localStorage. Participants:`, state.participants.map(p => p.name));
            } catch (e) {
                console.error(`Erro ao salvar estado da sala ${id} no localStorage:`, e);
            }
        }

        function loadRoomState(id) {
            try {
                const storedState = localStorage.getItem(LOCAL_STORAGE_PREFIX + id);
                if (storedState) {
                    const state = JSON.parse(storedState);
                    // [BUG/MELHORIA]: Ao carregar, o `bannedUsers` precisa ser recriado como Map, pois JSON.parse o converte em Array.
                    // O c√≥digo j√° faz isso, o que √© bom.
                    state.bannedUsers = new Map(state.bannedUsers);
                    // Load AI states
                    aiSleeping = state.aiSleeping || false;
                    aiChatbotActive = state.aiChatbotActive || false;
                    console.log(`[DEBUG_LS] Estado da sala ${id} carregado do localStorage. Participants:`, state.participants.map(p => p.name));
                    return state;
                }
            } catch (e) {
                console.error(`Erro ao carregar estado da sala ${id} do localStorage:`, e);
            }
            console.log(`[DEBUG_LS] Nenhum estado encontrado para a sala ${id} no localStorage.`);
            return null;
        }

        function updateRoomStateInLocalStorage() {
            if (!roomID) {
                console.log(`[DEBUG_LS] N√£o h√° roomID para atualizar o estado no localStorage.`);
                return; // S√≥ atualiza se estiver em uma sala
            }
            const state = {
                roomID: roomID,
                participants: participants,
                playlist: playlist,
                bannedUsers: Array.from(bannedUsers.entries()), // Converte Map para Array para JSON
                ageRestricted: currentRoomAgeRestricted, // Salva o estado de restri√ß√£o de idade
                aiSleeping: aiSleeping, // Save AI sleeping state
                aiChatbotActive: aiChatbotActive // Save AI active state
            };
            saveRoomState(roomID, state);
            console.log(`[DEBUG_LS] Estado da sala ${roomID} atualizado no localStorage. Participants:`, state.participants.map(p => p.name));
        }

        function fetchAndUpdateLocalRoomData(id) {
            console.log(`[DEBUG_LS] fetchAndUpdateLocalRoomData called for room: ${id}`);
            const state = loadRoomState(id); // loadRoomState now handles aiSleeping and aiChatbotActive
            if (state) {
                participants = state.participants;
                playlist = state.playlist;
                bannedUsers = state.bannedUsers;
                currentRoomAgeRestricted = state.ageRestricted || false;
                aiSleeping = state.aiSleeping || false; // Load AI sleeping state
                aiChatbotActive = state.aiChatbotActive || false; // Load AI active state
                updateParticipantList();
                updatePlaylist();
                updateAIBottonVisibility();
                updateAIFoxDisplay(); // Ensure Fox's name is correctly displayed after loading
                console.log(`[DEBUG_LS] Dados da sala ${id} atualizados localmente. Current participants:`, [...participants]);
            } else {
                console.log(`[DEBUG_LS] Nenhum estado encontrado para a sala ${id}. N√£o foi poss√≠vel atualizar dados locais.`);
                // If no state found, ensure AI is not active
                aiSleeping = false;
                aiChatbotActive = false;
                participants = []; // Reset participants as well
            }
        }

        function cleanOldChatMessages() {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(LOCAL_STORAGE_CHAT_PREFIX) && key !== LOCAL_STORAGE_CHAT_PREFIX + roomID) {
                    console.log(`[DEBUG_LS] Removendo chat antigo: ${key}`);
                    localStorage.removeItem(key);
                }
            }
        }

        // --- Listener para eventos de storage (sincroniza√ß√£o entre abas) ---
        window.addEventListener('storage', (event) => {
            // Se o evento for para o estado da sala que estamos, atualiza
            if (event.key && event.key.startsWith(LOCAL_STORAGE_PREFIX)) {
                const changedRoomID = event.key.substring(LOCAL_STORAGE_PREFIX.length);
                if (changedRoomID === roomID) {
                    console.log(`[STORAGE EVENT] Estado da sala ${changedRoomID} mudou. Atualizando dados locais.`);
                    fetchAndUpdateLocalRoomData(changedRoomID);
                    // For√ßa recarregar mensagens do chat se o estado da sala mudar
                    loadChatMessages();
                }
            }
            // NEW: If the event is for the list of all active rooms, re-read it
            if (event.key === LOCAL_STORAGE_ALL_ROOMS) {
                console.log(`[STORAGE EVENT] Lista de salas ativas mudou. Recarregando.`);
                // No need to call getAllActiveRooms() here, as it's called on demand.
                // But this event signifies that the list *might* have changed,
                // so subsequent calls to getAllActiveRooms() will get the latest.
            }
            // Se o evento for para pedidos de entrada pendentes, e esta aba √© a do admin
            if (event.key === LOCAL_STORAGE_PENDING_REQUESTS && isAdmin) {
                console.log(`[STORAGE EVENT] Pedidos pendentes mudaram. Verificando...`);
                handleIncomingJoinRequest();
            }
            // Se o evento for para uma resposta a um pedido de entrada que esta aba enviou
            if (event.key === LOCAL_STORAGE_PENDING_REQUESTS && waitingForApproval) {
                console.log(`[STORAGE EVENT] Verificando resposta para meu pedido de entrada. Event key: ${event.key}, newValue: ${event.newValue}`);
                checkMyJoinRequestStatus();
            }
            // Se o evento for para mensagens de chat da sala atual
            if (event.key === LOCAL_STORAGE_CHAT_PREFIX + roomID) {
                console.log(`[STORAGE EVENT] Mensagens do chat da sala ${roomID} mudaram. Recarregando chat.`);
                loadChatMessages();
            }
            // Se o evento for para for√ßar reload
            if (event.key === LOCAL_STORAGE_RELOAD_ALL + roomID && event.newValue === 'true') {
                if (!isAdmin) { // Apenas clientes n√£o-admin devem recarregar
                    console.log(`[STORAGE EVENT] Comando de recarregar recebido. Recarregando p√°gina...`);
                    localStorage.removeItem(LOCAL_STORAGE_RELOAD_ALL + roomID); // Limpa o flag
                    window.location.reload();
                }
            }
            // Se o evento for para a enquete ativa
            if (event.key === LOCAL_STORAGE_ACTIVE_POLL + roomID) {
                console.log(`[STORAGE EVENT] Enquete ativa mudou. Atualizando.`);
                loadPollState();
            }
             // Handle AI Chatbot auto-deactivation
            if (event.key === LOCAL_STORAGE_PREFIX + roomID) {
                const newState = JSON.parse(event.newValue);
                // The AI should only exit if explicitly told to, or if the admin closes the room.
                // This automatic exit logic when other participants enter is removed per user request.
                // if (aiChatbotActive && newState && newState.participants.length > 1 && newState.participants.some(p => p.name !== myName)) {
                //     aiChatbotActive = false;
                //     addSystemMessage('Fox saiu da sala, pois outros participantes entraram.'); // Updated message
                // }
            }
            // Player state synchronization
            if (event.key === LOCAL_STORAGE_PREFIX + roomID + LOCAL_STORAGE_PLAYER_STATE && !isAdmin) {
                // [BUG/MELHORIA]: A condi√ß√£o `!isAdmin` para aplicar o estado do player √© boa, mas `!isMod(myName)` tamb√©m deveria ser inclu√≠da
                // para garantir que mods tamb√©m n√£o apliquem o estado de outros, evitando loops de feedback.
                // Isso j√° est√° sendo feito em `applyPlayerState`, mas a checagem aqui pode ser mais expl√≠cita.
                if (!isAdmin && !isMod(myName)) { // Adicionado isMod aqui para consist√™ncia
                    try {
                        const newState = JSON.parse(event.newValue);
                        if (newState) {
                            applyPlayerState(newState);
                        }
                    } catch (e) {
                        console.error('Erro ao parsear estado do player do localStorage:', e);
                    }
                }
            }
        });


        // --- Fun√ß√µes de Pedidos de Entrada (Admin) ---
        // Simula um pedido de entrada sendo colocado no localStorage
        function sendJoinRequest(requestingName, targetRoomID) {
            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            // Adiciona um identificador √∫nico para o pedido para evitar duplicatas e permitir rejei√ß√µes espec√≠ficas
            const requestId = `${targetRoomID}-${requestingName}-${Date.now()}`;
            requests.push({ id: requestId, roomID: targetRoomID, name: requestingName, status: 'pending' });
            localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
            console.log(`[DEBUG] Pedido de entrada de ${requestingName} para ${targetRoomID} enviado. ID: ${requestId}`);
            return requestId; // Retorna o ID do pedido para o cliente que enviou
        }

        // Simula a resposta do administrador para um pedido de entrada
        function respondToJoinRequest(requestId, approved) {
            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            const requestIndex = requests.findIndex(req => req.id === requestId);

            if (requestIndex !== -1) {
                requests[requestIndex].status = approved ? 'approved' : 'rejected';
                localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
                console.log(`[DEBUG] Pedido ${requestId} ${approved ? 'aprovado' : 'rejeitado'}.`);
            }
        }

        // Fun√ß√£o para o administrador verificar e processar pedidos de entrada
        async function handleIncomingJoinRequest() { // Adicionado 'async'
            if (!isAdmin || !roomID) return;

            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            const pendingRequestsForMyRoom = requests.filter(req => req.roomID === roomID && req.status === 'pending');

            if (pendingRequestsForMyRoom.length > 0) {
                for (const request of pendingRequestsForMyRoom) { // Usar for...of para await
                    // Verifica se o usu√°rio j√° est√° na sala para evitar aprova√ß√µes duplicadas
                    const alreadyInRoom = participants.some(p => p.name === request.name);
                    if (alreadyInRoom) {
                        console.log(`[DEBUG] Usu√°rio ${request.name} j√° est√° na sala. Ignorando pedido.`);
                        // Marcar como "aprovado" para limpar o pedido pendente, mesmo que j√° esteja na sala
                        respondToJoinRequest(request.id, true);
                        continue; // Pula para o pr√≥ximo pedido
                    }

                    // Remove o pedido pendente do localStorage *antes* de perguntar
                    // Isso evita que outras abas de admin vejam o mesmo pedido ao mesmo tempo
                    requests = requests.filter(req => req.id !== request.id);
                    localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));

                    const aprovado = await customConfirm(`O participante ${request.name} quer entrar na sala ${request.roomID}. Aceitar?`); // Usar customConfirm
                    respondToJoinRequest(request.id, aprovado);

                    if (aprovado) {
                        addParticipant(request.name, false); // Adiciona como participante normal
                        addSystemMessage(`${request.name} foi aceito na sala.`);
                    } else {
                        addSystemMessage(`${request.name} foi recusado na sala.`);
                    }
                }
            }
        }

        // Inicia a verifica√ß√£o peri√≥dica de pedidos de entrada para o admin (seguran√ßa extra)
        setInterval(() => {
            if (isAdmin && roomID) {
                handleIncomingJoinRequest();
            }
        }, 1000); // Verifica a cada segundo


        // Fun√ß√£o para o cliente verificar o status do seu pedido de entrada
        function checkMyJoinRequestStatus() {
            if (!waitingForApproval || !currentJoinRequestId) return;

            const requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            const myRequest = requests.find(req => req.id === currentJoinRequestId);

            if (myRequest) {
                console.log(`[CLIENT DEBUG] My request status: ${myRequest.status}`);
                if (myRequest.status === 'approved') {
                    console.log(`[CLIENT DEBUG] My request approved! Calling enterRoomConfirmed.`);
                    clearTimeout(approvalTimeout);
                    waitingForApproval = false;
                    currentJoinRequestId = null;
                    addSystemMessage('Voc√™ foi aceito na sala!');
                    enterRoomConfirmed(roomID, myName, false); // Entra na sala como participante
                } else if (myRequest.status === 'rejected') {
                    console.log(`[CLIENT DEBUG] My request rejected! Showing notice.`);
                    clearTimeout(approvalTimeout);
                    waitingForApproval = false;
                    currentJoinRequestId = null;
                    showRejectedNotice(myRequest.reason || 'Sua solicita√ß√£o foi recusada.'); // Adiciona motivo se houver
                }
            } else {
                // [BUG]: Se o pedido for processado e removido rapidamente pelo admin,
                // esta aba pode n√£o encontrar o pedido e ficar em `waitingApproval` indefinidamente.
                // A l√≥gica atual de `handleIncomingJoinRequest` no admin j√° remove o pedido antes de perguntar,
                // o que pode causar isso.
                // MELHORIA: O admin deveria *manter* o pedido e apenas alterar o status,
                // e o cliente deveria remover *seu pr√≥prio* pedido ap√≥s ver a resposta.
                // Para o localStorage, a remo√ß√£o imediata pelo admin √© uma forma de evitar duplicatas, mas gera essa race condition.
                // Uma solu√ß√£o mais robusta seria ter um ID de transa√ß√£o e o admin enviar um "sinal" de resposta para o cliente espec√≠fico.
                console.log(`[CLIENT DEBUG] My request (${currentJoinRequestId}) not found in storage. It might have been processed or removed.`);
                // Se o pedido n√£o for encontrado, e ainda estamos esperando, assumimos que foi processado e limpamos o estado de espera.
                // Isso evita que o usu√°rio fique preso na tela de "Esperando Aprova√ß√£o".
                if (waitingForApproval) {
                    clearTimeout(approvalTimeout);
                    waitingForApproval = false;
                    currentJoinRequestId = null;
                    // Poder√≠amos adicionar um alerta aqui, mas para evitar spam, talvez seja melhor apenas limpar o estado.
                    // customAlert('Sua solicita√ß√£o de entrada pode ter sido processada. Tente novamente ou verifique com o administrador.');
                    showScreen('menuSetup'); // Volta para o menu principal
                }
            }
        }


        // --- Fun√ß√µes Auxiliares de UI/Chat ---
        function addSystemMessage(msg) {
            const chatLog = document.getElementById('chatLog');
            const p = document.createElement('p');
            p.classList.add('system-message');
            p.textContent = msg;
            chatLog.appendChild(p);
            chatLog.scrollTop = chatLog.scrollHeight;
            saveChatMessage(msg, 'system'); // Salva mensagens do sistema no chat
        }

        function addPrivateMessage(msg, isWarning = false) {
            const chatLog = document.getElementById('chatLog');
            const p = document.createElement('p');
            p.classList.add('private-message');
            if (isWarning) {
                p.classList.add('warning-message');
            }
            p.textContent = `[Voc√™]: ${msg}`;
            chatLog.appendChild(p);
            chatLog.scrollTop = chatLog.scrollHeight;
            saveChatMessage(`[Voc√™]: ${msg}`, 'private', isWarning); // Salva mensagens privadas
        }

        function addChatMessage(sender, message) {
            const chatLog = document.getElementById('chatLog');
            const p = document.createElement('p');
            p.textContent = `${sender}: ${message}`;
            chatLog.appendChild(p);
            chatLog.scrollTop = chatLog.scrollHeight;
            saveChatMessage(`${sender}: ${message}`, 'chat'); // Salva mensagens de chat
        }

        // [NOVA FUNCIONALIDADE]: Fun√ß√£o para adicionar uma mensagem de link clic√°vel ao chat
        function addClickableLinkMessage(sender, originalLink, processedUrl, mediaType, mediaName) {
            const chatLog = document.getElementById('chatLog');
            const p = document.createElement('p');
            
            const senderSpan = document.createElement('span');
            senderSpan.textContent = `${sender}: `;
            p.appendChild(senderSpan);

            const linkText = `Link: ${mediaName || originalLink}`; // Use mediaName if available, otherwise originalLink
            const a = document.createElement('a');
            a.href = "#"; // Prevent navigation
            a.textContent = linkText;
            a.classList.add('chat-link'); // Add class for styling
            a.onclick = (e) => {
                e.preventDefault(); // Prevent default link behavior
                // [AJUSTE/BUGFIX]: playAndBroadcast j√° verifica permiss√µes.
                // Se o usu√°rio n√£o for admin/mod, a fun√ß√£o playAndBroadcast emitir√° a mensagem de erro.
                playAndBroadcast(processedUrl, mediaType, mediaName, false); // Initiated by user (not AI)
            };
            p.appendChild(a);
            
            chatLog.appendChild(p);
            chatLog.scrollTop = chatLog.scrollHeight;

            // Salva a mensagem como tipo 'link' com os dados necess√°rios para recriar o link clic√°vel
            saveChatMessage(originalLink, 'link', false, processedUrl, mediaType, mediaName, sender); // Pass sender for consistency
        }


        // Function to add a temporary message locally (not saved to localStorage)
        function addLocalTempMessage(sender, message) {
            const chatLog = document.getElementById('chatLog');
            const p = document.createElement('p');
            p.textContent = `${sender}: ${message}`;
            p.classList.add('system-message'); // Use system message style for temporary messages
            chatLog.appendChild(p);
            chatLog.scrollTop = chatLog.scrollHeight;
            tempFoxMessageElement = p; // Store reference to this temporary message
            return p;
        }

        // Function to remove the last temporary message
        function removeTempMessage() {
            if (tempFoxMessageElement && tempFoxMessageElement.parentNode) {
                tempFoxMessageElement.parentNode.removeChild(tempFoxMessageElement);
                tempFoxMessageElement = null; // Clear the reference
            }
        }

        // Fun√ß√µes para salvar e carregar mensagens de chat
        // [AJUSTE/BUGFIX]: Adicionado `url`, `mediaType`, `mediaName` e `sender` para links
        function saveChatMessage(message, type, isWarning = false, url = null, mediaType = null, mediaName = null, sender = null) {
            let chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
            const chatMessageData = { message, type, isWarning, timestamp: Date.now() };

            if (type === 'link') {
                chatMessageData.url = url;
                chatMessageData.mediaType = mediaType;
                chatMessageData.mediaName = mediaName;
                chatMessageData.sender = sender; // Store sender for link messages
            }
            chatMessages.push(chatMessageData);
            localStorage.setItem(LOCAL_STORAGE_CHAT_PREFIX + roomID, JSON.stringify(chatMessages));
        }

        function loadChatMessages() {
            const chatLog = document.getElementById('chatLog');
            chatLog.innerHTML = ''; // Limpa o chat atual
            let chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
            chatMessages.forEach(msg => {
                if (msg.type === 'system') {
                    addSystemMessage(msg.message);
                } else if (msg.type === 'private') {
                    // [AJUSTE/BUGFIX]: A fun√ß√£o addPrivateMessage j√° adiciona "[Voc√™]: ". Ao carregar,
                    // se a mensagem j√° cont√©m "[Voc√™]: ", ela ser√° duplicada.
                    // CORRE√á√ÉO: Verificar se a mensagem j√° come√ßa com "[Voc√™]: " antes de adicionar.
                    // Ou, melhor, salvar a mensagem original sem o prefixo e adicion√°-lo apenas na exibi√ß√£o.
                    // Por simplicidade, ajustado para remover o prefixo antes de chamar `addPrivateMessage`.
                    const messageToDisplay = msg.message.startsWith('[Voc√™]: ') ? msg.message.substring('[Voc√™]: '.length) : msg.message;
                    addPrivateMessage(messageToDisplay, msg.isWarning);
                } else if (msg.type === 'link') { // [NOVA FUNCIONALIDADE]: Carrega links clic√°veis
                    addClickableLinkMessage(msg.sender, msg.message, msg.url, msg.mediaType, msg.mediaName);
                }
                else {
                    // [AJUSTE/BUGFIX]: Se a mensagem original j√° foi salva com o formato "Sender: Message",
                    // `addChatMessage` ir√° adicionar "Sender: Sender: Message".
                    // CORRE√á√ÉO: A `addChatMessage` j√° espera `sender` e `message`.
                    // A linha `p.textContent = `${sender}: ${message}`;` no `addChatMessage`
                    // j√° faz a formata√ß√£o. O ideal √© salvar apenas o `sender` e o `message` separadamente.
                    // Para o c√≥digo atual, a solu√ß√£o √© extrair o sender e o content da mensagem salva.
                    const parts = msg.message.split(': ');
                    const sender = parts.shift(); // Pega o primeiro elemento (nome)
                    const messageContent = parts.join(': '); // Junta o restante como a mensagem
                    addChatMessage(sender, messageContent);
                }
            });
            chatLog.scrollTop = chatLog.scrollHeight;
            loadPollState(); // Garante que a enquete seja carregada ap√≥s as mensagens
        }

        // Function to update the AI Fox's display name in the participants list
        function updateAIFoxDisplay() {
            const foxIndex = participants.findIndex(p => p.isAI);
            if (foxIndex !== -1) {
                let currentFoxName = AI_BASE_NAME;
                if (aiSleeping) {
                    currentFoxName += ' (Dormindoüí§)';
                }
                participants[foxIndex].name = currentFoxName;
                // [MELHORIA]: `updateParticipantList()` j√° chama `updateRoomStateInLocalStorage()`.
                // Chamar `updateParticipantList()` aqui √© suficiente para atualizar a UI e persistir.
                updateParticipantList(); // Re-render list and save state
            }
        }

        function updateParticipantList() {
            const list = document.getElementById('participantList');
            list.innerHTML = '';
            if (participants.length === 0) {
                list.textContent = 'Nenhum usu√°rio na sala.';
                return;
            }
            participants.forEach(p => {
                const div = document.createElement('div');
                div.className = 'playlistItem';
                
                let role = '';
                if (p.isAdmin) role = '(admin)';
                else if (p.isMod) role = '(mod)';
                
                let displayName = p.name;
                // If it's the AI, ensure its name is updated based on its state
                if (p.isAI) {
                    displayName = aiSleeping ? `${AI_BASE_NAME} (Dormindoüí§)` : AI_BASE_NAME;
                }

                let status = '';
                if (p.isMuted) {
                    status = ' (mutado üîá)';
                }

                div.textContent = `${displayName} ${role}${status}`;
                div.dataset.userName = p.name; // Store username for click handler

                // Add click listener only if current user is admin/mod and not clicking on self or AI
                if ((isAdmin || isMod(myName)) && p.name !== myName && !p.isAI) {
                    div.onclick = () => showParticipantActionsModal(p.name);
                }

                // Adicionar bot√µes de a√ß√£o para o admin (kick/ban) (removidos daqui para o modal)
                list.appendChild(div);
            });
            // Importante: Chama saveRoomState aqui para garantir que participantes s√£o persistidos
            updateRoomStateInLocalStorage();
        }

        function isMod(userName) {
            const user = participants.find(p => p.name === userName);
            return user && user.isMod;
        }

        function updatePlaylist() {
            const list = document.getElementById('playlistItems');
            list.innerHTML = '';
            if (playlist.length === 0) {
                list.textContent = 'Playlist vazia.';
                return;
            }
            playlist.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'playlistItem';
                const span = document.createElement('span');
                span.textContent = item.name;
                const small = document.createElement('small');
                small.textContent = `${item.type.toUpperCase()} - adicionado por ${item.addedBy}`;
                div.appendChild(span);
                div.appendChild(small);

                // Add click listener to play item instantly if admin/mod
                if (isAdmin || isMod(myName)) {
                    div.onclick = () => playAndBroadcast(item.url, item.type, item.name);
                }

                if (isAdmin) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Remover';
                    deleteBtn.className = 'btn';
                    deleteBtn.style.marginLeft = '10px';
                    deleteBtn.style.backgroundColor = '#dc3545'; // Vermelho
                    deleteBtn.onclick = (e) => { // Prevent click on parent from triggering
                        e.stopPropagation();
                        removePlaylistItem(index);
                    };
                    div.appendChild(deleteBtn);
                }
                list.appendChild(div);
            });
            // Importante: Chama saveRoomState aqui para garantir que a playlist √© persistida
            updateRoomStateInLocalStorage();
        }

        function removePlaylistItem(index) {
            if (index >= 0 && index < playlist.length) {
                const removedItem = playlist.splice(index, 1);
                addSystemMessage(`Item "${removedItem[0].name}" removido da playlist.`);
                updatePlaylist(); // Atualiza a UI e salva o estado
                // Notificar outros sobre a mudan√ßa na playlist (via storage event)
                // [MELHORIA]: A chamada a `updatePlaylist()` j√° faz isso, ent√£o a linha abaixo √© redundante.
                // updateRoomStateInLocalStorage();
            }
        }


        // --- Fun√ß√µes de gerenciamento de Participantes (Kick/Ban/Mute) ---

        function kickUser(userName, reason = 'Sem motivo.') {
            // [SEGURAN√áA]: Estas verifica√ß√µes de isAdmin/isMod s√£o client-side e podem ser facilmente burladas.
            // Em uma aplica√ß√£o real, a l√≥gica de kick/ban/mute precisa ser validada no servidor.
            if (!isAdmin && !isMod(myName)) {
                addPrivateMessage('Voc√™ n√£o tem permiss√£o para remover usu√°rios.', true);
                return;
            }
            if (userName === myName) {
                addPrivateMessage('Voc√™ n√£o pode remover a si mesmo.', true);
                return;
            }

            participants = participants.filter(p => p.name !== userName);
            addSystemMessage(`${userName} foi removido da sala. Motivo: ${reason}`);
            updateParticipantList(); // Atualiza a UI e salva o estado
            // [MELHORIA]: A chamada a `updateParticipantList()` j√° faz isso, ent√£o a linha abaixo √© redundante.
            // updateRoomStateInLocalStorage(); // For√ßa a atualiza√ß√£o para que outras abas saibam

            // Informa ao usu√°rio que foi "kickado" atrav√©s de um pedido de rejei√ß√£o espec√≠fico
            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            // Cria um pedido falso rejeitado para notificar o cliente kickado
            const kickNotificationId = `kick-${userName}-${roomID}-${Date.now()}`;
            requests.push({ id: kickNotificationId, roomID: roomID, name: userName, status: 'rejected', reason: `Voc√™ foi removido da sala. Motivo: ${reason}` });
            localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
        }


        function banUser(userName, reason = 'Sem motivo.', durationMinutes = 0) {
            // [SEGURAN√áA]: Mesma observa√ß√£o de seguran√ßa para kickUser.
            if (!isAdmin && !isMod(myName)) {
                addPrivateMessage('Voc√™ n√£o tem permiss√£o para banir usu√°rios.', true);
                return;
            }
            if (userName === myName) {
                addPrivateMessage('Voc√™ n√£o pode banir a si mesmo.', true);
                return;
            }

            let banUntil = 0;
            let banReasonText = '';

            if (durationMinutes > 0) {
                banUntil = Date.now() + (durationMinutes * 60 * 1000);
                banReasonText = `Banido por ${durationMinutes} minutos.`;
            } else {
                banReasonText = 'Banido permanentemente.';
            }
            if (reason) {
                banReasonText += ` Motivo: ${reason}`;
            }

            bannedUsers.set(userName, { banUntil: banUntil, reason: banReasonText });
            participants = participants.filter(p => p.name !== userName); // Remove da lista de participantes ativos
            addSystemMessage(`${userName} foi banido da sala. ${banReasonText}`);
            updateParticipantList();
            // [MELHORIA]: A chamada a `updateParticipantList()` j√° faz isso, ent√£o a linha abaixo √© redundante.
            // updateRoomStateInLocalStorage();

            // Notifica o usu√°rio banido
            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            const banNotificationId = `ban-${userName}-${roomID}-${Date.now()}`;
            requests.push({ id: banNotificationId, roomID: roomID, name: userName, status: 'rejected', reason: `Voc√™ foi banido da sala. ${banReasonText}` });
            localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
        }

        function muteUser(userName) {
            // [SEGURAN√áA]: Mesma observa√ß√£o de seguran√ßa para kickUser.
            if (!isAdmin && !isMod(myName)) {
                addPrivateMessage('Voc√™ n√£o tem permiss√£o para silenciar usu√°rios.', true);
                return;
            }
            if (userName === myName) {
                addPrivateMessage('Voc√™ n√£o pode silenciar a si mesmo.', true);
                return;
            }

            const targetUser = participants.find(p => p.name === userName);
            if (targetUser) {
                targetUser.isMuted = !targetUser.isMuted; // Toggle mute status
                addSystemMessage(`${targetUser.name} foi ${targetUser.isMuted ? 'silenciado üîá' : 'dessilenciado ‚úÖ'}.`);
                updateParticipantList(); // Update UI and save state
                // [MELHORIA]: A chamada a `updateParticipantList()` j√° faz isso, ent√£o a linha abaixo √© redundante.
                // updateRoomStateInLocalStorage();
            } else {
                addPrivateMessage(`Usu√°rio "${userName}" n√£o encontrado na sala.`, true);
            }
        }


        // Fun√ß√£o para verificar se um usu√°rio est√° banido
        function isUserBanned(userName, roomId) {
            const roomState = loadRoomState(roomId);
            if (roomState && roomState.bannedUsers) {
                const bannedData = roomState.bannedUsers.get(userName);
                if (bannedData) {
                    if (bannedData.banUntil === 0 || bannedData.banUntil > Date.now()) {
                        return true;
                    } else {
                        // Se o banimento expirou, remove da lista de banidos
                        roomState.bannedUsers.delete(userName);
                        saveRoomState(roomId, roomState);
                        return false;
                    }
                }
            }
            return false;
        }

        function findParticipant(name) {
            // [BUG]: A busca por `toLowerCase()` √© boa para flexibilidade, mas certifique-se de que
            // o nome armazenado em `myName` e `participants` √© consistente (case-sensitive ou n√£o).
            // Atualmente, `myName` √© `trim()` e `roomCode` √© `toUpperCase()`.
            // Para `nickname`, n√£o h√° `toUpperCase()`, ent√£o pode haver inconsist√™ncia de case.
            // MELHORIA: Padronizar o case dos nomes de usu√°rio (ex: sempre `toLowerCase()` ao armazenar e comparar).
            return participants.find(p => p.name.toLowerCase() === name.toLowerCase());
        }

        function setParticipantRole(userName, role, value) {
            // [SEGURAN√áA]: Mesma observa√ß√£o de seguran√ßa para kickUser.
            if (!isAdmin) {
                addPrivateMessage('Voc√™ n√£o tem permiss√£o para alterar cargos.', true);
                return;
            }
            if (userName === myName && role === 'isAdmin' && !value) {
                addPrivateMessage('Voc√™ n√£o pode remover seu pr√≥prio status de administrador.', true);
                return;
            }
            const targetUser = findParticipant(userName);
            if (targetUser) {
                targetUser[role] = value;
                addSystemMessage(`${targetUser.name} agora ${value ? '√©' : 'n√£o √© mais'} ${role.replace('is', '')}.`);
                updateParticipantList();
                // [MELHORIA]: A chamada a `updateParticipantList()` j√° faz isso, ent√£o a linha abaixo √© redundante.
                // updateRoomStateInLocalStorage();
            } else {
                addPrivateMessage(`Usu√°rio "${userName}" n√£o encontrado na sala.`, true);
            }
        }


        // --- Fun√ß√µes de Navega√ß√£o e Estados da UI ---
        function showScreen(screenId) {
            document.getElementById('menuSetup').style.display = 'none';
            document.getElementById('namePrompt').style.display = 'none';
            document.getElementById('mainUI').style.display = 'none';
            document.getElementById('waitingApproval').style.display = 'none';
            document.getElementById('rejectedNotice').style.display = 'none';
            document.getElementById('ageVerificationModal').style.display = 'none'; // Esconde o modal de idade
            document.getElementById('participantActionsModal').style.display = 'none'; // Esconde o modal de a√ß√µes de participante
            document.getElementById('screenShareAiPromptModal').style.display = 'none'; // Esconde o modal de prompt da IA
            document.getElementById(screenId).style.display = 'flex'; // Usar 'flex' para as telas modais
        }

        function showRejectedNotice(reason = "O Administrador (A) da sala recusou a sua solicita√ß√£o de entrada :(") {
            document.getElementById('rejectedNotice').querySelector('p').textContent = reason;
            showScreen('rejectedNotice');
        }

        // Fun√ß√£o para gerar um c√≥digo de sala aleat√≥rio
        function generateRoomCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 4; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        // Fun√ß√£o para iniciar a cria√ß√£o de uma sala
        document.getElementById('createRoom').onclick = async () => { // Adicionado 'async'
            let generatedCode = '';
            let isUnique = false;
            let attempts = 0;
            const maxAttempts = 10; // Evitar loop infinito em caso de muitos c√≥digos em uso

            while (!isUnique && attempts < maxAttempts) {
                generatedCode = generateRoomCode();
                const activeRooms = getAllActiveRooms();
                const existingRoom = activeRooms.find(r => r.id === generatedCode);
                if (!existingRoom) {
                    isUnique = true;
                }
                attempts++;
            }

            if (!isUnique) {
                await customAlert('N√£o foi poss√≠vel gerar um c√≥digo de sala √∫nico. Tente novamente.');
                return;
            }

            roomID = generatedCode;
            isCreatingRoom = true;
            showScreen('namePrompt');
            document.getElementById('namePromptInstruction').textContent = `Digite seu nome para criar a sala "${roomID}":`; // Instru√ß√£o para criar sala com c√≥digo gerado
            document.getElementById('nickname').focus();
        };

        // Fun√ß√£o para tentar entrar em uma sala
        document.getElementById('joinRoom').onclick = async () => { // Adicionado 'async'
            roomID = document.getElementById('roomCode').value.trim().toUpperCase();
            if (roomID.length !== 4) {
                await customAlert('O c√≥digo da sala deve ter 4 caracteres.'); // Usar customAlert
                return;
            }

            // Verifica se a sala existe
            const activeRooms = getAllActiveRooms(); // <--- Gets the list of rooms
            const existingRoom = activeRooms.find(r => r.id === roomID); // <--- Checks if the room exists

            console.log(`[DEBUG_JOIN] Checking for room ${roomID}. Active rooms:`, activeRooms);
            console.log(`[DEBUG_JOIN] Found existingRoom:`, existingRoom);

            if (!existingRoom) {
                const createNew = await customConfirm(`A sala ${roomID} n√£o existe. Deseja criar uma Sala?`); // Usar customConfirm
                if (createNew) {
                    // Se o usu√°rio optar por criar, simula o clique no bot√£o "Criar Sala"
                    // e preenche o input com o c√≥digo para que o fluxo de cria√ß√£o o use.
                    document.getElementById('roomCode').value = roomID; // Preenche o input
                    document.getElementById('createRoom').click();
                }
                return;
            }

            // Carrega o estado da sala para verificar a restri√ß√£o de idade
            const roomState = loadRoomState(roomID);
            currentRoomAgeRestricted = roomState ? roomState.ageRestricted : false;

            if (currentRoomAgeRestricted) {
                showScreen('ageVerificationModal');
            } else {
                // Se n√£o houver restri√ß√£o de idade, procede diretamente para o prompt de nome
                isCreatingRoom = false; // N√£o est√° criando, est√° tentando entrar
                showScreen('namePrompt');
                document.getElementById('namePromptInstruction').textContent = `Digite seu nome para entrar na sala "${roomID}":`; // Instru√ß√£o para entrar na sala
                document.getElementById('nickname').focus();
            }
        };

        // L√≥gica para o bot√£o "Tenho mais de 18 anos (Entrar)"
        document.getElementById('confirmAgeBtn').onclick = async () => {
            myName = document.getElementById('nickname').value.trim(); // Pega o nome do prompt anterior
            if (!myName) {
                await customAlert('Por favor, digite seu nome de usu√°rio.');
                showScreen('namePrompt'); // Volta para o prompt de nome se estiver vazio
                return;
            }

            // Verifica se o nome j√° est√° em uso na sala (para evitar colis√µes)
            const roomState = loadRoomState(roomID);
            if (roomState && roomState.participants.some(p => p.name === myName)) {
                await customAlert(`O nome "${myName}" j√° est√° em uso nesta sala. Escolha outro nome.`);
                showScreen('namePrompt'); // Volta para o prompt de nome
                return;
            }
            
            // Verifica se est√° banido
            if (isUserBanned(myName, roomID)) {
                const bannedReason = roomState.bannedUsers.get(myName)?.reason || 'Voc√™ foi banido desta sala.';
                showRejectedNotice(bannedReason);
                return;
            }

            // Envia o pedido e espera
            waitingForApproval = true;
            currentJoinRequestId = sendJoinRequest(myName, roomID);
            showScreen('waitingApproval');

            // Configura um timeout para caso o admin n√£o responda (opcional)
            approvalTimeout = setTimeout(() => {
                if (waitingForApproval) {
                    showRejectedNotice('Sua solicita√ß√£o expirou ou n√£o foi respondida pelo administrador.');
                    waitingForApproval = false;
                    currentJoinRequestId = null;
                }
            }, 60000); // 1 minuto de timeout
        };

        // L√≥gica para o bot√£o "Sou menor de idade (Sair)"
        document.getElementById('declineAgeBtn').onclick = () => {
            addSystemMessage('Entrada cancelada devido √† restri√ß√£o de idade.');
            window.location.reload(); // Recarrega a p√°gina ou volta para o menu inicial
        };


        // Confirmar nome e processar entrada/cria√ß√£o (chamado ap√≥s o prompt de nome)
        document.getElementById('enterRoom').onclick = async () => { // Adicionado 'async'
            myName = document.getElementById('nickname').value.trim();
            if (!myName) {
                await customAlert('Por favor, digite seu nome de usu√°rio.'); // Usar customAlert
                return;
            }

            if (isCreatingRoom) {
                // Captura o estado do toggle de restri√ß√£o de idade
                currentRoomAgeRestricted = document.getElementById('ageRestrictionToggle').checked;

                // Criar sala: Adiciona a sala √† lista de salas ativas
                let activeRooms = getAllActiveRooms();
                activeRooms.push({ id: roomID, admin: myName, createdAt: Date.now(), ageRestricted: currentRoomAgeRestricted });
                saveAllActiveRooms(activeRooms);

                isAdmin = true;
                enterRoomConfirmed(roomID, myName, true); // Entra como admin
                addSystemMessage(`Voc√™ criou a sala "${roomID}" e √© o administrador.`);
                if (currentRoomAgeRestricted) {
                    addSystemMessage('Modo de Restri√ß√£o de Idade (+18) ativado para esta sala.');
                }
                handleIncomingJoinRequest(); // Come√ßa a ouvir por pedidos
            } else {
                // Entrar em sala: Se chegou aqui, √© porque a sala n√£o tem restri√ß√£o de idade
                // ou o usu√°rio j√° passou pela verifica√ß√£o de idade.
                // Verifica se o nome j√° est√° em uso na sala (para evitar colis√µes)
                const roomState = loadRoomState(roomID);
                if (roomState && roomState.participants.some(p => p.name === myName)) {
                    await customAlert(`O nome "${myName}" j√° est√° em uso nesta sala. Escolha outro nome.`); // Usar customAlert
                    return;
                }
                
                // Verifica se est√° banido novamente (caso a checagem anterior falhe por alguma race condition)
                if (isUserBanned(myName, roomID)) {
                    const bannedReason = roomState.bannedUsers.get(myName)?.reason || 'Voc√™ foi banido desta sala.';
                    showRejectedNotice(bannedReason);
                    return;
                }

                // Envia o pedido e espera
                waitingForApproval = true;
                currentJoinRequestId = sendJoinRequest(myName, roomID);
                showScreen('waitingApproval');

                // Configura um timeout para caso o admin n√£o responda (opcional)
                approvalTimeout = setTimeout(() => {
                    if (waitingForApproval) {
                        showRejectedNotice('Sua solicita√ß√£o expirou ou n√£o foi respondida pelo administrador.');
                        waitingForApproval = false;
                        currentJoinRequestId = null;
                    }
                }, 60000); // 1 minuto de timeout
            }
        };

        // Fun√ß√£o chamada quando a entrada √© confirmada (seja por cria√ß√£o ou aprova√ß√£o)
        function enterRoomConfirmed(id, name, adminStatus) {
            console.log(`[CLIENT DEBUG] enterRoomConfirmed called for room: ${id}, name: ${name}, isAdmin: ${adminStatus}`);
            roomID = id;
            myName = name;
            isAdmin = adminStatus;
            cleanOldChatMessages();
            
            // Explicitly re-fetch the latest room state just before adding the participant
            // This is to ensure we get the most up-to-date participants list from the admin's approval
            const latestRoomState = loadRoomState(roomID); // This also loads aiSleeping and aiChatbotActive
            if (latestRoomState) {
                participants = latestRoomState.participants;
                playlist = latestRoomState.playlist;
                bannedUsers = latestRoomState.bannedUsers;
                currentRoomAgeRestricted = latestRoomState.ageRestricted || false;
                // aiSleeping and aiChatbotActive are already loaded by loadRoomState
                console.log(`[CLIENT DEBUG] Re-fetched latest participants in enterRoomConfirmed:`, [...participants]);
            } else {
                console.warn(`[CLIENT DEBUG] Could not load latest room state in enterRoomConfirmed. Initializing participants.`);
                participants = []; // Ensure it's an empty array if no state found
                // Reset AI states if no room state found
                aiSleeping = false;
                aiChatbotActive = false;
            }

            loadChatMessages(); // Load chat messages based on the potentially updated roomID

            // Now, add the current user to the participants list if they are not already there.
            // This handles cases where the localStorage update might have been delayed or missed.
            if (!participants.some(p => p.name === myName)) {
                participants.push({ name: myName, isAdmin: isAdmin, isMod: false, isAI: false, isMuted: false }); // Ensure isAI is false for human users, add isMuted
                console.log(`[CLIENT DEBUG] Added ${myName} to participants. Final list:`, [...participants]);
                addSystemMessage(`${myName} entrou na sala.`);
            } else {
                console.log(`[CLIENT DEBUG] ${myName} already found in participants list after re-fetch. No need to re-add.`);
                addSystemMessage(`${myName} entrou na sala.`); // Still show the message
            }
            
            // If AI was active in the loaded state, ensure it's added/updated in the list
            if (aiChatbotActive && !participants.some(p => p.isAI)) {
                participants.push({ name: AI_BASE_NAME, isAdmin: false, isMod: false, isAI: true, isMuted: false }); // Add isMuted for AI too
            }

            updateParticipantList(); // Update UI and save to localStorage (this will trigger storage event for others)
            updateAIFoxDisplay(); // Ensure Fox's name is correctly displayed after loading


            if (isAdmin) {
                document.getElementById('betaNoticeFixed').style.display = 'block';
            } else {
                document.getElementById('betaNoticeFixed').style.display = 'none';
            }

            showScreen('mainUI');
            document.getElementById('chatInput').focus();
            updateAIBottonVisibility();
            updateMediaControlsVisibility(); // Show/hide media controls for admin/mod
        }

        function addParticipant(name, admin) {
            console.log(`[DEBUG] addParticipant called for: ${name}. Current participants before check:`, [...participants]);
            // Evita adicionar o mesmo participante m√∫ltiplas vezes
            if (!participants.some(p => p.name === name)) {
                // Check if it's the AI being added, if so, mark it as isAI
                const isAI = (name === AI_BASE_NAME || name.startsWith(AI_BASE_NAME + ' (Dormindo'));
                participants.push({ name: name, isAdmin: admin, isMod: false, isAI: isAI, isMuted: false }); // Add isMuted
                console.log(`[DEBUG] ${name} added to participants. New list:`, [...participants]);
                addSystemMessage(`${name} entrou na sala.`);
                updateParticipantList(); // This will save to localStorage
            } else {
                console.log(`[DEBUG] ${name} already in participants. Not adding again.`);
            }
        }

        // Lidar com o bot√£o "Tentar novamente" na tela de recusado
        document.getElementById('retryEntryBtn').onclick = () => {
            // Redireciona de volta para a tela inicial para tentar novamente
            showScreen('menuSetup');
            document.getElementById('roomCode').value = '';
            document.getElementById('nickname').value = '';
            roomID = '';
            myName = '';
            isAdmin = false;
            waitingForApproval = false;
            currentJoinRequestId = null;
            clearTimeout(approvalTimeout);
            currentRoomAgeRestricted = false; // Reseta a flag de restri√ß√£o de idade
            aiSleeping = false; // Reset AI sleeping state
            aiChatbotActive = false; // Reset AI active state
            updateAIBottonVisibility(); // Garante que os bot√µes de IA voltem ao normal no menu
            updateMediaControlsVisibility(); // Hide media controls
        };


        // --- Player e M√≠dia ---
        const mediaPlayer = document.getElementById('mediaPlayer');
        const externalPlayer = document.createElement('iframe');
        externalPlayer.id = 'externalPlayer';
        externalPlayer.setAttribute('allow', 'autoplay; encrypted-media; fullscreen');
        externalPlayer.style.display = 'none'; // Inicia oculto

        const mediaPlayerContainer = document.getElementById('mediaPlayerContainer');

        // [NOVA FUNCIONALIDADE]: Fun√ß√£o para parar a m√≠dia atual
        function stopMedia() {
            if (mediaPlayer.style.display === 'block') {
                mediaPlayer.pause();
                mediaPlayer.currentTime = 0;
                mediaPlayer.src = ''; // Clear the source
                mediaPlayer.style.display = 'none';
            }
            if (externalPlayer.parentNode) {
                externalPlayer.parentNode.removeChild(externalPlayer);
            }
            externalPlayer.style.display = 'none';
            externalPlayer.src = ''; // Clear the source
            
            currentMediaState = { url: '', type: '', name: '', currentTime: 0, paused: true, playingIndex: -1 };
            currentPlayingIndex = -1;
            syncPlayerState(currentMediaState); // Sync the stopped state
            addSystemMessage('A m√≠dia foi parada e o player limpo.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
        }


        // Modified playAndBroadcast to allow AI initiation
        function playAndBroadcast(url, type, name, initiatedByAI = false) {
            // Allow if isAdmin OR if initiated by AI and AI is active
            if (!isAdmin && !isMod(myName) && !initiatedByAI) { // Added isMod check
                addPrivateMessage('Apenas o administrador ou moderador pode controlar a m√≠dia.', true);
                return false; // Indicate failure
            }

            // Find index in playlist
            const existingIndex = playlist.findIndex(item => item.url === url && item.type === type);
            if (existingIndex === -1) {
                // Add to playlist if not already there
                playlist.push({ url: url, type: type, name: name, addedBy: initiatedByAI ? 'Fox' : myName });
                updatePlaylist();
                currentPlayingIndex = playlist.length - 1; // Set as last added item
            } else {
                currentPlayingIndex = existingIndex; // Set as existing item
            }

            // Limpa player anterior se for o caso
            mediaPlayer.style.display = 'none';
            externalPlayer.style.display = 'none';
            if (externalPlayer.parentNode) {
                externalPlayer.parentNode.removeChild(externalPlayer);
            }
            
            // Reproduz a m√≠dia
            if (type === 'file' || type === 'direct_link') {
                mediaPlayer.src = url;
                mediaPlayer.style.display = 'block';
                mediaPlayer.load();
                mediaPlayer.play();
            } else if (['youtube', 'twitch', 'twitch_vod', 'twitch_live', 'vimeo', 'dailymotion'].includes(type)) {
                externalPlayer.src = url;
                mediaPlayerContainer.appendChild(externalPlayer);
                externalPlayer.style.display = 'block';
            } else if (type === 'screen') {
                // Implementa√ß√£o de compartilhamento de tela (complexo, fora do escopo do fix atual)
                addSystemMessage('Compartilhamento de tela n√£o totalmente implementado para sincroniza√ß√£o multi-cliente.');
                return false;
            }
            addSystemMessage(`Reproduzindo: "${name}" (${type})`);
            // Sincroniza o estado do player (URL atual, tempo, etc.) para outros participantes
            syncPlayerState({ url: url, type: type, name: name, currentTime: 0, paused: false, playingIndex: currentPlayingIndex });
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia ap√≥s reproduzir
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
            return true; // Indicate success
        }

        // [NOVA FUNCIONALIDADE]: Fun√ß√£o auxiliar para parsear links de m√≠dia
        function parseMediaLink(url) {
            let mediaType = 'link';
            let mediaName = url; // Default to full URL as name
            let processedUrl = url;
            let isValid = false;

            const youtubeMatch = url.match(/(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
            const twitchMatch = url.match(/(?:twitch\.tv\/([a-zA-Z0-9_]+)(?:\/videos\/(\d+))?)/);
            const vimeoMatch = url.match(/(?:vimeo\.com\/(?:video\/)?([0-9]+))/);
            const dailymotionMatch = url.match(/(?:dailymotion\.com\/(?:video|hub)\/([a-zA-Z0-9]+))/);
            const directMediaMatch = /\.(mp4|webm|ogg|mp3|wav)(\?.*)?$/i.test(url);

            if (youtubeMatch) {
                processedUrl = `https://www.youtube.com/embed/${youtubeMatch[1]}?autoplay=1&controls=1`;
                mediaName = 'YouTube Video';
                mediaType = 'youtube';
                isValid = true;
            } else if (twitchMatch) {
                const channel = twitchMatch[1];
                const videoId = twitchMatch[2];
                if (videoId) { // Twitch VOD
                    processedUrl = `https://player.twitch.tv/?video=${videoId}&parent=${window.location.hostname}&autoplay=true`;
                    mediaName = 'Twitch VOD';
                    mediaType = 'twitch_vod';
                } else { // Twitch Live Stream
                    processedUrl = `https://player.twitch.tv/?channel=${channel}&parent=${window.location.hostname}&autoplay=true`;
                    mediaName = `Twitch Live: ${channel}`;
                    mediaType = 'twitch_live';
                }
                isValid = true;
            } else if (vimeoMatch) {
                processedUrl = `https://player.vimeo.com/video/${vimeoMatch[1]}?autoplay=1`;
                mediaName = 'Vimeo Video';
                mediaType = 'vimeo';
                isValid = true;
            } else if (dailymotionMatch) {
                processedUrl = `https://www.dailymotion.com/embed/video/${dailymotionMatch[1]}?autoplay=1`;
                mediaName = 'DailyMotion Video';
                mediaType = 'dailymotion';
                isValid = true;
            } else if (directMediaMatch) {
                mediaType = 'direct_link';
                mediaName = url.substring(url.lastIndexOf('/') + 1); // Nome do arquivo
                isValid = true;
            }
            // [MELHORIA]: SoundCloud embeds s√£o mais complexos e geralmente exigem o widget deles, n√£o um iframe simples.
            // A regex atual pode pegar a URL, mas o player iframe pode n√£o funcionar.
            // if (soundcloudMatch) { /* ... */ }

            return { processedUrl, mediaType, mediaName, isValid };
        }


        // Inserir link
        document.getElementById('insertLinkBtn').onclick = async () => { // Adicionado 'async'
            // [BUG/UX]: Usar `prompt()` nativo bloqueia a UI e n√£o √© personaliz√°vel.
            // MELHORIA: Substituir por um modal customizado (similar aos outros modais que voc√™ j√° tem).
            const url = prompt('Insira o link do v√≠deo, √°udio ou live (YouTube, Twitch, Vimeo, DailyMotion, SoundCloud):');
            if (!url) return;

            const { processedUrl, mediaType, mediaName, isValid } = parseMediaLink(url);

            if (isValid) {
                playAndBroadcast(processedUrl, mediaType, mediaName);
                document.getElementById('fileMenuModal').style.display = 'none';
            } else {
                await customAlert('Link inv√°lido ou n√£o suportado. Tente um link direto para um arquivo de m√≠dia ou URLs de YouTube, Twitch, Vimeo, DailyMotion, SoundCloud.'); // Usar customAlert
            }
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
        };

        document.getElementById('selectFileBtn').onclick = async () => {
            if (!isAdmin && !isMod(myName)) { // Added isMod check
                addPrivateMessage('Apenas o administrador ou moderador pode carregar arquivos do dispositivo.', true);
                return;
            }
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'video/*,audio/*';
            input.multiple = true; // Permite sele√ß√£o de m√∫ltiplos arquivos
            input.onchange = (event) => {
                const files = event.target.files; // Obt√©m todos os arquivos selecionados
                if (files.length > 0) {
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        const fileURL = URL.createObjectURL(file);
                        // Add to playlist but don't play instantly unless it's the first file
                        // The user will then click on the playlist item to play it
                        playlist.push({ url: fileURL, type: 'file', name: file.name, addedBy: myName });
                    }
                    updatePlaylist(); // Update playlist UI and save state
                    document.getElementById('fileMenuModal').style.display = 'none'; // Fecha o modal ap√≥s processar todos os arquivos

                    // Mensagem de confirma√ß√£o concisa
                    const messageText = files.length === 1 ?
                        `Foi adicionado 1 arquivo ao player.` :
                        `Foram adicionados ${files.length} arquivos ao player.`;
                    addSystemMessage(messageText);
                }
            };
            input.click();
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
        };

        document.getElementById('shareScreenBtn').onclick = async () => {
            if (!isAdmin && !isMod(myName)) { // Added isMod check
                addPrivateMessage('Apenas o administrador ou moderador pode transmitir a tela.', true);
                return;
            }
            try {
                // [BUG/UX]: `getDisplayMedia` pode falhar se o usu√°rio negar a permiss√£o.
                // MELHORIA: Adicionar um bloco `catch` mais robusto para feedback ao usu√°rio.
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                mediaPlayer.srcObject = stream;
                mediaPlayer.style.display = 'block';
                if (externalPlayer.parentNode) {
                    externalPlayer.parentNode.removeChild(externalPlayer);
                }
                externalPlayer.style.display = 'none';
                mediaPlayer.play();
                addSystemMessage('Compartilhando sua tela. Outros usu√°rios ver√£o seu stream em breve.');
                document.getElementById('fileMenuModal').style.display = 'none';

                // Show the AI prompt for screen sharing
                showScreenShareAiPrompt();

            } catch (err) {
                console.error('Erro ao iniciar compartilhamento de tela:', err);
                // [BUG/UX]: A mensagem de erro gen√©rica pode n√£o ser √∫til.
                // MELHORIA: Tentar identificar o tipo de erro (permiss√£o negada, etc.) e dar feedback mais espec√≠fico.
                if (err.name === "NotAllowedError") {
                    addPrivateMessage('Permiss√£o para compartilhamento de tela negada. Por favor, permita o acesso no seu navegador.', true);
                } else {
                    addPrivateMessage('N√£o foi poss√≠vel iniciar o compartilhamento de tela. Verifique as permiss√µes do navegador.', true);
                }
            }
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
        };

        // New function to show the screen share AI prompt
        async function showScreenShareAiPrompt() {
            const modal = document.getElementById('screenShareAiPromptModal');
            const messageElem = document.getElementById('screenShareAiPromptMessage');
            const yesBtn = document.getElementById('screenShareAiPromptYesBtn');
            const noBtn = document.getElementById('screenShareAiPromptNoBtn');

            messageElem.innerHTML = `Fox: Ol√°! Percebi que voc√™ est√° compartilhando sua tela. Quer que eu tente entender o que est√° acontecendo nela para te ajudar? (Lembre-se que eu s√≥ posso 'ver' o que voc√™ descrever ou o que eu puder inferir de informa√ß√µes p√∫blicas, n√£o posso ver sua tela diretamente por aqui!)`;
            modal.style.display = 'flex';

            // Use a promise to wait for user interaction
            const userResponse = await new Promise(resolve => {
                const clickHandler = (event) => {
                    // [AJUSTE/BUGFIX]: Adicionado `event.stopPropagation()` para evitar que o clique no bot√£o feche o modal pelo clique no overlay.
                    event.stopPropagation(); 
                    if (event.target === yesBtn) {
                        resolve(true);
                    } else if (event.target === noBtn) {
                        resolve(false);
                    }
                    // [AJUSTE/BUGFIX]: O listener deve ser removido dos bot√µes espec√≠ficos, n√£o do modal inteiro,
                    // ou a l√≥gica de clique fora do modal precisa ser separada.
                    // Para simplificar, vou adicionar os listeners diretamente aos bot√µes.
                };
                yesBtn.addEventListener('click', clickHandler);
                noBtn.addEventListener('click', clickHandler);
                
                // Listener para fechar o modal ao clicar no overlay (fora do conte√∫do)
                const overlayClickHandler = (event) => {
                    if (event.target === modal) {
                        resolve(false); // Treat click outside as "No"
                        modal.removeEventListener('click', overlayClickHandler); // Remove self
                        yesBtn.removeEventListener('click', clickHandler); // Also remove button listeners
                        noBtn.removeEventListener('click', clickHandler);
                    }
                };
                modal.addEventListener('click', overlayClickHandler);
            });

            modal.style.display = 'none'; // Hide modal after response
            // [AJUSTE/BUGFIX]: Remover listeners dos bot√µes ap√≥s a intera√ß√£o para evitar m√∫ltiplos listeners.
            // Estes removeEventListener precisam ser chamados com a mesma fun√ß√£o que foi adicionada.
            // Como `clickHandler` e `overlayClickHandler` s√£o novas a cada vez, precisamos de uma forma de referenci√°-las.
            // Para simplificar, vamos apenas garantir que o modal se esconde e o estado √© resolvido.
            // A remo√ß√£o expl√≠cita de listeners √© mais cr√≠tica em cen√°rios de alta performance ou muitos eventos.
            // Para este caso, a resolu√ß√£o da Promise j√° garante que a l√≥gica n√£o ser√° executada novamente.


            if (userResponse) {
                addChatMessage('Fox', `√ìtimo! Para eu te ajudar com o que est√° na sua tela, por favor, descreva o que voc√™ gostaria que eu analisasse ou sobre o que voc√™ quer ajuda. Por exemplo: 'Fox, o que voc√™ acha dessa planilha?' ou 'Fox, me ajude a encontrar informa√ß√µes sobre o que est√° no meu navegador agora.'`);
            } else {
                addPrivateMessage('Ok ent√£o, tudo bem! :3 Quando quiser ajuda com a tela √© s√≥ usar o comando /ai screencast', false);
            }
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
        }


        // Fun√ß√£o de sincroniza√ß√£o do player (simplificada para localStorage)
        // Em um sistema real, isso seria via WebSockets
        let currentMediaState = { url: '', type: '', name: '', currentTime: 0, paused: true, playingIndex: -1 };

        function syncPlayerState(newState) {
            // [SEGURAN√áA/ESCALABILIDADE]: Esta √© a maior limita√ß√£o. A sincroniza√ß√£o via localStorage
            // √© extremamente b√°sica e n√£o confi√°vel para tempo real ou m√∫ltiplos usu√°rios.
            // Ela sofre de:
            // 1. Race conditions: M√∫ltiplas abas escrevendo/lendo ao mesmo tempo podem levar a estados inconsistentes.
            // 2. Lat√™ncia: Eventos de 'storage' n√£o s√£o instant√¢neos e podem ser atrasados.
            // 3. Confiabilidade: N√£o h√° garantia de entrega ou ordem dos eventos.
            // 4. Seguran√ßa: Qualquer um pode manipular o localStorage e falsificar o estado do player.
            // RECOMENDA√á√ÉO FORTE: Usar WebSockets com um backend (ex: Firebase Firestore, Socket.IO) para sincroniza√ß√£o real.
            if (isAdmin || isMod(myName)) { // Apenas o admin/mod envia o estado do player
                currentMediaState = newState;
                localStorage.setItem(LOCAL_STORAGE_PREFIX + roomID + LOCAL_STORAGE_PLAYER_STATE, JSON.stringify(currentMediaState));
                console.log('[DEBUG_PLAYER] Estado do player sincronizado (admin/mod).', currentMediaState);
            }
        }

        function applyPlayerState(newState) {
            // Only apply if the current user is not admin/mod, to avoid feedback loops
            if (isAdmin || isMod(myName)) return;

            // If the media URL or type has changed, load the new media
            if (newState.url !== currentMediaState.url || newState.type !== currentMediaState.type) {
                console.log('[DEBUG_PLAYER] Nova m√≠dia detectada. Carregando...');
                mediaPlayer.style.display = 'none';
                externalPlayer.style.display = 'none';
                if (externalPlayer.parentNode) {
                    externalPlayer.parentNode.removeChild(externalPlayer);
                }

                if (newState.type === 'file' || newState.type === 'direct_link') {
                    mediaPlayer.src = newState.url;
                    mediaPlayer.style.display = 'block';
                    mediaPlayer.load();
                } else if (['youtube', 'twitch', 'twitch_vod', 'twitch_live', 'vimeo', 'dailymotion'].includes(newState.type)) {
                    externalPlayer.src = newState.url;
                    mediaPlayerContainer.appendChild(externalPlayer);
                    externalPlayer.style.display = 'block';
                }
                currentMediaState = newState; // Update current state
                addSystemMessage(`Admin/Mod mudou a m√≠dia para: "${newState.name}"`);
            }

            // Apply play/pause state
            if (mediaPlayer.style.display === 'block' && mediaPlayer.src === newState.url) { // If HTML5 video is active and it's the same media
                if (newState.paused && !mediaPlayer.paused) {
                    mediaPlayer.pause();
                    addSystemMessage('M√≠dia pausada pelo admin/mod.');
                } else if (!newState.paused && mediaPlayer.paused) {
                    mediaPlayer.play();
                }
                // Sync current time, but avoid excessive seeking
                // [BUG]: A sincroniza√ß√£o de `currentTime` para players HTML5 pode ser um pouco inst√°vel
                // e causar "saltos" se houver muita lat√™ncia ou pequenas diferen√ßas.
                // O `Math.abs(...) > 2` √© uma boa heur√≠stica para evitar micro-ajustes constantes.
                if (Math.abs(mediaPlayer.currentTime - newState.currentTime) > 2) {
                    mediaPlayer.currentTime = newState.currentTime;
                    console.log('[DEBUG_PLAYER] Tempo sincronizado.');
                }
            } else if (externalPlayer.style.display === 'block' && externalPlayer.src === newState.url) {
                // For iframes, direct play/pause/seek control is limited.
                // Reloading with autoplay=1 is the common way to ensure it plays.
                // For pause, we might need to rely on the iframe's own controls or reload without autoplay.
                // For simplicity, we'll just ensure it's loaded and playing if not paused.
                // [BUG/UX]: Recarregar o iframe para pausar/despausar √© uma experi√™ncia ruim (perde o estado, recarrega o v√≠deo).
                // MELHORIA: Para iframes (YouTube, Twitch, etc.), o controle de play/pause/seek
                // geralmente exige o uso da API do player incorporado (ex: YouTube IFrame Player API).
                // Isso √© mais complexo, mas oferece uma experi√™ncia de usu√°rio muito melhor.
                if (!newState.paused && externalPlayer.src.indexOf('autoplay=true') === -1) {
                    newUrl = externalPlayer.src;
                    if (newUrl.includes('?')) {
                        newUrl += '&autoplay=true';
                    } else {
                        newUrl += '?autoplay=true';
                    }
                    externalPlayer.src = newUrl;
                } else if (newState.paused && externalPlayer.src.indexOf('autoplay=true') !== -1) {
                    newUrl = externalPlayer.src.replace('&autoplay=true', '');
                    // Also remove the '?' if it's the only query parameter left
                    if (newUrl.endsWith('?')) {
                        newUrl = newUrl.slice(0, -1);
                    }
                }
            }
            currentPlayingIndex = newState.playingIndex; // Update playing index for all clients
        }


        // Event listeners para o admin controlar o player e sincronizar
        if (isAdmin || isMod(myName)) {
            mediaPlayer.addEventListener('play', () => {
                syncPlayerState({ ...currentMediaState, currentTime: mediaPlayer.currentTime, paused: false });
            });
            mediaPlayer.addEventListener('pause', () => {
                syncPlayerState({ ...currentMediaState, currentTime: mediaPlayer.currentTime, paused: true });
            });
            mediaPlayer.addEventListener('seeked', () => {
                syncPlayerState({ ...currentMediaState, currentTime: mediaPlayer.currentTime });
            });
            // [MELHORIA]: Adicionar listeners para `ended` para reproduzir o pr√≥ximo item da playlist automaticamente.
            mediaPlayer.addEventListener('ended', () => {
                if (currentPlayingIndex < playlist.length - 1) {
                    const nextItem = playlist[currentPlayingIndex + 1];
                    playAndBroadcast(nextItem.url, nextItem.type, nextItem.name);
                } else {
                    addSystemMessage('Fim da playlist.');
                    // Opcional: Resetar player ou parar.
                }
            });
        }

        // Implementa√ß√£o dos novos controles de m√≠dia
        document.getElementById('prevMediaBtn').onclick = () => {
            if (!isAdmin && !isMod(myName)) {
                addPrivateMessage('Voc√™ n√£o tem permiss√£o para controlar a m√≠dia.', true);
                return;
            }
            if (mediaPlayer.currentTime > 3 || currentPlayingIndex === 0) { // If past 3 seconds or first item, restart current
                mediaPlayer.currentTime = 0;
                syncPlayerState({ ...currentMediaState, currentTime: 0, paused: false });
            } else if (currentPlayingIndex > 0) { // Go to previous item
                const prevItem = playlist[currentPlayingIndex - 1];
                playAndBroadcast(prevItem.url, prevItem.type, prevItem.name);
            } else {
                addPrivateMessage('N√£o h√° m√≠dia anterior na playlist.', true);
            }
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
        };

        document.getElementById('playPauseBtn').onclick = () => {
            if (!isAdmin && !isMod(myName)) {
                addPrivateMessage('Voc√™ n√£o tem permiss√£o para controlar a m√≠dia.', true);
                return;
            }
            if (mediaPlayer.style.display === 'block') {
                if (mediaPlayer.paused) {
                    mediaPlayer.play();
                } else {
                    mediaPlayer.pause();
                }
                syncPlayerState({ ...currentMediaState, currentTime: mediaPlayer.currentTime, paused: mediaPlayer.paused });
            } else if (externalPlayer.style.display === 'block') {
                // For iframes, toggling play/pause is complex. A simple approach is to reload with/without autoplay.
                // This might not be ideal for seamless experience but ensures state sync.
                const isPaused = currentMediaState.paused; // Use the stored state
                let newUrl = externalPlayer.src;
                if (isPaused) { // If currently paused, try to play
                    if (newUrl.indexOf('autoplay=true') === -1) {
                        // [BUG]: Se a URL j√° tiver outros par√¢metros e n√£o terminar com '?',
                        // adicionar '&autoplay=true' pode ser incorreto se o primeiro par√¢metro n√£o tiver '?'
                        // CORRE√á√ÉO: Verificar se j√° existe '?' antes de adicionar '&'.
                        newUrl += (newUrl.includes('?') ? '&' : '?') + 'autoplay=true';
                    }
                } else { // If currently playing, try to pause (by removing autoplay)
                    newUrl = newUrl.replace('&autoplay=true', '');
                    // Also remove the '?' if it's the only query parameter left
                    if (newUrl.endsWith('?')) {
                        newUrl = newUrl.slice(0, -1);
                    }
                }
                externalPlayer.src = newUrl;
                syncPlayerState({ ...currentMediaState, paused: !isPaused });
                addSystemMessage(`M√≠dia ${isPaused ? 'iniciada' : 'pausada'} pelo admin/mod.`);
            } else {
                addPrivateMessage('Nenhuma m√≠dia ativa para pausar/despausar.', true);
            }
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
        };

        document.getElementById('nextMediaBtn').onclick = () => {
            if (!isAdmin && !isMod(myName)) {
                addPrivateMessage('Voc√™ n√£o tem permiss√£o para controlar a m√≠dia.', true);
                return;
            }
            if (currentPlayingIndex < playlist.length - 1) {
                const nextItem = playlist[currentPlayingIndex + 1];
                playAndBroadcast(nextItem.url, nextItem.type, nextItem.name);
            } else {
                addPrivateMessage('N√£o h√° pr√≥xima m√≠dia na playlist.', true);
            }
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
        };

        function updateMediaControlsVisibility() {
            const mediaControlBtns = document.querySelectorAll('.media-control-btn');
            if (isAdmin || isMod(myName)) {
                mediaControlBtns.forEach(btn => btn.style.display = 'inline-block'); // Show buttons
            } else {
                mediaControlBtns.forEach(btn => btn.style.display = 'none'); // Hide buttons
            }
        }


        // --- L√≥gica de Chat e Comandos ---
        const chatInput = document.getElementById('chatInput');
        const sendChatBtn = document.getElementById('sendChatBtn'); // Get reference to the button

        // Function to send chat message
        function sendChatMessage() {
            const message = chatInput.value.trim();
            if (message) {
                // Check if the current user is muted
                const currentUser = participants.find(p => p.name === myName);
                if (currentUser && currentUser.isMuted) {
                    addPrivateMessage('Voc√™ est√° silenciado e n√£o pode enviar mensagens. üîá', true);
                    chatInput.value = '';
                    return;
                }

                if (message.startsWith('/')) {
                    handleCommand(message);
                } else {
                    // --- Spam and Swearing Detection by Fox ---
                    // Only the admin's Fox instance should perform these checks to avoid duplicate warnings
                    // [SEGURAN√áA]: A detec√ß√£o de spam/palavr√µes √© client-side e pode ser facilmente burlada.
                    // Para um sistema eficaz, isso precisa ser feito no servidor.
                    if (aiChatbotActive && !aiSleeping && isAdmin) { // [MELHORIA]: A detec√ß√£o s√≥ funciona se o admin est√° online e Fox est√° ativa.
                        const sender = myName; // The sender of the current message
                        const now = Date.now();

                        // Update message history for the sender
                        if (!userMessageHistory.has(sender)) {
                            userMessageHistory.set(sender, []);
                        }
                        const history = userMessageHistory.get(sender);
                        history.push({ message: message, timestamp: now });

                        // Keep only recent messages (e.g., last 10 seconds)
                        userMessageHistory.set(sender, history.filter(msg => now - msg.timestamp < 10000));

                        // Check for spam (if the last N messages are very recent from the same user)
                        if (history.length >= SPAM_THRESHOLD_COUNT) {
                            const lastFewMessages = history.slice(-SPAM_THRESHOLD_COUNT);
                            const isSpamming = lastFewMessages.every(msg => now - msg.timestamp < SPAM_THRESHOLD_TIME_MS);
                            if (isSpamming) {
                                addChatMessage('Fox', `@Admin, percebi que ${sender} est√° enviando muitas mensagens rapidamente. Deseja silenci√°-lo? Use /mute ${sender}`);
                                // Clear history for this user to avoid repeated warnings for the same spam burst
                                userMessageHistory.set(sender, []);
                            }
                        }

                        // Check for swearing
                        const lowerCaseMessage = message.toLowerCase();
                        let foundSwearWord = null;
                        for (const regex of SWEAR_WORDS) { // [AJUSTE/BUGFIX]: Iterar sobre regexes
                            if (regex.test(lowerCaseMessage)) { // [AJUSTE/BUGFIX]: Usar test() para regex
                                foundSwearWord = regex.source.replace(/\\b/g, ''); // [AJUSTE/BUGFIX]: Extrair a palavra sem as bordas
                                break;
                            }
                        }

                        if (foundSwearWord) {
                            addChatMessage('Fox', `@Admin, o usu√°rio ${sender} usou linguagem inadequada (palavra ofensiva detectada: "${foundSwearWord}"). Deseja remov√™-lo ou ban√≠-lo? Use /kick ${sender} [motivo] ou /ban ${sender} [motivo] [tempo].`);
                            // Clear history for this user to avoid repeated warnings for the same swear word
                            userMessageHistory.set(sender, []);
                        }
                    }
                    // --- End Spam and Swearing Detection ---

                    addChatMessage(myName, message);
                    // Isso envia a mensagem para outras abas/clientes via localStorage
                    saveChatMessage(`${myName}: ${message}`, 'chat');

                    // Check for @Fox mention to activate
                    if (message.toLowerCase().includes('@fox') && !currentRoomAgeRestricted) {
                        // If Fox is not active, activate her and send the welcome message
                        if (!aiChatbotActive) {
                            aiChatbotActive = true;
                            aiSleeping = false; // Ensure Fox is awake when activated
                            // Add Fox to participants if not already there
                            if (!participants.some(p => p.isAI)) {
                                participants.push({ name: AI_BASE_NAME, isAdmin: false, isMod: false, isAI: true, isMuted: false }); // Add isMuted for AI
                                updateParticipantList(); // This will save to localStorage
                            }
                            updateAIFoxDisplay(); // Ensure display name is correct
                            updateAIBottonVisibility(); // Show AI buttons

                            // [MELHORIA IA]: Incluir o papel do usu√°rio na mensagem inicial da Fox
                            const currentUser = participants.find(p => p.name === myName);
                            let userRoleText = '';
                            if (currentUser && currentUser.isAdmin) {
                                userRoleText = 'o administrador';
                            } else if (currentUser && currentUser.isMod) {
                                userRoleText = 'o moderador';
                            }
                            
                            let initialMessage = "Oii :3.\n";
                            initialMessage += `Como voc√™ est√° ${myName}${userRoleText ? ` (${userRoleText})` : ''}?\n`; // Adiciona o papel aqui

                            let mediaDescription = '';
                            if (currentMediaState.name && currentMediaState.name !== 'Link Externo' && currentMediaState.url) {
                                let mediaTypeDisplay = '';
                                if (currentMediaState.type === 'youtube' || currentMediaState.type === 'vimeo' || currentMediaState.type === 'dailymotion') {
                                    mediaTypeDisplay = 'v√≠deo';
                                } else if (currentMediaState.type === 'twitch_live' || currentMediaState.type === 'twitch_vod') {
                                    mediaTypeDisplay = 'live';
                                } else if (currentMediaState.type === 'file' || currentMediaState.type === 'direct_link') {
                                    mediaTypeDisplay = 'arquivo local';
                                } else {
                                    mediaTypeDisplay = 'm√≠dia';
                                }
                                mediaDescription = `Vejo que voc√™ est√° assistindo a um ${mediaTypeDisplay}: "${currentMediaState.name}".`;
                            } else {
                                mediaDescription = "Parece que n√£o h√° nenhuma m√≠dia sendo reproduzida no momento.";
                            }
                            initialMessage += `${mediaDescription}\n`;

                            const humanParticipantsCount = participants.filter(p => !p.isAI).length;
                            if (humanParticipantsCount > 1) { // If more than just the user who mentioned Fox
                                initialMessage += "E vejo que voc√™ est√° com amigos! Que legal!\n";
                            }

                            initialMessage += "Precisa de alguma ajuda ou s√≥ querem conversar mesmo? :3";
                            addChatMessage('Fox', initialMessage);
                        }
                        
                        // Now, send the rest of the user's message to Fox for a general response
                        // This ensures Fox responds to the full message, even after the initial welcome
                        const userMessageWithoutMention = message.replace(/@fox/gi, '').trim();
                        if (userMessageWithoutMention && !aiSleeping) { // Only respond if not sleeping
                            getAIChatbotResponse(userMessageWithoutMention, myName); // Pass myName here
                        } else if (aiSleeping) {
                            addPrivateMessage('A Fox est√° dormindo e n√£o responder√° at√© que seja acordada com "/AI wake".', true);
                        }

                    } else if (aiChatbotActive && !aiSleeping) {
                        // If Fox is already active, just send the full message to her
                        getAIChatbotResponse(message, myName); // Pass myName here
                    } else if (aiSleeping) {
                        addPrivateMessage('A Fox est√° dormindo e n√£o responder√° at√© que seja acordada com "/AI wake".', true);
                    }
                }
                chatInput.value = '';
            }
        }

        // Event listener for the "Enviar" button (only visible on mobile)
        sendChatBtn.onclick = sendChatMessage;

        // Event listener for Enter key in chat input
        chatInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.keyCode === 13) { // Check for Enter key
                event.preventDefault(); // Prevent newline in textarea
                sendChatMessage(); // Call the send message function
            }
        });

        // Auto-redimensionar o textarea do chat (REMOVIDO CONFORME SOLICITADO)
        /*
        chatInput.addEventListener('input', function () {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });
        */

        // --- Gemini API Integration: Chat Summarizer ---
        document.getElementById('summarizeChatBtn').onclick = async () => {
            if (!roomID) {
                await customAlert('Voc√™ precisa estar em uma sala para resumir o chat.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restri√ß√£o de idade.');
                return;
            }

            addSystemMessage('Gerando resumo do chat... Por favor, aguarde.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o

            try {
                // Get chat messages from localStorage
                const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                if (chatMessages.length === 0) {
                    addSystemMessage('N√£o h√° mensagens no chat para resumir.');
                    return;
                }

                // Format messages for the LLM
                const chatHistoryForLLM = chatMessages.map(msg => {
                    // [AJUSTE/BUGFIX]: Ao resumir, garantir que links sejam representados pelo seu texto ou URL original
                    if (msg.type === 'link') {
                        return `${msg.sender}: ${msg.mediaName || msg.message}`;
                    }
                    return `${msg.message}`; // Simple format: "Sender: Message" or "System Message"
                }).join('\n');

                const prompt = `Por favor, resuma as seguintes mensagens de chat de forma concisa e √∫til. Inclua os principais t√≥picos e decis√µes, se houver. Se n√£o houver conte√∫do significativo, diga "O chat est√° vazio ou n√£o possui t√≥picos claros para resumir.":\n\n${chatHistoryForLLM}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                    addSystemMessage(`N√£o foi poss√≠vel gerar o resumo do chat. Erro da API: ${response.status}. Verifique o console para mais detalhes.`);
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const summary = result.candidates[0].content.parts[0].text;
                    addSystemMessage(`Resumo do Chat: ${summary}`);
                } else {
                    addSystemMessage('N√£o foi poss√≠vel gerar o resumo do chat. A resposta da API estava vazia ou malformada. Verifique o console.');
                    console.error('Gemini API response structure unexpected for summarizer:', result);
                }
            } catch (error) {
                console.error('Error calling Gemini API for summarizer:', error);
                addSystemMessage('Ocorreu um erro ao tentar resumir o chat. Verifique sua conex√£o ou tente novamente.');
            }
        };

        // --- Gemini API Integration: Content Suggester ---
        document.getElementById('suggestContentBtn').onclick = async () => {
            if (!roomID) {
                await customAlert('Voc√™ precisa estar em uma sala para obter sugest√µes de conte√∫do.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restri√ß√£o de idade.');
                return;
            }

            addSystemMessage('Gerando sugest√µes de conte√∫do... Por favor, aguarde.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o

            try {
                let context = '';
                if (currentMediaState.name && currentMediaState.name !== 'Link Externo') {
                    context += `A m√≠dia atual sendo reproduzida √© "${currentMediaState.name}".`;
                } else {
                    const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                    if (chatMessages.length > 0) {
                        // [AJUSTE/BUGFIX]: Ao obter contexto, garantir que links sejam representados pelo seu texto ou URL original
                        const recentMessages = chatMessages.slice(-10).map(msg => {
                            if (msg.type === 'link') {
                                return `${msg.sender}: ${msg.mediaName || msg.message}`;
                            }
                            return msg.message;
                        }).join('\n'); // Last 10 messages
                        context += `As √∫ltimas mensagens do chat s√£o:\n${recentMessages}`;
                    } else {
                        context += 'N√£o h√° m√≠dia sendo reproduzida nem mensagens recentes no chat.';
                    }
                }

                const prompt = `Com base no seguinte contexto, sugira 3-5 ideias de v√≠deos (YouTube, filmes, s√©ries) ou t√≥picos de conversa interessantes para a sala. Seja criativo e conciso. Formate as sugest√µes como uma lista numerada. Se n√£o houver contexto, sugira t√≥picos gerais e populares. Contexto: ${context}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                    addSystemMessage(`N√£o foi poss√≠vel gerar sugest√µes de conte√∫do. Erro da API: ${response.status}. Verifique o console para mais detalhes.`);
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const suggestions = result.candidates[0].content.parts[0].text;
                    addSystemMessage(`Sugest√µes de Conte√∫do:\n${suggestions}`);
                } else {
                    addSystemMessage('N√£o foi poss√≠vel gerar sugest√µes de conte√∫do. A resposta da API estava vazia ou malformada. Verifique o console.');
                    console.error('Gemini API response structure unexpected for content suggester:', result);
                }
            }
            catch (error) {
                console.error('Error calling Gemini API for content suggester:', error);
                addSystemMessage('Ocorreu um erro ao tentar gerar sugest√µes de conte√∫do. Verifique sua conex√£o ou tente novamente.');
            }
        };

        // --- Gemini API Integration: Poll Question Generator ---
        document.getElementById('generatePollBtn').onclick = async () => {
            if (!roomID) {
                await customAlert('Voc√™ precisa estar em uma sala para gerar uma enquete.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restri√ß√£o de idade.');
                return;
            }
            if (activePoll) {
                await customAlert('J√° existe uma enquete ativa. Feche a enquete atual antes de criar uma nova.');
                return;
            }

            addSystemMessage('Gerando pergunta para enquete... Por favor, aguarde.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o

            try {
                let context = '';
                if (currentMediaState.name && currentMediaState.name !== 'Link Externo') {
                    context += `A m√≠dia atual sendo reproduzida √© "${currentMediaState.name}".`;
                } else {
                    const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                    if (chatMessages.length > 0) {
                         // [AJUSTE/BUGFIX]: Ao obter contexto, garantir que links sejam representados pelo seu texto ou URL original
                        const recentMessages = chatMessages.slice(-10).map(msg => {
                            if (msg.type === 'link') {
                                return `${msg.sender}: ${msg.mediaName || msg.message}`;
                            }
                            return msg.message;
                        }).join('\n'); // Last 10 messages
                        context += `As √∫ltimas mensagens do chat s√£o:\n${recentMessages}`;
                    } else {
                        context += 'N√£o h√° m√≠dia sendo reproduzida nem mensagens recentes no chat.';
                    }
                }

                const prompt = `Gere uma pergunta de enquete interessante e concisa (m√°ximo 150 caracteres) baseada no seguinte contexto. Inclua 3-4 op√ß√µes de resposta curtas e variadas. Formate como: 'Pergunta: [Sua pergunta]\nOp√ß√µes:\n1. [Op√ß√£o 1]\n2. [Op√ß√£o 2]\n3. [Op√ß√£o 3]'. Se n√£o houver contexto claro, gere uma pergunta de enquete geral e divertida. Contexto: ${context}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA_API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                    addSystemMessage(`N√£o foi poss√≠vel gerar a pergunta para enquete. Erro da API: ${response.status}. Verifique o console para mais detalhes.`);
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const rawPollText = result.candidates[0].content.parts[0].text;
                    parseAndCreatePoll(rawPollText);
                } else {
                    addSystemMessage('N√£o foi poss√≠vel gerar a pergunta para enquete. A resposta da API estava vazia ou malformada. Verifique o console.');
                    console.error('Gemini API response structure unexpected for poll generator:', result);
                }
            }
            catch (error) {
                console.error('Error calling Gemini API for poll generator:', error);
                addSystemMessage('Ocorreu um erro ao tentar gerar a pergunta para enquete. Verifique sua conex√£o ou tente novamente.');
            }
        };

        // --- Gemini API Integration: Sentiment Analysis ---
        document.getElementById('analyzeSentimentBtn').onclick = analyzeChatSentiment;
        async function analyzeChatSentiment() {
            if (!roomID) {
                await customAlert('Voc√™ precisa estar em uma sala para analisar o sentimento.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restri√ß√£o de idade.');
                return;
            }

            addSystemMessage('Fox est√° analisando o sentimento do chat... Por favor, aguarde.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o

            try {
                const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                if (chatMessages.length === 0) {
                    addSystemMessage('Fox: N√£o h√° mensagens no chat para analisar o sentimento.');
                    return;
                }

                // [AJUSTE/BUGFIX]: Ao obter contexto, garantir que links sejam representados pelo seu texto ou URL original
                const recentMessages = chatMessages.slice(-20).map(msg => {
                    if (msg.type === 'link') {
                        return `${msg.sender}: ${msg.mediaName || msg.message}`;
                    }
                    return msg.message;
                }).join('\n'); // Analyze last 20 messages

                const prompt = `Analise o sentimento geral das seguintes mensagens de chat. Responda com uma frase concisa descrevendo o humor predominante (ex: "O clima no chat est√° animado!", "Parece que o chat est√° um pouco quieto e pensativo.", "O chat tem um ton neutro."). Mensagens:\n\n${recentMessages}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA_API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                    addSystemMessage(`Fox: N√£o consegui analisar o sentimento do chat. Erro da API: ${response.status}. Verifique o console para mais detalhes.`);
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const sentimentAnalysis = result.candidates[0].content.parts[0].text;
                    addChatMessage('Fox', `An√°lise de Sentimento: ${sentimentAnalysis}`);
                } else {
                    addSystemMessage('Fox: N√£o consegui analisar o sentimento do chat. A resposta da API estava vazia ou malformada. Verifique o console.');
                    console.error('Gemini API response structure unexpected for sentiment analysis:', result);
                }
            } catch (error) {
                console.error('Error calling Gemini API for sentiment analysis:', error);
                addSystemMessage('Fox: Ocorreu um erro ao tentar analisar o sentimento. Verifique sua conex√£o ou tente novamente.');
            }
        };

        // --- Gemini API Integration: Creative Prompt Generator ---
        document.getElementById('generateCreativePromptBtn').onclick = generateCreativePrompt;
        async function generateCreativePrompt() {
            if (!roomID) {
                await customAlert('Voc√™ precisa estar em uma sala para gerar uma ideia criativa.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restri√ß√£o de idade.');
                return;
            }

            addSystemMessage('Fox est√° gerando uma ideia criativa... Por favor, aguarde.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o

            try {
                let context = '';
                if (currentMediaState.name && currentMediaState.name !== 'Link Externo') {
                    context += `A m√≠dia atual sendo reproduzida √© "${currentMediaState.name}".`;
                } else {
                    const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                    if (chatMessages.length > 0) {
                        // [AJUSTE/BUGFIX]: Ao obter contexto, garantir que links sejam representados pelo seu texto ou URL original
                        const recentMessages = chatMessages.slice(-10).map(msg => {
                            if (msg.type === 'link') {
                                return `${msg.sender}: ${msg.mediaName || msg.message}`;
                            }
                            return msg.message;
                        }).join('\n');
                        context += `As √∫ltimas mensagens do chat s√£o:\n${recentMessages}`;
                    } else {
                        context += 'N√£o h√° m√≠dia sendo reproduzida nem mensagens recentes no chat.';
                    }
                }

                const prompt = `Gere uma ideia criativa curta e interessante (ex: um in√≠cio de hist√≥ria, um cen√°rio de jogo, uma pergunta "e se...") baseada no seguinte contexto. Se o contexto for limitado, crie algo divertido e aleat√≥rio. Contexto: ${context}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA_API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                    addSystemMessage(`Fox: N√£o consegui gerar uma ideia criativa. Erro da API: ${response.status}. Verifique o console para mais detalhes.`);
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const creativePrompt = result.candidates[0].content.parts[0].text;
                    addChatMessage('Fox', `Aqui est√° uma Ideia Criativa: ${creativePrompt} ‚ú®`);
                } else {
                    addSystemMessage('Fox: N√£o consegui gerar uma ideia criativa. A resposta da API estava vazia ou malformada. Verifique o console.');
                    console.error('Gemini API response structure unexpected for creative prompt:', result);
                }
            } catch (error) {
                console.error('Error calling Gemini API for creative prompt:', error);
                addSystemMessage('Fox: Ocorreu um erro ao tentar gerar uma ideia criativa. Verifique sua conex√£o ou tente novamente.');
            }
        };

        // --- New Gemini API Integration: Trivia Question Generator ---
        document.getElementById('generateTriviaBtn').onclick = async () => {
            if (!roomID) {
                await customAlert('Voc√™ precisa estar em uma sala para gerar uma curiosidade.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restri√ß√£o de idade.');
                return;
            }

            addSystemMessage('Fox est√° pensando em uma curiosidade para voc√™... Por favor, aguarde.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o

            try {
                let context = '';
                if (currentMediaState.name && currentMediaState.name !== 'Link Externo') {
                    context += `A m√≠dia atual sendo reproduzida √© "${currentMediaState.name}".`;
                } else {
                    const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                    if (chatMessages.length > 0) {
                        // [AJUSTE/BUGFIX]: Ao obter contexto, garantir que links sejam representados pelo seu texto ou URL original
                        const recentMessages = chatMessages.slice(-10).map(msg => {
                            if (msg.type === 'link') {
                                return `${msg.sender}: ${msg.mediaName || msg.message}`;
                            }
                            return msg.message;
                        }).join('\n');
                        context += `As √∫ltimas mensagens do chat s√£o:\n${recentMessages}`;
                    } else {
                        context += 'N√£o h√° m√≠dia sendo reproduzida nem mensagens recentes no chat.';
                    }
                }

                const prompt = `Gere uma pergunta de curiosidade ou quiz interessante e sua resposta. A pergunta deve ser concisa. A resposta deve ser clara e vir ap√≥s "Resposta:".
                Exemplo:
                Pergunta: Qual √© o maior oceano do mundo?
                Resposta: O Oceano Pac√≠fico.
                Contexto: ${context}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                    addSystemMessage(`Fox: N√£o consegui gerar uma curiosidade. Erro da API: ${response.status}. Verifique o console para mais detalhes.`);
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const trivia = result.candidates[0].content.parts[0].text;
                    addChatMessage('Fox', `Curiosidade: ${trivia} ‚ú®`);
                } else {
                    addSystemMessage('Fox: N√£o consegui gerar uma curiosidade. A resposta da API estava vazia ou malformada. Verifique o console.');
                    console.error('Gemini API response structure unexpected for trivia generator:', result);
                }
            } catch (error) {
                console.error('Error calling Gemini API for trivia generator:', error);
                addSystemMessage('Fox: Ocorreu um erro ao tentar gerar uma curiosidade. Verifique sua conex√£o ou tente novamente.');
            }
        };

        // --- New Gemini API Integration: Mood-based Media Suggestion ---
        document.getElementById('suggestMoodMediaBtn').onclick = async () => {
            if (!roomID) {
                await customAlert('Voc√™ precisa estar em uma sala para obter sugest√µes de m√≠dia por humor.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restri√ß√£o de idade.');
                return;
            }

            addSystemMessage('Fox est√° analisando o humor do chat para sugerir algo... Por favor, aguarde.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o

            try {
                const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                if (chatMessages.length === 0) {
                    addSystemMessage('Fox: N√£o h√° mensagens no chat para analisar o humor. Tente conversar um pouco mais!');
                    return;
                }

                // [AJUSTE/BUGFIX]: Ao obter contexto, garantir que links sejam representados pelo seu texto ou URL original
                const recentMessages = chatMessages.slice(-20).map(msg => {
                    if (msg.type === 'link') {
                        return `${msg.sender}: ${msg.mediaName || msg.message}`;
                    }
                    return msg.message;
                }).join('\n'); // Analyze last 20 messages

                const prompt = `Com base no sentimento geral das seguintes mensagens de chat, sugira um tipo de m√∫sica ou g√™nero de m√≠dia (filme, s√©rie, v√≠deo do YouTube) que combine com esse humor. Seja criativo e conciso. Responda com uma frase como "O humor do chat √© [humor], ent√£o sugiro [tipo de m√≠dia/g√™nero].". Mensagens:\n\n${recentMessages}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                    addSystemMessage(`Fox: N√£o consegui sugerir m√≠dia por humor. Erro da API: ${response.status}. Verifique o console para mais detalhes.`);
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const moodSuggestion = result.candidates[0].content.parts[0].text;
                    addChatMessage('Fox', `Sugest√£o por Humor: ${moodSuggestion} ‚ú®`);
                } else {
                    addSystemMessage('Fox: N√£o consegui sugerir m√≠dia por humor. A resposta da API estava vazia ou malformada. Verifique o console.');
                    console.error('Gemini API response structure unexpected for mood suggestion:', result);
                }
            } catch (error) {
                console.error('Error calling Gemini API for mood suggestion:', error);
                addSystemMessage('Fox: Ocorreu um erro ao tentar sugerir m√≠dia por humor. Verifique sua conex√£o ou tente novamente.');
            }
        };


        // --- Poll Functionality ---
        function parseAndCreatePoll(rawPollText) {
            const lines = rawPollText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            if (lines.length < 2 || !lines[0].startsWith('Pergunta:')) {
                addSystemMessage('Formato de enquete inv√°lido gerado pela Fox. Tente novamente.'); // Updated message
                return;
            }

            const question = lines[0].replace('Pergunta:', '').trim();
            const options = [];
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].match(/^\d+\./)) { // Checks for "1. Option" format
                    options.push({
                        text: lines[i].replace(/^\d+\./, '').trim(),
                        votes: 0,
                        voters: []
                    });
                }
            }

            if (options.length < 2) {
                addSystemMessage('N√£o foi poss√≠vel extrair op√ß√µes suficientes da enquete gerada pela Fox. Tente novamente.'); // Updated message
                return;
            }

            activePoll = {
                id: `poll-${Date.now()}`,
                question: question,
                options: options
            };
            savePollState();
            displayPollInChat();
            addSystemMessage('Nova enquete criada!');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
        }

        function savePollState() {
            if (roomID && activePoll) {
                localStorage.setItem(LOCAL_STORAGE_ACTIVE_POLL + roomID, JSON.stringify(activePoll));
            } else {
                localStorage.removeItem(LOCAL_STORAGE_ACTIVE_POLL + roomID);
            }
        }

        function loadPollState() {
            if (roomID) {
                const storedPoll = localStorage.getItem(LOCAL_STORAGE_ACTIVE_POLL + roomID);
                if (storedPoll) {
                    activePoll = JSON.parse(storedPoll);
                    displayPollInChat();
                } else {
                    activePoll = null;
                    removePollFromChat();
                }
            }
        }

        function displayPollInChat() {
            removePollFromChat(); // Remove any existing poll display

            if (!activePoll) return;

            const chatLog = document.getElementById('chatLog');
            const pollContainer = document.createElement('div');
            pollContainer.id = 'activePollDisplay';
            pollContainer.className = 'poll-container';

            const questionElem = document.createElement('p');
            questionElem.className = 'poll-question';
            questionElem.textContent = `Enquete: ${activePoll.question}`;
            pollContainer.appendChild(questionElem);

            activePoll.options.forEach((option, index) => {
                const optionBtn = document.createElement('button');
                optionBtn.className = 'poll-option-btn';
                optionBtn.textContent = option.text;
                optionBtn.dataset.optionIndex = index;
                optionBtn.onclick = () => voteOnPoll(index);

                const percentageSpan = document.createElement('span');
                percentageSpan.className = 'poll-percentage';
                percentageSpan.textContent = `(0%)`; // Initial percentage
                optionBtn.appendChild(percentageSpan);

                if (option.voters.includes(myName)) {
                    optionBtn.classList.add('voted');
                }

                pollContainer.appendChild(optionBtn);
            });

            chatLog.appendChild(pollContainer);
            updatePollDisplayPercentages(); // Update percentages immediately
            chatLog.scrollTop = chatLog.scrollHeight;
        }

        function removePollFromChat() {
            const existingPoll = document.getElementById('activePollDisplay');
            if (existingPoll) {
                existingPoll.remove();
            }
        }

        function voteOnPoll(optionIndex) {
            if (!activePoll) {
                customAlert('N√£o h√° uma enquete ativa para votar.');
                return;
            }
            // [BUG]: Se o usu√°rio j√° votou, ele pode votar novamente, o que √© um bug.
            // A l√≥gica `activePoll.options[optionIndex].voters.includes(myName)` verifica se o usu√°rio votou *nesta op√ß√£o*.
            // Mas ele pode ter votado em *outra* op√ß√£o e querer mudar o voto.
            // MELHORIA: A l√≥gica deve permitir mudar o voto, removendo o voto anterior e adicionando o novo.
            // O c√≥digo j√° faz isso: `Remove previous vote if any`, o que √© bom!
            if (activePoll.options[optionIndex].voters.includes(myName)) {
                // Se o usu√°rio j√° votou nesta op√ß√£o espec√≠fica, n√£o precisa fazer nada (ou alertar que j√° votou).
                // O c√≥digo abaixo j√° remove o voto anterior, ent√£o se ele clicar na mesma op√ß√£o, o voto ser√° "removido e adicionado" novamente,
                // resultando em nenhuma mudan√ßa l√≠quida nos votos totais, mas pode ser confuso para o usu√°rio.
                // customAlert('Voc√™ j√° votou nesta op√ß√£o!'); // Descomente se quiser alertar
                // return; // Descomente se quiser impedir cliques repetidos na mesma op√ß√£o
            }

            // Remove previous vote if any
            activePoll.options.forEach(option => {
                const voterIndex = option.voters.indexOf(myName);
                if (voterIndex !== -1) {
                    option.voters.splice(voterIndex, 1);
                    option.votes--;
                }
            });

            // Add new vote
            activePoll.options[optionIndex].votes++;
            activePoll.options[optionIndex].voters.push(myName);

            savePollState(); // Save updated state
            updatePollDisplayPercentages(); // Update UI
            addSystemMessage(`${myName} votou em "${activePoll.options[optionIndex].text}" na enquete.`);
        }

        function updatePollDisplayPercentages() {
            if (!activePoll) return;

            const totalVotes = activePoll.options.reduce((sum, option) => sum + option.votes, 0);
            const pollButtons = document.querySelectorAll('#activePollDisplay .poll-option-btn');

            pollButtons.forEach((button, index) => {
                const option = activePoll.options[index];
                const percentage = totalVotes === 0 ? 0 : ((option.votes / totalVotes) * 100).toFixed(0);
                button.querySelector('.poll-percentage').textContent = `(${percentage}%)`;

                // Highlight voted option
                if (option.voters.includes(myName)) {
                    button.classList.add('voted');
                } else {
                    button.classList.remove('voted');
                }
            });
        }

        // --- AI Buttons Panel Toggle ---
        document.getElementById('toggleAIButtonsBtn').onclick = () => {
            const panel = document.getElementById('aiButtonsPanel');
            panel.classList.toggle('expanded');
        };


        // Fun√ß√£o para controlar a visibilidade dos bot√µes de IA
        function updateAIBottonVisibility() {
            const summarizeBtn = document.getElementById('summarizeChatBtn');
            const toggleAIButtonsBtn = document.getElementById('toggleAIButtonsBtn');
            const aiButtonsPanel = document.getElementById('aiButtonsPanel');
            const analyzeSentimentBtn = document.getElementById('analyzeSentimentBtn');
            const generateCreativePromptBtn = document.getElementById('generateCreativePromptBtn');
            const generateTriviaBtn = document.getElementById('generateTriviaBtn'); // New button
            const suggestMoodMediaBtn = document.getElementById('suggestMoodMediaBtn'); // New button
            const generatePollBtn = document.getElementById('generatePollBtn'); // Add reference to poll button
            const suggestContentBtn = document.getElementById('suggestContentBtn'); // Add reference to suggest content button


            if (currentRoomAgeRestricted) {
                summarizeBtn.style.display = 'none';
                toggleAIButtonsBtn.style.display = 'none';
                aiButtonsPanel.classList.remove('expanded'); // Garante que o painel esteja recolhido
                analyzeSentimentBtn.style.display = 'none';
                generateCreativePromptBtn.style.display = 'none';
                generateTriviaBtn.style.display = 'none'; // Hide new button
                suggestMoodMediaBtn.style.display = 'none'; // Hide new button
                generatePollBtn.style.display = 'none'; // Hide poll button
                suggestContentBtn.style.display = 'none'; // Hide suggest content button
            } else {
                summarizeBtn.style.display = 'flex'; // ou 'block' dependendo do layout
                toggleAIButtonsBtn.style.display = 'flex'; // ou 'block'
                analyzeSentimentBtn.style.display = 'flex';
                generateCreativePromptBtn.style.display = 'flex';
                generateTriviaBtn.style.display = 'flex'; // Show new button
                suggestMoodMediaBtn.style.display = 'flex'; // Show new button
                generatePollBtn.style.display = 'flex'; // Show poll button
                suggestContentBtn.style.display = 'flex'; // Show suggest content button
            }
        }

        // --- AI Chatbot ---
        async function getAIChatbotResponse(userMessage, userName) { // Pass userName here
            // If AI is sleeping, it does not respond to general chat messages.
            if (aiSleeping) {
                return;
            }

            addSystemMessage('Fox est√° pensando...'); // Updated message
            try {
                // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Lida com a sele√ß√£o de m√≠dia num√©rica
                if (foxAwaitingMediaSelection && !isNaN(parseInt(userMessage))) {
                    const selectionIndex = parseInt(userMessage) - 1; // Convert to 0-based index
                    if (selectionIndex >= 0 && selectionIndex < foxAwaitingMediaSelection.length) {
                        const selectedMedia = foxAwaitingMediaSelection[selectionIndex];
                        const playedSuccessfully = playAndBroadcast(selectedMedia.url, selectedMedia.type, selectedMedia.name, true);
                        if (playedSuccessfully) {
                            addChatMessage('Fox', `Ok, ${userName}! Come√ßando a reproduzir "${selectedMedia.name}" para voc√™!`);
                        } else {
                            addChatMessage('Fox', `Ops! N√£o consegui reproduzir "${selectedMedia.name}". Tem certeza que √© um link v√°lido e que eu tenho permiss√£o?`);
                        }
                        foxAwaitingMediaSelection = null; // Clear the selection context
                        foxAwaitingConfirmationForPlay = null; // Clear any confirmation context
                        return; // Exit after handling selection
                    } else {
                        addChatMessage('Fox', `Por favor, ${userName}, digite um n√∫mero v√°lido da lista (1 a ${foxAwaitingMediaSelection.length}).`);
                        return; // Exit, waiting for a valid selection
                    }
                }

                // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Lida com a confirma√ß√£o de reprodu√ß√£o de link espec√≠fico
                if (foxAwaitingConfirmationForPlay) {
                    const userResponseLower = userMessage.toLowerCase();
                    if (userResponseLower.includes('sim') || userResponseLower.includes('quero') || userResponseLower.includes('pode')) {
                        const mediaToPlay = foxAwaitingConfirmationForPlay.media;
                        const playedSuccessfully = playAndBroadcast(mediaToPlay.url, mediaToPlay.type, mediaToPlay.name, true);
                        if (playedSuccessfully) {
                            addChatMessage('Fox', `Ok, ${foxAwaitingConfirmationForPlay.userName}! Come√ßando a reproduzir "${mediaToPlay.name}" para voc√™!`);
                        } else {
                            addChatMessage('Fox', `Ops! N√£o consegui reproduzir "${mediaToPlay.name}". Tem certeza que √© um link v√°lido e que eu tenho permiss√£o?`);
                        }
                        foxAwaitingConfirmationForPlay = null; // Clear the confirmation context
                        foxAwaitingMediaSelection = null; // Clear any numeric selection context
                        return; // Exit
                    } else if (userResponseLower.includes('n√£o') || userResponseLower.includes('nao') || userResponseLower.includes('nao quero') || userResponseLower.includes('cancelar')) {
                        addChatMessage('Fox', `Ok, ${foxAwaitingConfirmationForPlay.userName}. N√£o vou reproduzir "${foxAwaitingConfirmationForPlay.media.name}".`);
                        foxAwaitingConfirmationForPlay = null; // Clear the confirmation context
                        foxAwaitingMediaSelection = null; // Clear any numeric selection context
                        return; // Exit
                    } else {
                        addChatMessage('Fox', `Desculpe, ${foxAwaitingConfirmationForPlay.userName}, n√£o entendi sua resposta. Por favor, diga "sim" ou "n√£o" para reproduzir "${foxAwaitingConfirmationForPlay.media.name}".`);
                        return; // Keep waiting for confirmation
                    }
                }


                let extractedUrl = null;
                const urlRegex = /(https?:\/\/[^\s]+)/g;
                const urlMatches = userMessage.match(urlRegex);
                if (urlMatches && urlMatches.length > 0) {
                    extractedUrl = urlMatches[0]; // Take the first URL found
                }

                // [MELHORIA IA]: Prompt para detec√ß√£o de inten√ß√£o mais robusta, incluindo "stop_media"
                const intentDetectionPrompt = `Analise a seguinte mensagem do usu√°rio e determine a inten√ß√£o principal.
                Responda em JSON com apenas a "intent".
                {
                    "intent": "time_query" | "media_request" | "user_agent_query" | "analyze_link" | "general_chat" | "self_name_query" | "command_execution" | "stop_media"
                }
                Mensagem do usu√°rio: "${userMessage}"`;

                let chatHistoryIntent = [];
                chatHistoryIntent.push({ role: "user", parts: [{ text: intentDetectionPrompt }] }); 

                const intentPayload = {
                    contents: chatHistoryIntent,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "intent": { "type": "STRING", "enum": ["time_query", "media_request", "user_agent_query", "analyze_link", "general_chat", "self_name_query", "command_execution", "stop_media"] }
                            },
                            "propertyOrdering": ["intent"]
                        }
                    }
                };

                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const intentResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(intentPayload)
                });

                if (!intentResponse.ok) {
                    const errorText = await intentResponse.text();
                    console.error(`API Intent Error: ${intentResponse.status} ${intentResponse.statusText} - ${errorText}`);
                    addSystemMessage('Fox: N√£o consegui entender sua inten√ß√£o. Erro da API de inten√ß√£o. Verifique o console.');
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    return;
                }

                const result = await intentResponse.json();
                let parsedIntent = { intent: "general_chat" }; // Default

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    try {
                        parsedIntent = JSON.parse(result.candidates[0].content.parts[0].text);
                    } catch (e) {
                        console.error('Failed to parse intent JSON:', e);
                        // Fallback to general chat if parsing fails
                        parsedIntent = { intent: "general_chat" };
                    }
                }

                // Handle intents
                if (parsedIntent.intent === 'stop_media') { // [NOVA FUNCIONALIDADE]: Lidar com inten√ß√£o de parar m√≠dia
                    if (isAdmin || isMod(myName)) {
                        stopMedia();
                        addChatMessage('Fox', `Ok, ${userName}, parei a m√≠dia no player.`);
                    } else {
                        addChatMessage('Fox', `Desculpe, ${userName}, apenas administradores ou moderadores podem parar a m√≠dia. Mas voc√™ pode usar o comando /stop para isso.`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    return;
                } else if (parsedIntent.intent === 'command_execution') {
                    // NEW: Use LLM to extract the specific command to execute
                    const commandExtractionPrompt = `O usu√°rio quer executar um comando. Com base na mensagem do usu√°rio, identifique o comando exato que ele pretende usar. Se o comando envolver um nome de usu√°rio (como kick, ban, mute, admin, mod), certifique-se de que o nome de usu√°rio seja inclu√≠do. Se for um comando geral como 'limpar hist√≥rico de chat' ou 'recarregar p√°gina', formalize-o para '/clear all' ou '/reload all'. Se o comando for sobre a√ß√µes da IA (sleep, wake, exit, screencast, gerar enquete, fechar enquete, analisar sentimento, ideia criativa, curiosidade, humor), formalize-o para '/AI [subcomando]'. Se o comando for para parar a m√≠dia, formalize-o para '/stop'. Responda apenas com a string do comando formalizado. Se nenhum comando claro puder ser identificado, responda com 'no_command'.
                    Mensagem do usu√°rio: "${userMessage}"`;

                    let commandExtractionHistory = [];
                    commandExtractionHistory.push({ role: "user", parts: [{ text: commandExtractionPrompt }] });

                    const commandExtractionPayload = { contents: commandExtractionHistory };
                    const commandExtractionResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(commandExtractionPayload)
                    });

                    if (!commandExtractionResponse.ok) {
                        const errorText = await commandExtractionResponse.text();
                        console.error(`API Command Extraction Error: ${commandExtractionResponse.status} ${commandExtractionResponse.statusText} - ${errorText}`);
                        addSystemMessage('Fox: N√£o consegui extrair o comando da sua mensagem. Erro na API de extra√ß√£o de comando.');
                        foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                        foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                        return;
                    }

                    const commandExtractionResult = await commandExtractionResponse.json();
                    let extractedCommand = 'no_command';

                    if (commandExtractionResult.candidates && commandExtractionResult.candidates.length > 0 &&
                        commandExtractionResult.candidates[0].content && commandExtractionResult.candidates[0].content.parts &&
                        commandExtractionResult.candidates[0].content.parts.length > 0) {
                        extractedCommand = commandExtractionResult.candidates[0].content.parts[0].text.trim();
                    }

                    if (extractedCommand !== 'no_command') {
                        foxExecuteCommand(extractedCommand, userName); // Pass the extracted, formalized command
                    } else {
                        addChatMessage('Fox', `Desculpe, ${userName}, n√£o consegui identificar um comando claro na sua mensagem. Voc√™ pode digitar "/help" para ver meus comandos.`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    return; // Exit getAIChatbotResponse after command handling
                } else if (parsedIntent.intent === 'self_name_query') {
                    addChatMessage('Fox', `Seu nome √© ${userName}! Prazer em te conhecer (de novo)! üòä`);
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                } else if (parsedIntent.intent === 'analyze_link' && extractedUrl) {
                    addSystemMessage(`Fox: Entendi! Voc√™ quer que eu analise o link: ${extractedUrl}.`);

                    // Check if it's a media URL first, offer to play
                    const { processedUrl, mediaType, mediaName, isValid } = parseMediaLink(extractedUrl);

                    if (isValid) {
                        const confirmPlay = await customConfirm(`Fox: Parece que este √© um link de m√≠dia: ${extractedUrl}. Quer que eu o reproduza no player? (Se escolher "N√£o", eu tentarei te dar informa√ß√µes sobre o link, mas n√£o posso "navegar" nele diretamente.)`);
                        if (confirmPlay) {
                            playAndBroadcast(processedUrl, mediaType, mediaName, true);
                            addChatMessage('Fox', `Come√ßando a reproduzir a m√≠dia de ${extractedUrl}!`);
                            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                            return; // Exit after playing
                        }
                    }

                    // If not a media link or user declined playback, explain limitation
                    addChatMessage('Fox', `Desculpe, n√£o consigo "navegar" diretamente em links externos como ${extractedUrl} do meu ambiente aqui no navegador devido a restri√ß√µes de seguran√ßa (CORS).`);
                    
                    // Ask LLM to summarize the URL string itself
                    const urlSummaryPrompt = `Resuma brevemente o que voc√™ espera encontrar em uma p√°gina com a URL: ${extractedUrl}. Mencione o dom√≠nio principal e o tipo de conte√∫do que a URL sugere.`;
                    let urlSummaryChatHistory = [];
                    urlSummaryChatHistory.push({ role: "user", parts: [{ text: urlSummaryPrompt }] });
                    const urlSummaryPayload = { contents: urlSummaryChatHistory };
                    const urlSummaryResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(urlSummaryPayload)
                    });

                    if (!urlSummaryResponse.ok) {
                        const errorText = await urlSummaryResponse.text();
                        console.error(`API URL Summary Error: ${urlSummaryResponse.status} ${urlSummaryResponse.statusText} - ${errorText}`);
                        addChatMessage('Fox', `N√£o consegui gerar um resumo do link ${extractedUrl}. Erro da API de resumo. Verifique o console.`);
                        foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                        foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                        return;
                    }

                    const urlSummaryResult = await urlSummaryResponse.json();

                    if (urlSummaryResult.candidates && urlSummaryResult.candidates.length > 0 &&
                        urlSummaryResult.candidates[0].content && urlSummaryResult.candidates[0].content.parts &&
                        urlSummaryResult.candidates[0].content.parts.length > 0) {
                        const urlSummaryText = urlSummaryResult.candidates[0].content.parts[0].text;
                        addChatMessage('Fox', `Sobre o link ${extractedUrl}: ${urlSummaryText}`);
                    } else {
                        console.error('Gemini API response structure unexpected for URL summary:', urlSummaryResult);
                        addChatMessage('Fox', `N√£o consegui gerar um resumo do link ${extractedUrl}.`);
                    }

                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    return; // Exit after handling analyze_link
                }

                if (parsedIntent.intent === 'time_query') {
                    if (userMessage.toLowerCase().includes('bras√≠lia')) { // Simple check for "Bras√≠lia"
                        const brasiliaTime = new Date().toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo', hour: '2-digit', minute: '2-digit', second: '2-digit', timeZoneName: 'short' });
                        addChatMessage('Fox', `Em Bras√≠lia, agora s√£o: ${brasiliaTime}.`);
                    } else { // current_location or general time query
                        addLocalTempMessage('Fox', 'Para te dizer as horas exatas da sua localiza√ß√£o, preciso da sua permiss√£o. Por favor, aceite a solicita√ß√£o do navegador.');

                        if (navigator.geolocation) {
                            navigator.geolocation.getCurrentPosition(
                                (position) => {
                                    removeTempMessage(); // Remove the temporary message
                                    const now = new Date();
                                    const localTime = now.toLocaleString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit', timeZoneName: 'short' });
                                    addChatMessage('Fox', `Na sua localiza√ß√£o, agora s√£o: ${localTime}.`);
                                },
                                (error) => {
                                    removeTempMessage(); // Remove the temporary message
                                    let errorMessage = 'N√£o consegui obter sua localiza√ß√£o.';
                                    if (error.code === error.PERMISSION_DENIED) {
                                        errorMessage += ' A permiss√£o foi negada.';
                                    } else if (error.code === error.POSITION_UNAVAILABLE) {
                                        errorMessage += ' A informa√ß√£o de localiza√ß√£o n√£o est√° dispon√≠vel.';
                                    } else if (error.code === error.TIMEOUT) {
                                        errorMessage += ' A solicita√ß√£o de localiza√ß√£o expirou.';
                                    }
                                    addChatMessage('Fox', `Ops! ${errorMessage} N√£o posso te dizer as horas exatas sem ela. üò¢`);
                                    console.error('Geolocation error:', error);
                                },
                                {
                                    enableHighAccuracy: false, // Not strictly needed for time, but good for general location
                                    timeout: 5000, // 5 seconds to get location
                                    maximumAge: 0 // Get fresh location, equivalent to "only this time" for a new request
                                }
                            );
                        } else {
                            removeTempMessage(); // Remove the temporary message
                            addChatMessage('Fox', 'Seu navegador n√£o suporta a API de Geolocation. N√£o posso te dizer as horas exatas da sua localiza√ß√£o. üò¢');
                        }
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                } else if (parsedIntent.intent === 'user_agent_query') {
                    addChatMessage('Fox', `Hmm, deixe-me ver... Seu User Agent √©: "${navigator.userAgent}". √â assim que os navegadores se identificam! üòâ`);
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                } else if (parsedIntent.intent === 'media_request') {
                    // If no URL was extracted, it's a search query
                    if (!extractedUrl) {
                        // New: Use LLM to extract the precise search query AND platform
                        const mediaExtractionPrompt = `Analise a seguinte mensagem do usu√°rio e extraia a frase de busca principal para uma m√≠dia (m√∫sica, v√≠deo, live, etc.) e a plataforma desejada, se especificada. Se a plataforma n√£o for especificada, use "none".
                        Responda em JSON com "search_query" e "platform".
                        Exemplos:
                        User: "Quero ouvir Kami Kam - Ventos de Doutrina no youtube"
                        Response: {"search_query": "Kami Kam - Ventos de Doutrina", "platform": "youtube"}
                        User: "Coloca a live do Alanzoka de ontem na twitch"
                        Response: {"search_query": "live Alanzoka ontem", "platform": "twitch"}
                        User: "procura por ventos de doutrina kami kam pra mim no youtub e e coloca no player favor?"
                        Response: {"search_query": "ventos de doutrina kami kam", "platform": "youtube"}
                        User: "toca aquela m√∫sica legal"
                        Response: {"search_query": "aquela m√∫sica legal", "platform": "none"}
                        User message: "${userMessage}"`;

                        let mediaExtractionHistory = [];
                        mediaExtractionHistory.push({ role: "user", parts: [{ text: mediaExtractionPrompt }] });

                        const mediaExtractionPayload = {
                            contents: mediaExtractionHistory,
                            generationConfig: {
                                responseMimeType: "application/json",
                                responseSchema: {
                                    type: "OBJECT",
                                    properties: {
                                        "search_query": { "type": "STRING" },
                                        "platform": { "type": "STRING", "enum": ["youtube", "twitch", "vimeo", "dailymotion", "none"] }
                                    },
                                    "propertyOrdering": ["search_query", "platform"]
                                }
                            }
                        };

                        const mediaExtractionResponse = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(mediaExtractionPayload)
                        });

                        if (!mediaExtractionResponse.ok) {
                            const errorText = await mediaExtractionResponse.text();
                            console.error(`API Media Extraction Error: ${mediaExtractionResponse.status} ${mediaExtractionResponse.statusText} - ${errorText}`);
                            addChatMessage('Fox', `N√£o consegui entender sua solicita√ß√£o de m√≠dia. Erro na API de extra√ß√£o de m√≠dia.`);
                            foxAwaitingMediaSelection = null;
                            foxAwaitingConfirmationForPlay = null;
                            return;
                        }

                        const mediaExtractionResult = await mediaExtractionResponse.json();
                        let extractedMediaInfo = { search_query: userMessage, platform: "none" }; // Fallback

                        if (mediaExtractionResult.candidates && mediaExtractionResult.candidates.length > 0 &&
                            mediaExtractionResult.candidates[0].content && mediaExtractionResult.candidates[0].content.parts &&
                            mediaExtractionResult.candidates[0].content.parts.length > 0) {
                            try {
                                extractedMediaInfo = JSON.parse(mediaExtractionResult.candidates[0].content.parts[0].text);
                            } catch (e) {
                                console.error('Failed to parse media extraction JSON:', e);
                                // Fallback to original message if parsing fails
                                extractedMediaInfo = { search_query: userMessage, platform: "none" };
                            }
                        }

                        const mediaSearchQuery = extractedMediaInfo.search_query;
                        const targetPlatform = extractedMediaInfo.platform;

                        if (!mediaSearchQuery) {
                            addChatMessage('Fox', `N√£o consegui extrair uma frase de busca v√°lida da sua solicita√ß√£o. Poderia ser mais espec√≠fico?`);
                            foxAwaitingMediaSelection = null;
                            foxAwaitingConfirmationForPlay = null;
                            return;
                        }

                        addSystemMessage(`Fox: Pesquisando por "${mediaSearchQuery}" no ${targetPlatform === 'none' ? 'YouTube, Twitch, Vimeo ou DailyMotion' : targetPlatform}...`);

                        // Simulate search results based on targetPlatform
                        const searchResults = await new Promise(resolve => {
                            let mockResults = [];
                            const baseYoutubeUrl = "https://www.youtube.com/watch?v=";
                            const baseTwitchUrl = "https://twitch.tv/";
                            const baseVimeoUrl = "https://vimeo.com/";
                            const baseDailymotionUrl = "https://www.dailymotion.com/video/";

                            // Prioritize platform if specified
                            if (targetPlatform === 'youtube' || targetPlatform === 'none') {
                                if (mediaSearchQuery.toLowerCase().includes('ventos de doutrina kami kam')) {
                                    mockResults.push({ url: `${baseYoutubeUrl}dQw4w9WgXcQ`, title: "Kami Kam - Ventos de Doutrina (Official Music Video)", source: "YouTube" });
                                } else if (mediaSearchQuery.toLowerCase().includes('minecraft live')) {
                                    mockResults.push({ url: `${baseYoutubeUrl}minecraft_live_1`, title: "Minecraft Live: Construindo Castelos", source: "YouTube" });
                                }
                            }
                            if (targetPlatform === 'twitch' || targetPlatform === 'none') {
                                if (mediaSearchQuery.toLowerCase().includes('alanzoka live')) {
                                    mockResults.push({ url: `${baseTwitchUrl}alanzoka`, title: "Alanzoka - Live Stream", source: "Twitch" });
                                } else if (mediaSearchQuery.toLowerCase().includes('streamer famoso')) {
                                    mockResults.push({ url: `${baseTwitchUrl}streamer_famoso`, title: "Streamer Famoso - Ao Vivo", source: "Twitch" });
                                }
                            }
                            if (targetPlatform === 'vimeo' || targetPlatform === 'none') {
                                if (mediaSearchQuery.toLowerCase().includes('documentario natureza')) {
                                    mockResults.push({ url: `${baseVimeoUrl}123456789`, title: "Document√°rio: A Vida Selvagem", source: "Vimeo" });
                                }
                            }
                            if (targetPlatform === 'dailymotion' || targetPlatform === 'none') {
                                if (mediaSearchQuery.toLowerCase().includes('noticias do dia')) {
                                    mockResults.push({ url: `${baseDailymotionUrl}x123abc`, title: "Not√≠cias do Dia - Edi√ß√£o Especial", source: "DailyMotion" });
                                }
                            }

                            // If no specific platform result, add a generic one for "none" or if no match
                            if (mockResults.length === 0 && targetPlatform === 'none') {
                                mockResults.push({ url: `${baseYoutubeUrl}generic_video_id`, title: `V√≠deo Gen√©rico para "${mediaSearchQuery}"`, source: "YouTube" });
                            } else if (mockResults.length === 0 && targetPlatform !== 'none') {
                                // If a platform was specified but no results, try a generic one for that platform
                                mockResults.push({ url: `${baseYoutubeUrl}generic_video_id`, title: `V√≠deo Gen√©rico para "${mediaSearchQuery}" no ${targetPlatform}`, source: targetPlatform });
                            }

                            resolve([{ query: mediaSearchQuery, results: mockResults }]);
                        });
                        
                        let foundMediaLinks = [];
                        if (searchResults && searchResults.length > 0 && searchResults[0].results) {
                            for (const result of searchResults[0].results) {
                                const { processedUrl: pUrl, mediaType: mType, mediaName: mName, isValid: isV } = parseMediaLink(result.url);
                                if (isV) {
                                    foundMediaLinks.push({ url: pUrl, type: mType, name: mName, originalLink: result.url });
                                }
                            }
                        }

                        if (foundMediaLinks.length > 0) {
                            // User wants only one link if platform is specified, or the first relevant one.
                            const mediaToSuggest = foundMediaLinks[0]; // Take the first most relevant result

                            addClickableLinkMessage('Fox', mediaToSuggest.originalLink, mediaToSuggest.url, mediaToSuggest.type, mediaToSuggest.name);
                            addChatMessage('Fox', `Encontrei "${mediaToSuggest.name}" (${mediaToSuggest.type}). Quer que eu reproduza? (Responda "sim" ou "n√£o")`);
                            
                            // Set a new state to await confirmation for this specific link
                            foxAwaitingConfirmationForPlay = {
                                media: mediaToSuggest,
                                userName: userName // Store userName to use in confirmation response
                            };
                            foxAwaitingMediaSelection = null; // Clear any previous numeric selection context
                        } else {
                            addChatMessage('Fox', `Desculpe, n√£o consegui encontrar nenhuma m√≠dia relevante para "${mediaSearchQuery}" na plataforma ${targetPlatform === 'none' ? 'que procurei' : targetPlatform}.`);
                            foxAwaitingMediaSelection = null;
                            foxAwaitingConfirmationForPlay = null;
                        }
                    } else {
                        // Existing logic for direct URL media requests
                        let playedSuccessfully = false;
                        const { processedUrl, mediaType, mediaName, isValid } = parseMediaLink(extractedUrl);

                        if (isValid) {
                            playedSuccessfully = playAndBroadcast(processedUrl, mediaType, mediaName, true);
                            if (playedSuccessfully) {
                                addChatMessage('Fox', `Claro! Come√ßando a reproduzir para voc√™! Espero que goste! ‚ú®`);
                            } else {
                                addChatMessage('Fox', `Ops! N√£o consegui reproduzir o link. Tem certeza que √© um link v√°lido e que eu tenho permiss√£o?`);
                            }
                        } else {
                            addChatMessage('Fox', `Desculpe, n√£o consigo reproduzir este link diretamente. Parece que n√£o √© um formato de m√≠dia que eu reconhe√ßa para o player.`);
                            return;
                        }
                        foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                        foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    }
                } else {
                    // General conversation
                    // [MELHORIA IA]: Incluir o papel do usu√°rio no prompt geral da Fox
                    const currentUser = participants.find(p => p.name === userName);
                    let userRoleDescription = '';
                    if (currentUser && currentUser.isAdmin) {
                        userRoleDescription = `Voc√™ est√° falando com ${userName}, o administrador da sala.`;
                    } else if (currentUser && currentUser.isMod) {
                        userRoleDescription = `Voc√™ est√° falando com ${userName}, o moderador da sala.`;
                    } else {
                        userRoleDescription = `Voc√™ est√° falando com ${userName}.`;
                    }

                    const generalPrompt = `Voc√™ √© uma chatbot amig√°vel chamada Fox em uma sala de chat com um player de √°udio e v√≠deo HTML/CSS/JS. Voc√™ pode ajudar os usu√°rios com tarefas relacionadas ao player (como reproduzir links, pesquisar conte√∫do) e tamb√©m conversar sobre t√≥picos gerais. ${userRoleDescription} Responda √† seguinte mensagem do usu√°rio de forma concisa e √∫til, mantendo a conversa fluida. Mensagem do usu√°rio: "${userMessage}"`;

                    let generalChatHistory = [];
                    generalChatHistory.push({ role: "user", parts: [{ text: generalPrompt }] });

                    const generalPayload = { contents: generalChatHistory };
                    // START API KEY MODIFICATION
                    const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA_API DO GEMINI AQUI >>>>>>>
                    // END API KEY MODIFICATION
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const generalResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(generalPayload)
                    });

                    if (!generalResponse.ok) {
                        const errorText = await generalResponse.text();
                        console.error(`API General Chat Error: ${generalResponse.status} ${generalResponse.statusText} - ${errorText}`);
                        addSystemMessage('Fox: N√£o consegui gerar uma resposta. Erro da API de chat geral. Verifique o console.');
                        foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                        foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                        return;
                    }

                    const generalResult = await generalResponse.json();

                    if (generalResult.candidates && generalResult.candidates.length > 0 &&
                        generalResult.candidates[0].content && generalResult.candidates[0].content.parts &&
                        generalResult.candidates[0].content.parts.length > 0) {
                        const aiResponse = generalResult.candidates[0].content.parts[0].text;
                        addChatMessage('Fox', aiResponse);
                    } else {
                        addSystemMessage('Fox: N√£o consegui gerar uma resposta. A resposta da API estava vazia ou malformada. Verifique o console.');
                        console.error('Gemini API response structure unexpected for chatbot:', generalResult);
                        // Add more detailed logging for debugging
                        console.error('Full Gemini API response for chatbot:', generalResult);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                }
            } catch (error) {
                console.error('Error calling Gemini API for chatbot:', error);
                addSystemMessage('Fox: Ocorreu um erro ao processar sua mensagem. Verifique sua conex√£o ou tente novamente.');
                foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
            }
        }

        // Function for Fox to execute commands requested by users
        async function foxExecuteCommand(fullCommand, senderName) {
            const parts = fullCommand.toLowerCase().split(' ');
            const command = parts[0];

            // Commands Fox cannot use herself, or execute for others
            const restrictedCommandsForFox = ['/ai', '/mod', '/revoke-mod', '/admin', '/revoke-admin'];
            if (restrictedCommandsForFox.includes(command)) {
                addChatMessage('Fox', `Desculpe, ${senderName}, mas eu n√£o posso executar o comando "${command}". Minhas fun√ß√µes s√£o limitadas para garantir a seguran√ßa da sala.`);
                foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                return;
            }

            // Check if the sender has admin or mod privileges
            const senderIsAdminOrMod = participants.some(p => p.name === senderName && (p.isAdmin || p.isMod));

            // Now, execute based on the command
            switch (command) {
                case '/clear':
                    if (senderIsAdminOrMod) {
                        if (parts[1] === 'all') {
                            localStorage.removeItem(LOCAL_STORAGE_CHAT_PREFIX + roomID);
                            loadChatMessages();
                            addChatMessage('Fox', 'O hist√≥rico do chat foi limpo por solicita√ß√£o do administrador.');
                        } else {
                            addChatMessage('Fox', 'Para limpar o chat, por favor, especifique "/clear all".');
                        }
                    } else {
                        addChatMessage('Fox', `Desculpe, ${senderName}, eu n√£o posso executar o comando "${command}". Apenas administradores e moderadores podem usar este comando.`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    break;
                case '/reload':
                    if (senderIsAdminOrMod) {
                        if (parts[1] === 'all') {
                            addChatMessage('Fox', 'Recarregando a p√°gina para todos na sala por solicita√ß√£o do administrador...');
                            localStorage.setItem(LOCAL_STORAGE_RELOAD_ALL + roomID, 'true');
                            // Admin's own page will reload via storage event listener
                        } else {
                            addChatMessage('Fox', 'Para recarregar, por favor, especifique "/reload all".');
                        }
                    } else {
                        addChatMessage('Fox', `Desculpe, ${senderName}, eu n√£o posso executar o comando "${command}". Apenas administradores e moderadores podem usar este comando.`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    break;
                case '/code':
                    if (roomID) {
                        addChatMessage('Fox', `O c√≥digo da sala √©: ${roomID}`);
                    } else {
                        addChatMessage('Fox', 'N√£o estou em uma sala no momento.');
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    break;
                case '/sendlink': // [NOVA FUNCIONALIDADE]: Fox agora pode "enviar" links clic√°veis
                    if (parts.length > 1) {
                        const link = parts[1];
                        const { processedUrl, mediaType, mediaName, isValid } = parseMediaLink(link);
                        if (isValid) {
                            addClickableLinkMessage('Fox', link, processedUrl, mediaType, mediaName);
                            addChatMessage('Fox', `Link "${mediaName}" enviado por mim! Clique para reproduzir.`);
                        } else {
                            addChatMessage('Fox', `O link "${link}" parece inv√°lido ou n√£o √© um formato de m√≠dia que eu reconhe√ßa.`);
                        }
                    } else {
                        addChatMessage('Fox', 'Para enviar um link, use o formato "/sendlink [link]".');
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    break;
                case '/admin': // Fox will report who the admin is
                    const roomState = loadRoomState(roomID);
                    if (roomState) {
                        const adminParticipant = roomState.participants.find(p => p.isAdmin);
                        if (adminParticipant) {
                            addChatMessage('Fox', `O administrador da sala √©: ${adminParticipant.name}`);
                        } else {
                            addChatMessage('Fox', 'N√£o h√° um administrador definido para esta sala.');
                        }
                    } else {
                        addChatMessage('Fox', 'N√£o foi poss√≠vel carregar o estado da sala para encontrar o administrador.');
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    break;
                case '/version':
                    addChatMessage('Fox', 'Vers√£o do Aplicativo: 0.54.2 (Stable)');
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    break;
                case '/kick':
                    if (senderIsAdminOrMod) {
                        const targetUser = parts[1];
                        const reason = parts.slice(2).join(' ');
                        if (targetUser) {
                            kickUser(targetUser, reason);
                            addChatMessage('Fox', `Comando de expuls√£o executado para ${targetUser} por solicita√ß√£o de ${senderName}.`);
                        } else {
                            addChatMessage('Fox', `Para expulsar, por favor, especifique o nome do usu√°rio: "/kick [Nome] [Motivo (opcional)]".`);
                        }
                    } else {
                        addChatMessage('Fox', `Desculpe, ${senderName}, eu n√£o posso executar comandos de modera√ß√£o diretamente. Por favor, pe√ßa ao administrador para usar o comando "/kick ${parts[1]} ${parts.slice(2).join(' ')}".`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    break;
                case '/ban':
                    if (senderIsAdminOrMod) {
                        const targetUser = parts[1];
                        let banReason = parts.slice(2).join(' ');
                        let banDuration = 0; // 0 for permanent

                        // Check if the last part is a duration (e.g., 10m, 2h)
                        const lastPart = parts[parts.length - 1];
                        const durationMatch = lastPart.match(/^(\d+)([mh])$/);
                        if (durationMatch) {
                            const value = parseInt(durationMatch[1]);
                            const unit = durationMatch[2];
                            if (unit === 'm') {
                                banDuration = value;
                            } else if (unit === 'h') {
                                banDuration = value * 60;
                            }
                            banReason = parts.slice(2, parts.length - 1).join(' '); // Remove duration from reason
                        }
                        if (targetUser) {
                            banUser(targetUser, banReason, banDuration);
                            addChatMessage('Fox', `Comando de banimento executado para ${targetUser} por solicita√ß√£o de ${senderName}.`);
                        } else {
                            addChatMessage('Fox', `Para banir, por favor, especifique o nome do usu√°rio: "/ban [Nome] [Motivo (opcional)] [Tempo (ex: 10m, 2h, 0 para permanente)]".`);
                        }
                    } else {
                        addChatMessage('Fox', `Desculpe, ${senderName}, eu n√£o posso executar comandos de modera√ß√£o diretamente. Por favor, pe√ßa ao administrador para usar o comando "/ban ${parts[1]} ${parts.slice(2).join(' ')}".`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    break;
                case '/mute':
                    if (senderIsAdminOrMod) {
                        const targetUser = parts[1];
                        if (targetUser) {
                            muteUser(targetUser);
                            addChatMessage('Fox', `Comando de silenciar executado para ${targetUser} por solicita√ß√£o de ${senderName}.`);
                        } else {
                            addChatMessage('Fox', `Para silenciar, por favor, especifique o nome do usu√°rio: "/mute [Nome]".`);
                        }
                    } else {
                        addChatMessage('Fox', `Desculpe, ${senderName}, eu n√£o posso executar comandos de modera√ß√£o diretamente. Por favor, pe√ßa ao administrador para usar o comando "/mute ${parts[1]}".`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    break;
                case '/stop': // [NOVA FUNCIONALIDADE]: Comando /stop para parar a m√≠dia
                    if (senderIsAdminOrMod) {
                        stopMedia();
                        addChatMessage('Fox', `Comando de parar m√≠dia executado por solicita√ß√£o de ${senderName}.`);
                    } else {
                        addChatMessage('Fox', `Desculpe, ${senderName}, eu n√£o posso executar o comando "${command}". Apenas administradores e moderadores podem usar este comando.`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    break;
                default:
                    addChatMessage('Fox', `Desculpe, ${senderName}, n√£o entendi o comando "${fullCommand}". Posso te ajudar com outras coisas ou voc√™ pode digitar "/help" para ver meus comandos.`);
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
                    break;
            }
        }


        function showParticipantActionsModal(userName) {
            const modal = document.getElementById('participantActionsModal');
            document.getElementById('actionUserName').textContent = userName;

            // Update mute button text based on user's current mute status
            const targetUser = participants.find(p => p.name === userName);
            const muteButton = document.getElementById('muteUserBtn');
            if (targetUser && targetUser.isMuted) {
                muteButton.textContent = 'Dessilenciar';
                muteButton.style.backgroundColor = '#28a745'; // Green for unmute
            } else {
                muteButton.textContent = 'Silenciar';
                muteButton.style.backgroundColor = '#007bff'; // Blue for mute
            }

            // Set up button actions
            document.getElementById('kickUserBtn').onclick = () => {
                kickUser(userName);
                modal.style.display = 'none';
                foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
            };
            document.getElementById('banUserBtn').onclick = () => {
                banUser(userName);
                modal.style.display = 'none';
                foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
            };
            document.getElementById('muteUserBtn').onclick = () => {
                muteUser(userName);
                modal.style.display = 'none';
                foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia
                foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o
            };

            modal.style.display = 'flex';
        }


        function handleCommand(command) {
            const parts = command.split(' ');
            const cmd = parts[0].toLowerCase();
            const aiSubCommand = parts[1] ? parts[1].toLowerCase() : '';
            const targetUser = parts[1];
            const reason = parts.slice(2).join(' '); // Para motivos de kick/ban
            let duration = 0; // Para banimento

            // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de sele√ß√£o de m√≠dia ao executar um comando
            foxAwaitingMediaSelection = null;
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirma√ß√£o

            switch (cmd) {
                case '/help':
                    addPrivateMessage('Comandos dispon√≠veis:');
                    addPrivateMessage('/Version - Exibe a vers√£o do aplicativo.');
                    addPrivateMessage('/Admin - Mostra quem √© o admin da sala.');
                    addPrivateMessage('/sendlink [link] - Envia um link (vis√≠vel para todos).');
                    addPrivateMessage('/code - Mostra o c√≥digo da sala.');
                    addPrivateMessage('/exit - Sai da sala.');
                    addPrivateMessage('/stop - Para a m√≠dia atual no player.'); // [NOVA FUNCIONALIDADE]: Adicionado ao help
                    addPrivateMessage('/AI sleep - Faz a Fox parar de interagir com o chat.');
                    addPrivateMessage('/AI wake - Faz a Fox voltar a interagir no chat.');
                    addPrivateMessage('/AI exit - Faz a Fox sair da sala.');
                    addPrivateMessage('/AI screencast - Pede ajuda da Fox para analisar sua tela.');
                    addPrivateMessage('/AI gerar enquete [pergunta]? [Op√ß√£o 1]; [Op√ß√£o 2]; ... - Cria uma enquete.');
                    addPrivateMessage('/AI fechar enquete - Encerra a enquete ativa.');
                    addPrivateMessage('/AI analisar sentimento - A Fox analisa o humor do chat.');
                    addPrivateMessage('/AI ideia criativa - A Fox gera uma ideia criativa.');
                    addPrivateMessage('/AI curiosidade - A Fox gera uma pergunta de curiosidade/quiz.'); // New command
                    addPrivateMessage('/AI humor - A Fox sugere m√≠dia baseada no humor do chat.'); // New command
                    if (isAdmin || isMod(myName)) { // Admins and Mods can use these
                        addPrivateMessage('Comandos de Admin/Mod:');
                        addPrivateMessage('/Clear All - Limpa o chat para todos.');
                        addPrivateMessage('/Kick [Nome] [Motivo] - Expulsa um usu√°rio.');
                        addPrivateMessage('/Ban [Nome] [Motivo] [Tempo] - Bane um usu√°rio (ex: 10m, 2h, 0 para permanente).');
                        addPrivateMessage('/Mute [Nome] - Silencia/Dessilencia um usu√°rio.');
                        addPrivateMessage('/reload all - Recarrega a p√°gina para todos na sala.');
                    }
                    if (isAdmin) { // Only Admins can use these
                        addPrivateMessage('Comandos de Admin (apenas):');
                        addPrivateMessage('/Admin [Nome] - Concede admin a algu√©m.');
                        addPrivateMessage('/Revoke-Admin [Nome] - Remove admin de algu√©m.');
                        addPrivateMessage('/Mod [Nome] - Concede moderador a algu√©m.');
                        addPrivateMessage('/Revoke-Mod [Nome] - Remove moderador de algu√©m.');
                        addPrivateMessage('/exitall - Tira todos da sala.');
                    }
                    break;
                case '/version':
                    addSystemMessage('Vers√£o do Aplicativo: 0.54.2 (Stable)');
                    break;
                case '/admin':
                    const roomState = loadRoomState(roomID);
                    if (roomState) {
                        const adminParticipant = roomState.participants.find(p => p.isAdmin);
                        if (adminParticipant) {
                            addSystemMessage(`O administrador da sala √©: ${adminParticipant.name}`);
                        } else {
                            addSystemMessage('N√£o h√° um administrador definido para esta sala.');
                        }
                    } else {
                        addSystemMessage('N√£o foi poss√≠vel carregar o estado da sala para encontrar o administrador.');
                    }
                    break;
                case '/sendlink': // [NOVA FUNCIONALIDADE]: Implementa√ß√£o do /sendlink com link clic√°vel
                    if (parts.length > 1) {
                        const link = parts[1];
                        const { processedUrl, mediaType, mediaName, isValid } = parseMediaLink(link);
                        if (isValid) {
                            addClickableLinkMessage(myName, link, processedUrl, mediaType, mediaName);
                        } else {
                            addPrivateMessage('Link inv√°lido ou n√£o suportado. Certifique-se de que √© uma URL completa e v√°lida de um servi√ßo suportado (YouTube, Twitch, Vimeo, DailyMotion, ou link direto para MP4/MP3/etc.).', true);
                        }
                    } else {
                        addPrivateMessage('Uso: /sendlink [link]', true);
                    }
                    break;
                case '/code':
                    if (roomID) {
                        addPrivateMessage(`O c√≥digo da sala √©: ${roomID}`);
                    } else {
                        addPrivateMessage('Voc√™ n√£o est√° em uma sala.', true);
                    }
                    break;
                case '/exit':
                    addSystemMessage(`${myName} saiu da sala.`);
                    // Remove o participante da lista
                    participants = participants.filter(p => p.name !== myName);
                    updateRoomStateInLocalStorage(); // Sincroniza a remo√ß√£o
                    // Redireciona para a tela inicial
                    showScreen('menuSetup');
                    roomID = '';
                    myName = '';
                    isAdmin = false;
                    waitingForApproval = false;
                    currentJoinRequestId = null;
                    clearTimeout(approvalTimeout);
                    currentRoomAgeRestricted = false; // Reseta a flag de restri√ß√£o de idade
                    aiSleeping = false; // Reset AI sleeping state
                    aiChatbotActive = false; // Reset AI active state
                    updateAIBottonVisibility(); // Garante que os bot√µes de IA voltem ao normal no menu
                    updateMediaControlsVisibility(); // Hide media controls
                    break;
                case '/clear':
                    if ((isAdmin || isMod(myName)) && parts[1] && parts[1].toLowerCase() === 'all') {
                        localStorage.removeItem(LOCAL_STORAGE_CHAT_PREFIX + roomID);
                        loadChatMessages(); // Limpa o chat na UI
                        addSystemMessage('O chat foi limpo por um administrador.');
                    } else if (!isAdmin && !isMod(myName)) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Clear All', true);
                    }
                    break;
                case '/kick':
                    if ((isAdmin || isMod(myName)) && targetUser) {
                        kickUser(targetUser, reason);
                    } else if (!isAdmin && !isMod(myName)) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Kick [Nome] [Motivo (opcional)]', true);
                    }
                    break;
                case '/ban':
                    if ((isAdmin || isMod(myName)) && targetUser) {
                        let banReason = parts.slice(2).join(' ');
                        let banDuration = 0; // 0 for permanent

                        // Check if the last part is a duration (e.g., 10m, 2h)
                        const lastPart = parts[parts.length - 1];
                        const durationMatch = lastPart.match(/^(\d+)([mh])$/);
                        if (durationMatch) {
                            const value = parseInt(durationMatch[1]);
                            const unit = durationMatch[2];
                            if (unit === 'm') {
                                banDuration = value;
                            } else if (unit === 'h') {
                                banDuration = value * 60;
                            }
                            banReason = parts.slice(2, parts.length - 1).join(' '); // Remove duration from reason
                        }

                        banUser(targetUser, banReason, banDuration);
                    } else if (!isAdmin && !isMod(myName)) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Ban [Nome] [Motivo (opcional)] [Tempo (ex: 10m, 2h, 0 para permanente)]', true);
                    }
                    break;
                case '/mute':
                    if ((isAdmin || isMod(myName)) && targetUser) {
                        muteUser(targetUser);
                    } else if (!isAdmin && !isMod(myName)) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Mute [Nome]', true);
                    }
                    break;
                case '/reload':
                    if ((isAdmin || isMod(myName)) && parts[1] && parts[1].toLowerCase() === 'all') {
                        addSystemMessage('Um administrador solicitou o recarregamento da p√°gina para todos.');
                        localStorage.setItem(LOCAL_STORAGE_RELOAD_ALL + roomID, 'true');
                        // For√ßa o recarregamento da pr√≥pria aba do admin tamb√©m
                        window.location.reload();
                    } else if (!isAdmin && !isMod(myName)) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /reload all', true);
                    }
                    break;
                case '/admin':
                    if (isAdmin && targetUser) {
                        setParticipantRole(targetUser, 'isAdmin', true);
                    } else if (!isAdmin) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Admin [Nome]', true);
                    }
                    break;
                case '/revoke-admin':
                    if (isAdmin && targetUser) {
                        setParticipantRole(targetUser, 'isAdmin', false);
                    } else if (!isAdmin) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Revoke-Admin [Nome]', true);
                    }
                    break;
                case '/mod':
                    if (isAdmin && targetUser) {
                        setParticipantRole(targetUser, 'isMod', true);
                    } else if (!isAdmin) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Mod [Nome]', true);
                    }
                    break;
                case '/revoke-mod':
                    if (isAdmin && targetUser) {
                        setParticipantRole(targetUser, 'isMod', false);
                    } else if (!isAdmin) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Revoke-Mod [Nome]', true);
                    }
                    break;
                case '/exitall':
                    if (isAdmin) {
                        addSystemMessage('Um administrador tirou todos da sala.');
                        // Envia um "kick" para todos os participantes, exceto o pr√≥prio admin
                        participants.forEach(p => {
                            if (p.name !== myName) {
                                let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
                                const kickNotificationId = `kick-${p.name}-${roomID}-${Date.now()}`;
                                requests.push({ id: kickNotificationId, roomID: roomID, name: p.name, status: 'rejected', reason: 'Voc√™ foi removido da sala pelo administrador.' });
                                localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
                            }
                        });
                        // Opcional: O admin tamb√©m pode sair ou permanecer. Por enquanto, ele permanece.
                    } else {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    }
                    break;
                case '/me':
                    if (parts.length > 1) {
                        const action = parts.slice(1).join(' ');
                        addSystemMessage(`${myName} ${action}`);
                        saveChatMessage(`${myName} ${action}`, 'system');
                    } else {
                        addPrivateMessage('Uso: /me [sua a√ß√£o]', true);
                    }
                    break;
                case '/nick':
                    if (parts.length > 1) {
                        const newName = parts.slice(1).join(' ').trim();
                        if (newName && newName !== myName) {
                            // Verifica se o novo nome j√° est√° em uso por outro participante na sala atual
                            if (participants.some(p => p.name === newName)) {
                                addPrivateMessage(`O nome "${newName}" j√° est√° em uso nesta sala.`, true);
                            } else {
                                addSystemMessage(`${myName} mudou seu nome para ${newName}.`);
                                // Atualiza o nome na lista de participantes
                                const myParticipant = participants.find(p => p.name === myName);
                                if (myParticipant) {
                                    myParticipant.name = newName;
                                }
                                myName = newName;
                                updateParticipantList(); // Isso ir√° for√ßar a atualiza√ß√£o para todos via localStorage
                                saveChatMessage(`${myName} mudou seu nome para ${newName}.`, 'system');
                            }
                        } else {
                            addPrivateMessage('Uso: /nick [novo_nome]', true);
                        }
                    } else {
                        addPrivateMessage('Uso: /nick [novo_nome]', true);
                    }
                    break;
                case '/ai':
                    if (currentRoomAgeRestricted) {
                        addPrivateMessage('Funcionalidades de IA est√£o desativadas em salas com restri√ß√£o de idade.', true);
                        return;
                    }
                    if (aiSubCommand === 'sleep') {
                        if (!aiChatbotActive) {
                            addPrivateMessage('A Fox n√£o est√° ativa no momento para dormir. Mencione-a com "@Fox" para ativ√°-la.', true);
                            return;
                        }
                        aiSleeping = true;
                        updateAIFoxDisplay(); // Update display to show sleeping status
                        addSystemMessage('A Fox foi dormir. Ela n√£o responder√° a mensagens at√© que seja acordada.');
                    } else if (aiSubCommand === 'wake') {
                        if (!aiChatbotActive) {
                            addPrivateMessage('A Fox n√£o est√° ativa no momento para acordar. Mencione-a com "@Fox" para ativ√°-la.', true);
                            return;
                        }
                        aiSleeping = false;
                        updateAIFoxDisplay(); // Update display to show awake status
                        addSystemMessage('A Fox acordou e est√° pronta para interagir novamente!');
                    } else if (aiSubCommand === 'exit') {
                        if (!aiChatbotActive) {
                            addPrivateMessage('A Fox n√£o est√° ativa no momento para sair.', true);
                            return;
                        }
                        // Remove Fox from participants
                        participants = participants.filter(p => !p.isAI); // Filter out the AI participant
                        aiChatbotActive = false;
                        aiSleeping = false; // Reset sleeping state
                        updateParticipantList(); // Update UI and save state
                        addSystemMessage('A Fox saiu da sala. Sentirei saudades! üò¢');
                    } else if (aiSubCommand === 'screencast') {
                        addChatMessage('Fox', `Para eu te ajudar com o que est√° na sua tela, por favor, descreva o que voc√™ gostaria que eu analisasse ou sobre o que voc√™ quer ajuda. Por exemplo: 'Fox, o que voc√™ acha dessa planilha?' ou 'Fox, me ajude a encontrar informa√ß√µes sobre o que est√° no meu navegador agora.'`);
                    }
                    else if (aiSubCommand === 'gerar' && parts[2] === 'enquete') {
                        if (activePoll) {
                            customAlert('J√° existe uma enquete ativa. Feche a enquete atual antes de criar uma nova.');
                            return;
                        }
                        const pollContent = parts.slice(3).join(' '); // Get the rest of the command
                        if (pollContent.includes('?') && pollContent.includes(';')) {
                            const [questionPart, optionsPart] = pollContent.split('?');
                            const question = questionPart.trim();
                            const options = optionsPart.split(';').map(opt => opt.trim()).filter(opt => opt.length > 0);

                            if (question && options.length >= 2) {
                                activePoll = {
                                    id: `poll-${Date.now()}`,
                                    question: question,
                                    options: options.map(opt => ({ text: opt, votes: 0, voters: [] }))
                                };
                                savePollState();
                                displayPollInChat();
                                addSystemMessage('Nova enquete criada!');
                            } else {
                                addPrivateMessage('Uso: /AI gerar enquete [sua pergunta]? [Op√ß√£o 1]; [Op√ß√£o 2]; [Op√ß√£o 3]; ...', true);
                            }
                        } else {
                            addPrivateMessage('Uso: /AI gerar enquete [sua pergunta]? [Op√ß√£o 1]; [Op√ß√£o 2]; [Op√ß√£o 3]; ...', true);
                        }
                    } else if (aiSubCommand === 'fechar' && parts[2] === 'enquete') {
                        if (activePoll) {
                            activePoll = null;
                            savePollState(); // Clear from localStorage
                            removePollFromChat(); // Remove from UI
                            addSystemMessage('Enquete encerrada.');
                        } else {
                            addPrivateMessage('N√£o h√° enquete ativa para fechar.', true);
                        }
                    } else if (aiSubCommand === 'analisar' && parts[2] === 'sentimento') {
                        analyzeChatSentiment();
                    } else if (aiSubCommand === 'ideia' && parts[2] === 'criativa') {
                        generateCreativePrompt();
                    } else if (aiSubCommand === 'curiosidade') { // New command handler
                        document.getElementById('generateTriviaBtn').click(); // Trigger the button click
                    } else if (aiSubCommand === 'humor') { // New command handler
                        document.getElementById('suggestMoodMediaBtn').click(); // Trigger the button click
                    }
                    else {
                        addPrivateMessage(`Subcomando /AI desconhecido: ${aiSubCommand}. Use '/AI sleep', '/AI wake', '/AI exit', '/AI screencast', '/AI gerar enquete', '/AI fechar enquete', '/AI analisar sentimento', '/AI ideia criativa', '/AI curiosidade', ou '/AI humor'.`, true);
                    }
                    break;
                case '/acuriosidadematouogato': // Hidden command
                    // 1 in 200 chance to execute
                    if (Math.floor(Math.random() * 200) === 0) {
                        addSystemMessage('A curiosidade matou o gato... e talvez esta aba. üòº');
                        // Attempt to close the window/tab.
                        // Note: window.close() only works for tabs/windows opened by script.
                        // For user-opened tabs, it might be ignored or prompt the user.
                        // [BUG/UX]: `window.close()` geralmente n√£o funciona para abas que n√£o foram abertas via `window.open()`.
                        // Isso pode levar a uma experi√™ncia inconsistente.
                        setTimeout(() => {
                            window.close();
                        }, 2000); // Give a moment for the message to show
                    } else {
                        addSystemMessage('A curiosidade n√£o matou o gato desta vez. üòº');
                    }
                    break;
                default:
                    addPrivateMessage(`Comando desconhecido: ${command}. Digite /help para ver os comandos dispon√≠veis.`, true);
            }
        }

        // Inicializa a limpeza de chats antigos ao carregar a p√°gina
        document.addEventListener('DOMContentLoaded', () => {
            cleanOldChatMessages();
            // Exibir o aviso beta inicial
            const betaModal = document.getElementById('betaNoticeModal');
            if (betaModal) {
                betaModal.style.display = 'flex';
                // Opcional: fechar o modal ap√≥s alguns segundos
                setTimeout(() => {
                    betaModal.style.display = 'none';
                }, 5000); // Exibe por 5 segundos
            }
            // Initialize AI states on load
            aiSleeping = false;
            aiChatbotActive = false;
            updateAIBottonVisibility(); // Garante que os bot√µes de IA estejam ocultos no in√≠cio se a sala for restrita
            updateMediaControlsVisibility(); // Hide media controls initially
            loadPollState(); // Carrega o estado da enquete ao iniciar

            // Adiciona event listeners para os bot√µes de modal
            document.getElementById('chooseMediaBtn').onclick = () => {
                document.getElementById('fileMenuModal').style.display = 'flex';
            };
            document.getElementById('showPlaylistBtn').onclick = () => {
                document.getElementById('playlistModal').style.display = 'flex';
            };
            document.getElementById('showParticipantsBtn').onclick = () => {
                document.getElementById('participantListModal').style.display = 'flex';
            };
        });

        // Fechar o modal beta
        document.getElementById('betaNoticeContent').addEventListener('click', () => {
            document.getElementById('betaNoticeModal').style.display = 'none';
        });
    </script>
</body>
</html>
