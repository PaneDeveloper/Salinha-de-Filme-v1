<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Chat + Player Completo</title>
    <style>
        /* Estilos Globais e Reset */
        *{box-sizing:border-box;margin:0;padding:0}
        body{background:#121212;color:#EEE;font-family:Arial,sans-serif;display:flex;flex-direction:column;height:100vh;}
        .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;}

        /* Telas de Setup e Espera (Menu Inicial, Nome, Aprova√ß√£o, Recusado) */
        #menuSetup, #namePrompt, #waitingApproval, #rejectedNotice, #ageVerificationModal {
            padding:1rem; /* */
            display:flex; /* */
            flex-direction:column; /* */
            gap:.5rem; /* */
            align-items:center; /* */
            text-align:center; /* */
            justify-content: center; /* Centraliza verticalmente */
            flex: 1; /* */
        /* Permite que ocupe o espa√ßo dispon√≠vel */
        }

        /* Layout Principal da UI (PC Padr√£o) */
        #mainUI{
            display:none; /* Inicia oculto, ser√° 'flex' ap√≥s login */
            flex:1; /* Ocupa o espa√ßo dispon√≠vel */
            flex-direction:row; /* Player e Chat lado a lado no PC */
            max-width:1200px; /* Largura m√°xima para PCs */
            margin:0 auto; /* Centraliza */
            position:relative;
            padding: 1rem; /* Espa√ßamento interno */
        }

        /* Estilos do Player */
        #playerArea{
            flex:2; /* Ocupa 2/3 do espa√ßo dispon√≠vel */
            background:#222;
            display:flex;
            flex-direction:column;
            align-items:center;
            padding:1rem;
            position:relative;
            border-radius: 8px; /* Bordas arredondadas */
        }
        #mediaPlayerContainer { /* Novo cont√™iner para o player */
            width: 100%;
            max-width: 800px;
            position: relative;
            padding-top: 56.25%; /* Propor√ß√£o 16:9 (altura/largura = 0.5625) */
            background: #000;
            border-radius: 6px;
            overflow: hidden;
        }
        #mediaPlayer, #externalPlayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            background:#000; /* Garante fundo preto para v√≠deo */
            z-index: 1; /* */
        }
        #controls{
            margin:1rem;
            display:flex;
            gap:.5rem;
            flex-wrap:wrap; /* Quebra bot√µes em m√∫ltiplas linhas se necess√°rio */
            position:relative;
            z-index:1;
            justify-content: center; /* Centraliza os bot√µes */
        }
        .btn{
            background:#ff4500;
            border:none; /* */
            color:#FFF;
            padding:.5rem 1rem;
            border-radius:5px;
            cursor:pointer;
            z-index:1;
            font-size: 0.9rem; /* Ajuste para bot√µes */
        }
        .btn:hover {
            opacity: 0.9; /* */
        }

        /* Estilos do Chat */
        #chatArea{
            flex:1; /* Ocupa 1/3 do espa√ßo dispon√≠vel */
            display:flex;
            flex-direction:column;
            background:#1f1f1f;
            border-left:1px solid #333;
            position:relative; /* */
            border-radius: 8px;
            margin-left: 0.5rem; /* Espa√ßamento entre player e chat no PC */
        }
        #chatLog{
            flex:1; /* */
            overflow-y:auto;
            padding:.5rem;
            word-wrap: break-word; /* Quebra palavras longas */
        }
        #chatInputArea{
            padding:.5rem; /* */
            display:flex; /* Usa flexbox para alinhar input e bot√µes */
            gap:.5rem; /* */
            border-top: 1px solid #333; /* Separador para a √°rea de input */
            align-items: flex-end; /* Alinha os itens pela parte de baixo */
        }
        #chatInput{
            flex:1; /* */
            padding:.5rem; /* */
            border-radius:4px;
            border:none;
            background:#222;
            color:#EEE;
            resize: vertical; /* Permite redimensionar verticalmente */
            max-height: 150px; /* Limite de altura para n√£o "estourar" o layout */
            min-height: 40px; /* Altura m√≠nima para o textarea */
            min-width: 100px; /* Largura m√≠nima para o textarea */
            overflow: auto; /* Garante que o conte√∫do tenha scroll se o textarea for menor que o conte√∫do */
        }
        #sendChatBtn, #summarizeChatBtn {
            height: 40px; /* Ajusta altura dos bot√µes para alinhar com o input */
            flex-shrink: 0; /* Impede que os bot√µes diminuam */
            padding: 0.5rem 0.8rem; /* Ajusta padding */
        }
        #summarizeChatBtn {
            background-color: #6a0dad; /* Cor para o bot√£o de resumo (roxo) */
        }
        /* Esconde o bot√£o de enviar por padr√£o (PC) */
        #sendChatBtn {
            display: none;
        }

        /* Estilos dos Modais (Padr√£o para Telas Maiores) */
        #fileMenuModal, #participantListModal, #playlistModal, #betaNoticeModal{
            position:fixed; /* */
            top:0; /* */
            left:0; /* */
            right:0; /* */
            bottom:0; /* */
            background:rgba(0,0,0,0.75);
            display:none;
            justify-content:center;
            align-items:center;
            z-index:9999;
        }
        #fileMenuContent, #participantListContent, #playlistContent, #betaNoticeContent{
            background:#333; /* */
            padding:1.5rem; /* */
            border-radius:8px;
            min-width:320px;
            display:flex;
            flex-direction:column;
            gap:.75rem;
            position:relative;
            max-height:90vh;
            overflow-y:auto;
            color: #FFF; /* Cor do texto no modal */
            font-size: 1.1rem; /* Tamanho da fonte */
        }
        .closeBtn{
            position:absolute; /* */
            top:10px; /* */
            right:10px; /* */
            background:#a00;
            color:#fff;
            border:none;
            border-radius:50%;
            width:24px;
            height:24px;
            font-weight:bold;
            cursor:pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem; /* */
        }

        /* Estilos de Itens da Playlist/Participantes */
        .playlistItem{display:flex;justify-content:space-between;align-items:center;padding:.5rem;margin-bottom:.3rem;background:#2a2a2a; /* */
        border-radius: 4px;}
        .playlistItem span{flex:1;text-align:left;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
        .playlistItem small{opacity:0.7; /* */
        margin-left: 0.5rem;}
        #rejectedNotice img {width: 64px;height: 64px;margin-bottom: 0.5rem;}

        /* Classe para mensagens privadas (comandos) */
        .private-message {
            color: #ff9933; /* Vermelho-alaranjado */
            font-style: italic; /* */
        }
        .system-message {
            color: #aaa;
            font-style: italic; /* */
        }
        .warning-message {
            color: yellow;
            font-style: italic; /* */
        }

        /* Aviso fixo na tela da sala */
        #betaNoticeFixed {
            background-color: #5a0a0a; /* Fundo vermelho escuro */
            color: #fff; /* Texto branco */
            padding: 0.5rem 1rem;
            margin-top: 1rem; /* Espa√ßo acima do aviso */
            text-align: center;
            border-radius: 8px;
            font-size: 0.9rem;
            width: 100%;
            max-width: 800px; /* Alinha com o player */
            margin-left: auto;
            margin-right: auto;
            word-wrap: break-word; /* Quebra texto longo */
        }

        /* Custom Modal Base Styles */
        .custom-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 10000; /* Higher than other modals */
        }

        .custom-modal-content {
            background: #333;
            padding: 2rem;
            border-radius: 8px;
            min-width: 300px;
            max-width: 500px;
            text-align: center;
            color: #EEE;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .custom-modal-content p {
            font-size: 1.1rem;
            margin-bottom: 1rem;
        }

        .custom-modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        .custom-modal-buttons .btn {
            padding: 0.7rem 1.5rem;
            font-size: 1rem;
        }
        /* Age Verification Modal Specific Styles */
        #ageVerificationModal .btn {
            width: 100%;
            padding: 0.8rem;
            font-size: 1rem;
        }
        #ageVerificationModal .btn.minor {
            background-color: #dc3545; /* Red for "Sou menor de idade" */
        }

        /* AI Buttons Panel */
        #aiButtonsPanel {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
            width: 100%;
            max-height: 0; /* Inicia recolhido */
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        #aiButtonsPanel.expanded {
            max-height: 150px; /* Altura suficiente para mostrar os bot√µes */
        }
        #aiButtonsPanel .btn {
            width: 100%;
            background-color: #28a745; /* Cor para sugest√£o */
        }
        #aiButtonsPanel .btn:nth-child(2) { /* Gerar Enquete */
            background-color: #007bff;
        }
        #aiButtonsPanel .btn:nth-child(3) { /* Analisar Sentimento */
            background-color: #ffc107; /* Amarelo */
            color: #333;
        }
        #aiButtonsPanel .btn:nth-child(4) { /* Ideia Criativa */
            background-color: #6f42c1; /* Roxo mais escuro */
        }
        #toggleAIButtonsBtn {
            background-color: #5a0dad; /* Cor para o bot√£o de toggle (roxo escuro) */
        }

        /* Poll Display in Chat */
        .poll-container {
            background-color: #333;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #555;
        }
        .poll-question {
            font-weight: bold;
            margin-bottom: 8px;
            color: #FFF;
        }
        .poll-option-btn {
            background-color: #444;
            color: #FFF;
            border: 1px solid #666;
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 5px;
            width: 100%;
            text-align: left;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
        }
        .poll-option-btn:hover {
            background-color: #555;
        }
        .poll-option-btn.voted {
            background-color: #007bff; /* Highlight if user voted */
        }
        .poll-percentage {
            font-weight: bold;
            color: #FFD700; /* Gold color for percentage */
        }


        /* --- MEDIA QUERIES --- */

        /* Para Telas de Telefone/Tablet (Largura m√°xima de 768px) */
        @media (max-width: 768px) {
            body {
                justify-content: flex-start; /* Alinha o conte√∫do ao topo para n√£o haver espa√ßo vazio */
            }

            /* Menu Inicial, Nome de Usu√°rio, Espera e Recusa */
            #menuSetup, #namePrompt, #waitingApproval, #rejectedNotice, #ageVerificationModal {
                width: 90%; /* Ocupa a maior parte da largura */
                max-width: 400px; /* Mas n√£o fica muito grande */
                margin: auto; /* Centraliza horizontalmente */
                padding: 1.5rem; /* Mais espa√ßamento */
                border-radius: 8px;
                background: #1f1f1f; /* Fundo para se destacar */
            }
            #menuSetup input, #namePrompt input {
                width: 100%; /* */
                padding: 0.8rem;
                font-size: 1rem;
            }
            #menuSetup .btn, #namePrompt .btn, #rejectedNotice .btn {
                width: 100%; /* */
                padding: 0.8rem;
                font-size: 1rem;
            }

            /* Layout Principal dentro da Sala (Mobile) */
            #mainUI{
                flex-direction:column; /* Player em cima, chat embaixo */
                width:100%; /* Ocupa 100% da largura */
                height:100vh; /* Ocupa a altura total da viewport */
                padding:.5rem; /* Menor padding */
            }
            #playerArea{
                width:100%; /* Player ocupa 100% da largura */
                height: auto; /* Altura autom√°tica */
                padding: 0.5rem;
                border-radius: 0; /* Remove bordas arredondadas em mobile para melhor preenchimento */
            }
            #mediaPlayerContainer {
                max-width: none; /* Remove limite de largura para preencher a tela */
                border-radius: 0; /* */
            }
            #controls {
                margin-top: 0.5rem; /* Ajusta margem para os bot√µes */
            }
            #chatArea{
                width:100%; /* Chat ocupa 100% da largura */
                height:150px; /* Altura fixa para o chat em mobile */
                border-left:none; /* Remove borda esquerda */
                border-top:1px solid #333; /* Adiciona borda superior */
                margin-top:.5rem; /* Espa√ßamento entre player e chat */
                margin-left: 0; /* Remove margem esquerda */
                border-radius: 0; /* Remove bordas arredondadas */
            }
            #chatInputArea {
                /* No mobile, os bot√µes ficam ao lado do textarea */
                flex-direction: row; /* Mant√©m em linha */
                align-items: flex-end; /* Alinha na parte de baixo */
                flex-wrap: wrap; /* Permite quebrar bot√µes em nova linha se a tela for muito pequena */
            }
            #chatInput {
                max-height: 100px; /* Limita a altura do input em mobile */
                min-height: 35px; /* */
                resize: vertical; /* Permite redimensionar verticalmente apenas em mobile */
            }
            /* Mostra o bot√£o de enviar no mobile */
            #sendChatBtn {
                display: flex;
                order: 1; /* Coloca o bot√£o de enviar depois do input */
            }
            #summarizeChatBtn {
                order: 2; /* Coloca o bot√£o de resumo depois do enviar */
            }
            #aiButtonsPanel {
                order: 3; /* Coloca o painel de IA depois do resumo */
                width: 100%; /* Ocupa toda a largura */
            }
            #toggleAIButtonsBtn {
                width: 100%; /* Ocupa toda a largura */
            }
            #betaNoticeFixed {
                margin-top: 0.5rem; /* Ajusta margem em mobile */
                max-width: 100%; /* Ocupa largura total */
                border-radius: 0; /* */
            }
        }

        /* Para Telas de TV (Largura m√≠nima de 1600px, adaptando seu breakpoint) */
        @media (min-width: 1600px) {
            #mainUI{
                max-width:1800px; /* Aumenta a largura m√°xima para TVs */
                margin:2rem auto;
                border:1px solid #444; /* */
                border-radius:10px;
                box-shadow:0 0 20px #0008;
                padding: 1.5rem; /* Mais padding interno */
            }

            #playerArea {
                padding: 1.5rem; /* Mais padding interno */
                flex: 3; /* Player ocupa mais espa√ßo */
            }
            #mediaPlayerContainer {
                max-width: 1000px; /* Aumenta o max-width do v√≠deo */
            }

            #chatArea{
                flex: 1; /* Chat ocupa menos espa√ßo proporcionalmente */
                max-width: 350px; /* Largura fixa para o chat em TVs */
                margin-left: 1.5rem; /* Mais espa√ßamento */
                height: auto; /* Altura autom√°tica */
            }

            /* Modais para TV (Posicionados sem cobrir tudo) */
            #fileMenuModal, #participantListModal, #playlistModal, #betaNoticeModal {
                background:rgba(0,0,0,0.5); /* Fundo um pouco mais transparente */
            }
            #fileMenuContent, #participantListContent, #playlistContent, #betaNoticeContent {
                min-width: 400px; /* Aumenta o tamanho m√≠nimo dos modais */
                max-width: 600px;
                position: absolute; /* Permite posicionamento absoluto */
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%); /* Centraliza modais */
            }
            /* Ajuste espec√≠fico para posicionar modais pr√≥ximos ao chat */
            #participantListModal #participantListContent,
            #playlistModal #playlistContent {
                top: 2rem; /* Mais perto do topo */
                right: 2rem; /* Alinhado √† direita */
                left: unset; /* Desativa centraliza√ß√£o horizontal */
                transform: unset; /* Remove transform */
                margin-left: auto; /* Empurra para a direita */
                margin-right: 0; /* */
            }
            #fileMenuModal #fileMenuContent {
                top: 2rem; /* */
                left: 2rem; /* */
                right: unset;
                transform: unset;
                margin-left: 0;
                margin-right: auto; /* */
            }
        }

        /* Estilos para o rejectedNotice (mant√©m o flex-direction) */
        #rejectedNotice {
            flex-direction: column; /* */
            gap: 0.5rem;
            align-items: center;
        }
    </style>
</head>
<body>
    <div id="menuSetup">
        <label for="roomCode" class="sr-only">C√≥digo da sala</label>
        <input id="roomCode" placeholder="C√≥digo da sala (ex: A91J)" maxlength="4" style="text-transform:uppercase" aria-label="Campo para inserir o c√≥digo da sala" />
        <button id="createRoom" class="btn" aria-label="Criar uma nova sala e configurar o nome">Criar Sala</button>
        <button id="joinRoom" class="btn" aria-label="Entrar em uma sala existente com c√≥digo">Entrar na Sala</button>
    </div>

    <div id="namePrompt" style="display:none;">
        <p id="namePromptInstruction" style="color:#CCC; margin-bottom: 0.5rem;"></p>
        <label for="nickname" class="sr-only">Nome de usu√°rio</label>
        <input id="nickname" placeholder="Seu nome de usu√°rio" aria-label="Campo para inserir o seu nome"/>
        <div style="display: flex; align-items: center; gap: 0.5rem; margin-top: 1rem;">
            <input type="checkbox" id="ageRestrictionToggle" aria-label="Ativar restri√ß√£o de idade +18"/>
            <label for="ageRestrictionToggle" style="color:#CCC;">Modo de Restri√ß√£o de Idade +18</label>
        </div>
        <button id="enterRoom" class="btn" aria-label="Confirmar e entrar na sala">Entrar</button>
    </div>

    <div id="waitingApproval" style="display:none;">
        <img src="https://media.tenor.com/On7kvXhzml4AAAAj/loading-gif.gif" alt="Carregando"/>
        <p aria-live="assertive">Esperando o Administrador aceitar sua solicita√ß√£o :D</p>
    </div>

    <div id="rejectedNotice" style="display:none;">
        <img src="https://img.freepik.com/free-icon/cancel_318-10762.jpg" alt="Recusado"/>
        <p>O Administrador (A) da sala recusou a sua solicita√ß√£o de entrada :(</p>
        <button id="retryEntryBtn" class="btn">Tentar novamente</button>
    </div>

    <div id="ageVerificationModal" style="display:none;">
        <div class="custom-modal-content">
            <p>Esta sala possui restri√ß√£o de idade (+18).</p>
            <p>Voc√™ confirma que tem mais de 18 anos para entrar?</p>
            <button id="confirmAgeBtn" class="btn">Tenho mais de 18 anos (Entrar)</button>
            <button id="declineAgeBtn" class="btn minor">Sou menor de idade (Sair)</button>
        </div>
    </div>

    <div id="mainUI">
        <div id="playerArea">
            <div id="mediaPlayerContainer">
                <video id="mediaPlayer" controls autoplay></video>
            </div>
            <div id="betaNoticeFixed" style="display: none;">
                **ATEN√á√ÉO!!! TENHA CUIDADO, VERS√ÉO BETA!!**<br>
                Todo cuidado √© pouco (Por Pane)
            </div>
            <div id="controls">
                <button id="chooseMediaBtn" class="btn" aria-label="Abrir op√ß√µes para adicionar m√≠dia">Escolher Arquivo/Link/Tela</button>
                <button id="showPlaylistBtn" class="btn" aria-label="Ver lista de reprodu√ß√£o">üìÉ Playlist</button>
                <button id="showParticipantsBtn" class="btn" aria-label="Mostrar participantes da sala">üë• Participantes</button>
                
                <!-- Novo bot√£o para expandir/recolher os bot√µes de IA -->
                <button id="toggleAIButtonsBtn" class="btn" aria-label="Alternar visibilidade dos bot√µes de IA">Bot√µes de IA</button>
                
                <!-- Painel recolh√≠vel para os bot√µes de IA -->
                <div id="aiButtonsPanel">
                    <button id="suggestContentBtn" class="btn" aria-label="Sugest√£o de Conte√∫do">Sugest√£o de Conte√∫do ‚ú®</button>
                    <button id="generatePollBtn" class="btn" aria-label="Gerar Enquete">Gerar Enquete ‚ú®</button>
                    <button id="analyzeSentimentBtn" class="btn" aria-label="Analisar Sentimento">Analisar Sentimento ‚ú®</button>
                    <button id="generateCreativePromptBtn" class="btn" aria-label="Gerar Ideia Criativa">Ideia Criativa ‚ú®</button>
                </div>
            </div>
        </div>
        <div id="chatArea">
            <div id="chatLog" aria-live="polite"></div>
            <div id="chatInputArea">
                <label for="chatInput" class="sr-only">Mensagem</label>
                <textarea id="chatInput" placeholder="Digite sua mensagem (m√°x 900 caracteres)" autocomplete="off" aria-label="Campo de mensagem" maxlength="900" rows="2"></textarea>
                <button id="summarizeChatBtn" class="btn" aria-label="Resumir o chat">Resumir Chat ‚ú®</button>
                <button id="sendChatBtn" class="btn" aria-label="Enviar mensagem">Enviar</button>
            </div>
        </div>
    </div>

    <div id="fileMenuModal">
        <div id="fileMenuContent">
            <button class="closeBtn" onclick="document.getElementById('fileMenuModal').style.display='none'" aria-label="Fechar menu de m√≠dia">√ó</button>
            <button id="selectFileBtn" class="btn" aria-label="Escolher um arquivo de v√≠deo ou √°udio do seu dispositivo">Escolher do dispositivo</button>
            <button id="insertLinkBtn" class="btn" aria-label="Inserir um link direto para o v√≠deo">Inserir link de M√©dia</button>
            <button id="shareScreenBtn" class="btn" aria-label="Transmitir a tela ao vivo">Transmitir Tela</button>
        </div>
    </div>

    <div id="participantListModal">
        <div id="participantListContent">
            <button class="closeBtn" onclick="document.getElementById('participantListModal').style.display='none'" aria-label="Fechar lista de participantes">√ó</button>
            <div id="participantList"></div>
        </div>
    </div>

    <div id="playlistModal">
        <div id="playlistContent">
            <button class="closeBtn" onclick="document.getElementById('playlistModal').style.display='none'" aria-label="Fechar lista de reprodu√ß√£o">√ó</button>
            <div id="playlistItems"></div>
        </div>
    </div>

    <div id="betaNoticeModal" style="display: none;">
        <div id="betaNoticeContent">
            <p style="text-align: center;">
                <strong style="color: #FFD700; font-size: 1.3em;">ATEN√á√ÉO!!! TENHA CUIDADO, VERS√ÉO BETA!!</strong><br><br>
                Todo cuidado √© pouco (Por Pane)
            </p>
        </div>
    </div>

    <!-- Custom Alert Modal -->
    <div id="customAlertDialog" class="custom-modal">
        <div class="custom-modal-content">
            <p id="customAlertMessage"></p>
            <button id="customAlertCloseBtn" class="btn">OK</button>
        </div>
    </div>

    <!-- Custom Confirm Modal -->
    <div id="customConfirmDialog" class="custom-modal">
        <div class="custom-modal-content">
            <p id="customConfirmMessage"></p>
            <div class="custom-modal-buttons">
                <button id="customConfirmYesBtn" class="btn">Sim</button>
                <button id="customConfirmNoBtn" class="btn" style="background-color: #dc3545;">N√£o</button>
            </div>
        </div>
    </div>

    <audio id="memeSound" src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg" preload="auto"></audio>

    <script>
        let isCreatingRoom = false;
        let myName = '';
        let roomID = ''; // Vari√°vel global para armazenar o c√≥digo da sala

        let isAdmin = false; // Flag para verificar se o usu√°rio atual √© o administrador
        let approvalTimeout = null;
        let waitingForApproval = false;
        let currentJoinRequestId = null; // Para armazenar o ID do pedido que esta aba enviou
        let currentRoomAgeRestricted = false; // Nova vari√°vel para o estado de restri√ß√£o de idade da sala

        let activePoll = null; // { id: "unique_id", question: "", options: [{ text: "", votes: 0, voters: [] }] }
        let aiChatbotActive = false; // Flag para o chatbot de IA

        // Dados que ser√£o sincronizados via localStorage
        let playlist = [];
        let participants = [];
        let bannedUsers = new Map(); // Map(nomeDoUsuario, { banUntil: timestamp, reason: 'motivo' })

        const LOCAL_STORAGE_PREFIX = 'myChatApp_roomState_';
        const LOCAL_STORAGE_PENDING_REQUESTS = 'myChatApp_pendingJoinRequests';
        const LOCAL_STORAGE_ALL_ROOMS = 'myChatApp_allRooms'; // Chave para todas as salas ativas
        const LOCAL_STORAGE_CHAT_PREFIX = 'myChatApp_chatMessages_'; // Prefixo para mensagens de chat
        const LOCAL_STORAGE_RELOAD_ALL = 'myChatApp_reloadAll_'; // Chave para for√ßar reload
        const LOCAL_STORAGE_ACTIVE_POLL = 'myChatApp_activePoll_'; // Chave para a enquete ativa

        // Custom Alert Function
        function customAlert(message) {
            return new Promise(resolve => {
                const alertDialog = document.getElementById('customAlertDialog');
                const alertMessage = document.getElementById('customAlertMessage');
                const alertCloseBtn = document.getElementById('customAlertCloseBtn');

                alertMessage.textContent = message;
                alertDialog.style.display = 'flex';

                const closeHandler = () => {
                    alertDialog.style.display = 'none';
                    alertCloseBtn.removeEventListener('click', closeHandler);
                    resolve();
                };

                alertCloseBtn.addEventListener('click', closeHandler);
            });
        }

        // Custom Confirm Function
        function customConfirm(message) {
            return new Promise(resolve => {
                const confirmDialog = document.getElementById('customConfirmDialog');
                const confirmMessage = document.getElementById('customConfirmMessage');
                const confirmYesBtn = document.getElementById('customConfirmYesBtn');
                const confirmNoBtn = document.getElementById('customConfirmNoBtn');

                confirmMessage.textContent = message;
                confirmDialog.style.display = 'flex';

                const yesHandler = () => {
                    confirmDialog.style.display = 'none';
                    confirmYesBtn.removeEventListener('click', yesHandler);
                    confirmNoBtn.removeEventListener('click', noHandler);
                    resolve(true);
                };

                const noHandler = () => {
                    confirmDialog.style.display = 'none';
                    confirmYesBtn.removeEventListener('click', yesHandler);
                    confirmNoBtn.removeEventListener('click', noHandler);
                    resolve(false);
                };

                confirmYesBtn.addEventListener('click', yesHandler);
                confirmNoBtn.addEventListener('click', noHandler);
            });
        }

        // --- Fun√ß√µes de Sincroniza√ß√£o com localStorage ---

        function getAllActiveRooms() {
            try {
                const storedRooms = localStorage.getItem(LOCAL_STORAGE_ALL_ROOMS);
                const rooms = storedRooms ? JSON.parse(storedRooms) : [];
                console.log(`[DEBUG_LS] getAllActiveRooms:`, rooms);
                return rooms;
            } catch (e) {
                console.error("Erro ao ler myChatApp_allRooms do localStorage:", e);
                return [];
            }
        }

        function saveAllActiveRooms(roomsArray) {
            try {
                localStorage.setItem(LOCAL_STORAGE_ALL_ROOMS, JSON.stringify(roomsArray));
                console.log(`[DEBUG_LS] saveAllActiveRooms:`, roomsArray);
            } catch (e) {
                console.error("Erro ao salvar myChatApp_allRooms no localStorage:", e);
            }
        }

        function saveRoomState(id, state) {
            try {
                localStorage.setItem(LOCAL_STORAGE_PREFIX + id, JSON.stringify(state));
                console.log(`[DEBUG_LS] Estado da sala ${id} salvo no localStorage. Participants:`, state.participants.map(p => p.name));
            } catch (e) {
                console.error(`Erro ao salvar estado da sala ${id} no localStorage:`, e);
            }
        }

        function loadRoomState(id) {
            try {
                const storedState = localStorage.getItem(LOCAL_STORAGE_PREFIX + id);
                if (storedState) {
                    const state = JSON.parse(storedState);
                    state.bannedUsers = new Map(state.bannedUsers);
                    console.log(`[DEBUG_LS] Estado da sala ${id} carregado do localStorage. Participants:`, state.participants.map(p => p.name));
                    return state;
                }
            } catch (e) {
                console.error(`Erro ao carregar estado da sala ${id} do localStorage:`, e);
            }
            console.log(`[DEBUG_LS] Nenhum estado encontrado para a sala ${id} no localStorage.`);
            return null;
        }

        function updateRoomStateInLocalStorage() {
            if (!roomID) {
                console.log(`[DEBUG_LS] N√£o h√° roomID para atualizar o estado no localStorage.`);
                return; // S√≥ atualiza se estiver em uma sala
            }
            const state = {
                roomID: roomID,
                participants: participants,
                playlist: playlist,
                bannedUsers: Array.from(bannedUsers.entries()), // Converte Map para Array para JSON
                ageRestricted: currentRoomAgeRestricted // Salva o estado de restri√ß√£o de idade
            };
            saveRoomState(roomID, state);
            console.log(`[DEBUG_LS] Estado da sala ${roomID} atualizado no localStorage. Participants:`, state.participants.map(p => p.name));
        }

        function fetchAndUpdateLocalRoomData(id) {
            console.log(`[DEBUG_LS] fetchAndUpdateLocalRoomData called for room: ${id}`);
            const state = loadRoomState(id);
            if (state) {
                participants = state.participants;
                playlist = state.playlist;
                bannedUsers = state.bannedUsers;
                currentRoomAgeRestricted = state.ageRestricted || false; // Carrega o estado de restri√ß√£o de idade
                updateParticipantList(); // Atualiza UI e for√ßa saveRoomState via participantList
                updatePlaylist();       // Atualiza UI e for√ßa saveRoomState via playlist
                updateAIBottonVisibility(); // Atualiza a visibilidade dos bot√µes de IA
                console.log(`[DEBUG_LS] Dados da sala ${id} atualizados localmente. Current participants:`, [...participants]);
            } else {
                console.log(`[DEBUG_LS] Nenhum estado encontrado para a sala ${id}. N√£o foi poss√≠vel atualizar dados locais.`);
            }
        }

        function cleanOldChatMessages() {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(LOCAL_STORAGE_CHAT_PREFIX) && key !== LOCAL_STORAGE_CHAT_PREFIX + roomID) {
                    console.log(`[DEBUG_LS] Removendo chat antigo: ${key}`);
                    localStorage.removeItem(key);
                }
            }
        }

        // --- Listener para eventos de storage (sincroniza√ß√£o entre abas) ---
        window.addEventListener('storage', (event) => {
            // Se o evento for para o estado da sala que estamos, atualiza
            if (event.key && event.key.startsWith(LOCAL_STORAGE_PREFIX)) {
                const changedRoomID = event.key.substring(LOCAL_STORAGE_PREFIX.length);
                if (changedRoomID === roomID) {
                    console.log(`[STORAGE EVENT] Estado da sala ${changedRoomID} mudou. Atualizando dados locais.`);
                    fetchAndUpdateLocalRoomData(changedRoomID);
                    // For√ßa recarregar mensagens do chat se o estado da sala mudar
                    loadChatMessages();
                }
            }
            // Se o evento for para pedidos de entrada pendentes, e esta aba √© a do admin
            if (event.key === LOCAL_STORAGE_PENDING_REQUESTS && isAdmin) {
                console.log(`[STORAGE EVENT] Pedidos pendentes mudaram. Verificando...`);
                handleIncomingJoinRequest();
            }
            // Se o evento for para uma resposta a um pedido de entrada que esta aba enviou
            if (event.key === LOCAL_STORAGE_PENDING_REQUESTS && waitingForApproval) {
                console.log(`[STORAGE EVENT] Verificando resposta para meu pedido de entrada. Event key: ${event.key}, newValue: ${event.newValue}`);
                checkMyJoinRequestStatus();
            }
            // Se o evento for para mensagens de chat da sala atual
            if (event.key === LOCAL_STORAGE_CHAT_PREFIX + roomID) {
                console.log(`[STORAGE EVENT] Mensagens do chat da sala ${roomID} mudaram. Recarregando chat.`);
                loadChatMessages();
            }
            // Se o evento for para for√ßar reload
            if (event.key === LOCAL_STORAGE_RELOAD_ALL + roomID && event.newValue === 'true') {
                if (!isAdmin) { // Apenas clientes n√£o-admin devem recarregar
                    console.log(`[STORAGE EVENT] Comando de recarregar recebido. Recarregando p√°gina...`);
                    localStorage.removeItem(LOCAL_STORAGE_RELOAD_ALL + roomID); // Limpa o flag
                    window.location.reload();
                }
            }
            // Se o evento for para a enquete ativa
            if (event.key === LOCAL_STORAGE_ACTIVE_POLL + roomID) {
                console.log(`[STORAGE EVENT] Enquete ativa mudou. Atualizando.`);
                loadPollState();
            }
             // Handle AI Chatbot auto-deactivation
            if (event.key === LOCAL_STORAGE_PREFIX + roomID) {
                const newState = JSON.parse(event.newValue);
                if (aiChatbotActive && newState && newState.participants.length > 1 && newState.participants.some(p => p.name !== myName)) {
                    aiChatbotActive = false;
                    addSystemMessage('Fox saiu da sala, pois outros participantes entraram.'); // Updated message
                }
            }
        });


        // --- Fun√ß√µes de Pedidos de Entrada (Admin) ---
        // Simula um pedido de entrada sendo colocado no localStorage
        function sendJoinRequest(requestingName, targetRoomID) {
            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            // Adiciona um identificador √∫nico para o pedido para evitar duplicatas e permitir rejei√ß√µes espec√≠ficas
            const requestId = `${targetRoomID}-${requestingName}-${Date.now()}`;
            requests.push({ id: requestId, roomID: targetRoomID, name: requestingName, status: 'pending' });
            localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
            console.log(`[DEBUG] Pedido de entrada de ${requestingName} para ${targetRoomID} enviado. ID: ${requestId}`);
            return requestId; // Retorna o ID do pedido para o cliente que enviou
        }

        // Simula a resposta do administrador para um pedido de entrada
        function respondToJoinRequest(requestId, approved) {
            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            const requestIndex = requests.findIndex(req => req.id === requestId);

            if (requestIndex !== -1) {
                requests[requestIndex].status = approved ? 'approved' : 'rejected';
                localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
                console.log(`[DEBUG] Pedido ${requestId} ${approved ? 'aprovado' : 'rejeitado'}.`);
            }
        }

        // Fun√ß√£o para o administrador verificar e processar pedidos de entrada
        async function handleIncomingJoinRequest() { // Adicionado 'async'
            if (!isAdmin || !roomID) return;

            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            const pendingRequestsForMyRoom = requests.filter(req => req.roomID === roomID && req.status === 'pending');

            if (pendingRequestsForMyRoom.length > 0) {
                for (const request of pendingRequestsForMyRoom) { // Usar for...of para await
                    // Verifica se o usu√°rio j√° est√° na sala para evitar aprova√ß√µes duplicadas
                    const alreadyInRoom = participants.some(p => p.name === request.name);
                    if (alreadyInRoom) {
                        console.log(`[DEBUG] Usu√°rio ${request.name} j√° est√° na sala. Ignorando pedido.`);
                        // Marcar como "aprovado" para limpar o pedido pendente, mesmo que j√° esteja na sala
                        respondToJoinRequest(request.id, true);
                        continue; // Pula para o pr√≥ximo pedido
                    }

                    // Remove o pedido pendente do localStorage *antes* de perguntar
                    // Isso evita que outras abas de admin vejam o mesmo pedido ao mesmo tempo
                    requests = requests.filter(req => req.id !== request.id);
                    localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));

                    const aprovado = await customConfirm(`O participante ${request.name} quer entrar na sala ${request.roomID}. Aceitar?`); // Usar customConfirm
                    respondToJoinRequest(request.id, aprovado);

                    if (aprovado) {
                        addParticipant(request.name, false); // Adiciona como participante normal
                        addSystemMessage(`${request.name} foi aceito na sala.`);
                    } else {
                        addSystemMessage(`${request.name} foi recusado na sala.`);
                    }
                }
            }
        }

        // Inicia a verifica√ß√£o peri√≥dica de pedidos de entrada para o admin (seguran√ßa extra)
        setInterval(() => {
            if (isAdmin && roomID) {
                handleIncomingJoinRequest();
            }
        }, 1000); // Verifica a cada segundo


        // Fun√ß√£o para o cliente verificar o status do seu pedido de entrada
        function checkMyJoinRequestStatus() {
            if (!waitingForApproval || !currentJoinRequestId) return;

            const requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            const myRequest = requests.find(req => req.id === currentJoinRequestId);

            if (myRequest) {
                console.log(`[CLIENT DEBUG] My request status: ${myRequest.status}`);
                if (myRequest.status === 'approved') {
                    console.log(`[CLIENT DEBUG] My request approved! Calling enterRoomConfirmed.`);
                    clearTimeout(approvalTimeout);
                    waitingForApproval = false;
                    currentJoinRequestId = null;
                    addSystemMessage('Voc√™ foi aceito na sala!');
                    enterRoomConfirmed(roomID, myName, false); // Entra na sala como participante
                } else if (myRequest.status === 'rejected') {
                    console.log(`[CLIENT DEBUG] My request rejected! Showing notice.`);
                    clearTimeout(approvalTimeout);
                    waitingForApproval = false;
                    currentJoinRequestId = null;
                    showRejectedNotice(myRequest.reason || 'Sua solicita√ß√£o foi recusada.'); // Adiciona motivo se houver
                }
            } else {
                console.log(`[CLIENT DEBUG] My request (${currentJoinRequestId}) not found in storage. It might have been processed or removed.`);
            }
        }


        // --- Fun√ß√µes Auxiliares de UI/Chat ---
        function addSystemMessage(msg) {
            const chatLog = document.getElementById('chatLog');
            const p = document.createElement('p');
            p.classList.add('system-message');
            p.textContent = msg;
            chatLog.appendChild(p);
            chatLog.scrollTop = chatLog.scrollHeight;
            saveChatMessage(msg, 'system'); // Salva mensagens do sistema no chat
        }

        function addPrivateMessage(msg, isWarning = false) {
            const chatLog = document.getElementById('chatLog');
            const p = document.createElement('p');
            p.classList.add('private-message');
            if (isWarning) {
                p.classList.add('warning-message');
            }
            p.textContent = `[Voc√™]: ${msg}`;
            chatLog.appendChild(p);
            chatLog.scrollTop = chatLog.scrollHeight;
            saveChatMessage(`[Voc√™]: ${msg}`, 'private', isWarning); // Salva mensagens privadas
        }

        function addChatMessage(sender, message) {
            const chatLog = document.getElementById('chatLog');
            const p = document.createElement('p');
            p.textContent = `${sender}: ${message}`;
            chatLog.appendChild(p);
            chatLog.scrollTop = chatLog.scrollHeight;
            saveChatMessage(`${sender}: ${message}`, 'chat'); // Salva mensagens de chat
        }

        // Fun√ß√µes para salvar e carregar mensagens de chat
        function saveChatMessage(message, type, isWarning = false) {
            let chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
            chatMessages.push({ message, type, isWarning, timestamp: Date.now() });
            localStorage.setItem(LOCAL_STORAGE_CHAT_PREFIX + roomID, JSON.stringify(chatMessages));
        }

        function loadChatMessages() {
            const chatLog = document.getElementById('chatLog');
            chatLog.innerHTML = ''; // Limpa o chat atual
            let chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
            chatMessages.forEach(msg => {
                if (msg.type === 'system') {
                    addSystemMessage(msg.message);
                } else if (msg.type === 'private') {
                    addPrivateMessage(msg.message.replace('[Voc√™]: ', ''), msg.isWarning); // Remove o prefixo para addPrivateMessage
                } else {
                    const parts = msg.message.split(': ');
                    const sender = parts.shift();
                    const messageContent = parts.join(': ');
                    addChatMessage(sender, messageContent);
                }
            });
            chatLog.scrollTop = chatLog.scrollHeight;
            loadPollState(); // Garante que a enquete seja carregada ap√≥s as mensagens
        }


        function updateParticipantList() {
            const list = document.getElementById('participantList');
            list.innerHTML = '';
            if (participants.length === 0) {
                list.textContent = 'Nenhum participante na sala.';
                return;
            }
            participants.forEach(p => {
                const div = document.createElement('div');
                div.className = 'playlistItem';
                let role = '';
                if (p.isAdmin) role = '(admin)';
                else if (p.isMod) role = '(mod)';
                div.textContent = `${p.name} ${role}`;

                // Adicionar bot√µes de a√ß√£o para o admin (kick/ban)
                if (isAdmin && p.name !== myName) { // Admin n√£o pode dar kick/ban em si mesmo
                    const kickBtn = document.createElement('button');
                    kickBtn.textContent = 'Kick';
                    kickBtn.className = 'btn';
                    kickBtn.style.marginLeft = '10px';
                    kickBtn.style.backgroundColor = '#dc3545'; // Vermelho
                    kickBtn.onclick = () => kickUser(p.name);
                    div.appendChild(kickBtn);

                    const banBtn = document.createElement('button');
                    banBtn.textContent = 'Ban';
                    banBtn.className = 'btn';
                    banBtn.style.marginLeft = '5px';
                    banBtn.style.backgroundColor = '#6c757d'; // Cinza
                    banBtn.onclick = () => banUser(p.name);
                    div.appendChild(banBtn);
                }
                list.appendChild(div);
            });
            // Importante: Chama saveRoomState aqui para garantir que participantes s√£o persistidos
            updateRoomStateInLocalStorage();
        }


        function updatePlaylist() {
            const list = document.getElementById('playlistItems');
            list.innerHTML = '';
            if (playlist.length === 0) {
                list.textContent = 'Playlist vazia.';
                return;
            }
            playlist.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'playlistItem';
                const span = document.createElement('span');
                span.textContent = item.name;
                const small = document.createElement('small');
                small.textContent = `${item.type.toUpperCase()} - adicionado por ${item.addedBy}`;
                div.appendChild(span);
                div.appendChild(small);

                if (isAdmin) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Remover';
                    deleteBtn.className = 'btn';
                    deleteBtn.style.marginLeft = '10px';
                    deleteBtn.style.backgroundColor = '#dc3545'; // Vermelho
                    deleteBtn.onclick = () => removePlaylistItem(index);
                    div.appendChild(deleteBtn);
                }
                list.appendChild(div);
            });
            // Importante: Chama saveRoomState aqui para garantir que a playlist √© persistida
            updateRoomStateInLocalStorage();
        }

        function removePlaylistItem(index) {
            if (index >= 0 && index < playlist.length) {
                const removedItem = playlist.splice(index, 1);
                addSystemMessage(`Item "${removedItem[0].name}" removido da playlist.`);
                updatePlaylist(); // Atualiza a UI e salva o estado
                // Notificar outros sobre a mudan√ßa na playlist (via storage event)
                updateRoomStateInLocalStorage();
            }
        }


        // --- Fun√ß√µes de gerenciamento de Participantes (Kick/Ban) ---

        function kickUser(userName, reason = 'Sem motivo.') {
            if (!isAdmin) {
                addPrivateMessage('Voc√™ n√£o tem permiss√£o para remover usu√°rios.', true);
                return;
            }
            if (userName === myName) {
                addPrivateMessage('Voc√™ n√£o pode remover a si mesmo.', true);
                return;
            }

            participants = participants.filter(p => p.name !== userName);
            addSystemMessage(`${userName} foi removido da sala. Motivo: ${reason}`);
            updateParticipantList(); // Atualiza a UI e salva o estado
            updateRoomStateInLocalStorage(); // For√ßa a atualiza√ß√£o para que outras abas saibam

            // Informa ao usu√°rio que foi "kickado" atrav√©s de um pedido de rejei√ß√£o espec√≠fico
            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            // Cria um pedido falso rejeitado para notificar o cliente kickado
            const kickNotificationId = `kick-${userName}-${roomID}-${Date.now()}`;
            requests.push({ id: kickNotificationId, roomID: roomID, name: userName, status: 'rejected', reason: `Voc√™ foi removido da sala. Motivo: ${reason}` });
            localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
        }


        function banUser(userName, reason = 'Sem motivo.', durationMinutes = 0) {
            if (!isAdmin) {
                addPrivateMessage('Voc√™ n√£o tem permiss√£o para banir usu√°rios.', true);
                return;
            }
            if (userName === myName) {
                addPrivateMessage('Voc√™ n√£o pode banir a si mesmo.', true);
                return;
            }

            let banUntil = 0;
            let banReasonText = '';

            if (durationMinutes > 0) {
                banUntil = Date.now() + (durationMinutes * 60 * 1000);
                banReasonText = `Banido por ${durationMinutes} minutos.`;
            } else {
                banReasonText = 'Banido permanentemente.';
            }
            if (reason) {
                banReasonText += ` Motivo: ${reason}`;
            }

            bannedUsers.set(userName, { banUntil: banUntil, reason: banReasonText });
            participants = participants.filter(p => p.name !== userName); // Remove da lista de participantes ativos
            addSystemMessage(`${userName} foi banido da sala. ${banReasonText}`);
            updateParticipantList();
            updateRoomStateInLocalStorage();

            // Notifica o usu√°rio banido
            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            const banNotificationId = `ban-${userName}-${roomID}-${Date.now()}`;
            requests.push({ id: banNotificationId, roomID: roomID, name: userName, status: 'rejected', reason: `Voc√™ foi banido da sala. ${banReasonText}` });
            localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
        }


        // Fun√ß√£o para verificar se um usu√°rio est√° banido
        function isUserBanned(userName, roomId) {
            const roomState = loadRoomState(roomId);
            if (roomState && roomState.bannedUsers) {
                const bannedData = roomState.bannedUsers.get(userName);
                if (bannedData) {
                    if (bannedData.banUntil === 0 || bannedData.banUntil > Date.now()) {
                        return true;
                    } else {
                        // Se o banimento expirou, remove da lista de banidos
                        roomState.bannedUsers.delete(userName);
                        saveRoomState(roomId, roomState);
                        return false;
                    }
                }
            }
            return false;
        }

        function findParticipant(name) {
            return participants.find(p => p.name.toLowerCase() === name.toLowerCase());
        }

        function setParticipantRole(userName, role, value) {
            if (!isAdmin) {
                addPrivateMessage('Voc√™ n√£o tem permiss√£o para alterar cargos.', true);
                return;
            }
            if (userName === myName && role === 'isAdmin' && !value) {
                addPrivateMessage('Voc√™ n√£o pode remover seu pr√≥prio status de administrador.', true);
                return;
            }
            const targetUser = findParticipant(userName);
            if (targetUser) {
                targetUser[role] = value;
                addSystemMessage(`${targetUser.name} agora ${value ? '√©' : 'n√£o √© mais'} ${role.replace('is', '')}.`);
                updateParticipantList();
                updateRoomStateInLocalStorage();
            } else {
                addPrivateMessage(`Usu√°rio "${userName}" n√£o encontrado na sala.`, true);
            }
        }


        // --- Fun√ß√µes de Navega√ß√£o e Estados da UI ---
        function showScreen(screenId) {
            document.getElementById('menuSetup').style.display = 'none';
            document.getElementById('namePrompt').style.display = 'none';
            document.getElementById('mainUI').style.display = 'none';
            document.getElementById('waitingApproval').style.display = 'none';
            document.getElementById('rejectedNotice').style.display = 'none';
            document.getElementById('ageVerificationModal').style.display = 'none'; // Esconde o modal de idade
            document.getElementById(screenId).style.display = 'flex'; // Usar 'flex' para as telas modais
        }

        function showRejectedNotice(reason = "O Administrador (A) da sala recusou a sua solicita√ß√£o de entrada :(") {
            document.getElementById('rejectedNotice').querySelector('p').textContent = reason;
            showScreen('rejectedNotice');
        }

        // Fun√ß√£o para gerar um c√≥digo de sala aleat√≥rio
        function generateRoomCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 4; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        // Fun√ß√£o para iniciar a cria√ß√£o de uma sala
        document.getElementById('createRoom').onclick = async () => { // Adicionado 'async'
            let generatedCode = '';
            let isUnique = false;
            let attempts = 0;
            const maxAttempts = 10; // Evitar loop infinito em caso de muitos c√≥digos em uso

            while (!isUnique && attempts < maxAttempts) {
                generatedCode = generateRoomCode();
                const activeRooms = getAllActiveRooms();
                const existingRoom = activeRooms.find(r => r.id === generatedCode);
                if (!existingRoom) {
                    isUnique = true;
                }
                attempts++;
            }

            if (!isUnique) {
                await customAlert('N√£o foi poss√≠vel gerar um c√≥digo de sala √∫nico. Tente novamente.');
                return;
            }

            roomID = generatedCode;
            isCreatingRoom = true;
            showScreen('namePrompt');
            document.getElementById('namePromptInstruction').textContent = `Digite seu nome para criar a sala "${roomID}":`; // Instru√ß√£o para criar sala com c√≥digo gerado
            document.getElementById('nickname').focus();
        };

        // Fun√ß√£o para tentar entrar em uma sala
        document.getElementById('joinRoom').onclick = async () => { // Adicionado 'async'
            roomID = document.getElementById('roomCode').value.trim().toUpperCase();
            if (roomID.length !== 4) {
                await customAlert('O c√≥digo da sala deve ter 4 caracteres.'); // Usar customAlert
                return;
            }

            // Verifica se a sala existe
            const activeRooms = getAllActiveRooms();
            const existingRoom = activeRooms.find(r => r.id === roomID);

            if (!existingRoom) {
                const createNew = await customConfirm(`A sala ${roomID} n√£o existe. Deseja cri√°-la?`); // Usar customConfirm
                if (createNew) {
                    // Se o usu√°rio optar por criar, simula o clique no bot√£o "Criar Sala"
                    // e preenche o input com o c√≥digo para que o fluxo de cria√ß√£o o use.
                    document.getElementById('roomCode').value = roomID; // Preenche o input
                    document.getElementById('createRoom').click();
                }
                return;
            }

            // Carrega o estado da sala para verificar a restri√ß√£o de idade
            const roomState = loadRoomState(roomID);
            currentRoomAgeRestricted = roomState ? roomState.ageRestricted : false;

            if (currentRoomAgeRestricted) {
                showScreen('ageVerificationModal');
            } else {
                // Se n√£o houver restri√ß√£o de idade, procede diretamente para o prompt de nome
                isCreatingRoom = false; // N√£o est√° criando, est√° tentando entrar
                showScreen('namePrompt');
                document.getElementById('namePromptInstruction').textContent = `Digite seu nome para entrar na sala "${roomID}":`; // Instru√ß√£o para entrar na sala
                document.getElementById('nickname').focus();
            }
        };

        // L√≥gica para o bot√£o "Tenho mais de 18 anos (Entrar)"
        document.getElementById('confirmAgeBtn').onclick = async () => {
            myName = document.getElementById('nickname').value.trim(); // Pega o nome do prompt anterior
            if (!myName) {
                await customAlert('Por favor, digite seu nome de usu√°rio.');
                showScreen('namePrompt'); // Volta para o prompt de nome se estiver vazio
                return;
            }

            // Verifica se o nome j√° est√° em uso na sala (para evitar colis√µes)
            const roomState = loadRoomState(roomID);
            if (roomState && roomState.participants.some(p => p.name === myName)) {
                await customAlert(`O nome "${myName}" j√° est√° em uso nesta sala. Escolha outro nome.`);
                showScreen('namePrompt'); // Volta para o prompt de nome
                return;
            }
            
            // Verifica se est√° banido
            if (isUserBanned(myName, roomID)) {
                const bannedReason = roomState.bannedUsers.get(myName)?.reason || 'Voc√™ foi banido desta sala.';
                showRejectedNotice(bannedReason);
                return;
            }

            // Envia o pedido e espera
            waitingForApproval = true;
            currentJoinRequestId = sendJoinRequest(myName, roomID);
            showScreen('waitingApproval');

            // Configura um timeout para caso o admin n√£o responda (opcional)
            approvalTimeout = setTimeout(() => {
                if (waitingForApproval) {
                    showRejectedNotice('Sua solicita√ß√£o expirou ou n√£o foi respondida pelo administrador.');
                    waitingForApproval = false;
                    currentJoinRequestId = null;
                }
            }, 60000); // 1 minuto de timeout
        };

        // L√≥gica para o bot√£o "Sou menor de idade (Sair)"
        document.getElementById('declineAgeBtn').onclick = () => {
            addSystemMessage('Entrada cancelada devido √† restri√ß√£o de idade.');
            window.location.reload(); // Recarrega a p√°gina ou volta para o menu inicial
        };


        // Confirmar nome e processar entrada/cria√ß√£o (chamado ap√≥s o prompt de nome)
        document.getElementById('enterRoom').onclick = async () => { // Adicionado 'async'
            myName = document.getElementById('nickname').value.trim();
            if (!myName) {
                await customAlert('Por favor, digite seu nome de usu√°rio.'); // Usar customAlert
                return;
            }

            if (isCreatingRoom) {
                // Captura o estado do toggle de restri√ß√£o de idade
                currentRoomAgeRestricted = document.getElementById('ageRestrictionToggle').checked;

                // Criar sala: Adiciona a sala √† lista de salas ativas
                let activeRooms = getAllActiveRooms();
                activeRooms.push({ id: roomID, admin: myName, createdAt: Date.now(), ageRestricted: currentRoomAgeRestricted });
                saveAllActiveRooms(activeRooms);

                isAdmin = true;
                enterRoomConfirmed(roomID, myName, true); // Entra como admin
                addSystemMessage(`Voc√™ criou a sala "${roomID}" e √© o administrador.`);
                if (currentRoomAgeRestricted) {
                    addSystemMessage('Modo de Restri√ß√£o de Idade (+18) ativado para esta sala.');
                }
                handleIncomingJoinRequest(); // Come√ßa a ouvir por pedidos
            } else {
                // Entrar em sala: Se chegou aqui, √© porque a sala n√£o tem restri√ß√£o de idade
                // ou o usu√°rio j√° passou pela verifica√ß√£o de idade.
                // Verifica se o nome j√° est√° em uso na sala (para evitar colis√µes)
                const roomState = loadRoomState(roomID);
                if (roomState && roomState.participants.some(p => p.name === myName)) {
                    await customAlert(`O nome "${myName}" j√° est√° em uso nesta sala. Escolha outro nome.`); // Usar customAlert
                    return;
                }
                
                // Verifica se est√° banido novamente (caso a checagem anterior falhe por alguma race condition)
                if (isUserBanned(myName, roomID)) {
                    const bannedReason = roomState.bannedUsers.get(myName)?.reason || 'Voc√™ foi banido desta sala.';
                    showRejectedNotice(bannedReason);
                    return;
                }

                // Envia o pedido e espera
                waitingForApproval = true;
                currentJoinRequestId = sendJoinRequest(myName, roomID);
                showScreen('waitingApproval');

                // Configura um timeout para caso o admin n√£o responda (opcional)
                approvalTimeout = setTimeout(() => {
                    if (waitingForApproval) {
                        showRejectedNotice('Sua solicita√ß√£o expirou ou n√£o foi respondida pelo administrador.');
                        waitingForApproval = false;
                        currentJoinRequestId = null;
                    }
                }, 60000); // 1 minuto de timeout
            }
        };

        // Fun√ß√£o chamada quando a entrada √© confirmada (seja por cria√ß√£o ou aprova√ß√£o)
        function enterRoomConfirmed(id, name, adminStatus) {
            console.log(`[CLIENT DEBUG] enterRoomConfirmed called for room: ${id}, name: ${name}, isAdmin: ${adminStatus}`);
            roomID = id;
            myName = name;
            isAdmin = adminStatus;
            cleanOldChatMessages();
            
            // Explicitamente re-fetch the latest room state just before adding the participant
            // This is to ensure we get the most up-to-date participants list from the admin's approval
            const latestRoomState = loadRoomState(roomID);
            if (latestRoomState) {
                participants = latestRoomState.participants;
                playlist = latestRoomState.playlist;
                bannedUsers = latestRoomState.bannedUsers;
                currentRoomAgeRestricted = latestRoomState.ageRestricted || false;
                console.log(`[CLIENT DEBUG] Re-fetched latest participants in enterRoomConfirmed:`, [...participants]);
            } else {
                console.warn(`[CLIENT DEBUG] Could not load latest room state in enterRoomConfirmed. Initializing participants.`);
                participants = []; // Ensure it's an empty array if no state found
            }

            loadChatMessages(); // Load chat messages based on the potentially updated roomID

            // Now, add the current user to the participants list if they are not already there.
            // This handles cases where the localStorage update might have been delayed or missed.
            if (!participants.some(p => p.name === myName)) {
                participants.push({ name: myName, isAdmin: isAdmin, isMod: false });
                console.log(`[CLIENT DEBUG] Added ${myName} to participants. Final list:`, [...participants]);
                addSystemMessage(`${myName} entrou na sala.`);
            } else {
                console.log(`[CLIENT DEBUG] ${myName} already found in participants list after re-fetch. No need to re-add.`);
                addSystemMessage(`${myName} entrou na sala.`); // Still show the message
            }

            updateParticipantList(); // Update UI and save to localStorage (this will trigger storage event for others)

            if (isAdmin) {
                document.getElementById('betaNoticeFixed').style.display = 'block';
            } else {
                document.getElementById('betaNoticeFixed').style.display = 'none';
            }

            showScreen('mainUI');
            document.getElementById('chatInput').focus();
            updateAIBottonVisibility();
        }

        function addParticipant(name, admin) {
            console.log(`[DEBUG] addParticipant called for: ${name}. Current participants before check:`, [...participants]);
            // Evita adicionar o mesmo participante m√∫ltiplas vezes
            if (!participants.some(p => p.name === name)) {
                participants.push({ name: name, isAdmin: admin, isMod: false });
                console.log(`[DEBUG] ${name} added to participants. New list:`, [...participants]);
                updateParticipantList();
                addSystemMessage(`${name} entrou na sala.`);
            } else {
                console.log(`[DEBUG] ${name} already in participants. Not adding again.`);
            }
        }

        // Lidar com o bot√£o "Tentar novamente" na tela de recusado
        document.getElementById('retryEntryBtn').onclick = () => {
            // Redireciona de volta para a tela inicial para tentar novamente
            showScreen('menuSetup');
            document.getElementById('roomCode').value = '';
            document.getElementById('nickname').value = '';
            roomID = '';
            myName = '';
            isAdmin = false;
            waitingForApproval = false;
            currentJoinRequestId = null;
            clearTimeout(approvalTimeout);
            currentRoomAgeRestricted = false; // Reseta a flag de restri√ß√£o de idade
            updateAIBottonVisibility(); // Garante que os bot√µes de IA voltem ao normal no menu
        };


        // --- Player e M√≠dia ---
        const mediaPlayer = document.getElementById('mediaPlayer');
        const externalPlayer = document.createElement('iframe');
        externalPlayer.id = 'externalPlayer';
        externalPlayer.setAttribute('allow', 'autoplay; encrypted-media; fullscreen');
        externalPlayer.style.display = 'none'; // Inicia oculto

        const mediaPlayerContainer = document.getElementById('mediaPlayerContainer');

        // Modified playAndBroadcast to allow AI initiation
        function playAndBroadcast(url, type, name, initiatedByAI = false) {
            // Allow if isAdmin OR if initiated by AI and AI is active
            if (!isAdmin && !initiatedByAI) {
                addPrivateMessage('Apenas o administrador pode controlar a m√≠dia.', true);
                return false; // Indicate failure
            }

            // Adiciona √† playlist
            playlist.push({ url: url, type: type, name: name, addedBy: initiatedByAI ? 'Fox' : myName }); // Added Fox as source
            updatePlaylist();

            // Limpa player anterior se for o caso
            mediaPlayer.style.display = 'none';
            externalPlayer.style.display = 'none';
            if (externalPlayer.parentNode) {
                externalPlayer.parentNode.removeChild(externalPlayer);
            }
            
            // Reproduz a m√≠dia
            if (type === 'file' || type === 'direct_link') {
                mediaPlayer.src = url;
                mediaPlayer.style.display = 'block';
                mediaPlayer.load();
                mediaPlayer.play();
            } else if (['youtube', 'twitch_vod', 'twitch_live', 'vimeo', 'dailymotion'].includes(type)) {
                externalPlayer.src = url;
                mediaPlayerContainer.appendChild(externalPlayer);
                externalPlayer.style.display = 'block';
            } else if (type === 'screen') {
                // Implementa√ß√£o de compartilhamento de tela (complexo, fora do escopo do fix atual)
                addSystemMessage('Compartilhamento de tela n√£o totalmente implementado para sincroniza√ß√£o multi-cliente.');
                return false;
            }
            addSystemMessage(`Reproduzindo: "${name}" (${type})`);
            // Sincroniza o estado do player (URL atual, tempo, etc.) para outros participantes
            syncPlayerState({ url: url, type: type, name: name, currentTime: 0, paused: false });
            return true; // Indicate success
        }

        // Inserir link
        document.getElementById('insertLinkBtn').onclick = async () => { // Adicionado 'async'
            // Usar prompt nativo para input de texto simples, pois customPrompt √© para confirma√ß√£o
            const url = prompt('Insira o link do v√≠deo, √°udio ou live (YouTube, Twitch, Vimeo, DailyMotion, SoundCloud):');
            if (!url) return;

            let mediaType = 'link';
            let mediaName = 'Link Externo';
            let processedUrl = url;
            let isValidEmbedOrDirectLink = false;

            const youtubeMatch = url.match(/(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
            const twitchMatch = url.match(/(?:twitch\.tv\/([a-zA-Z0-9_]+)(?:\/videos\/(\d+))?)/);
            const vimeoMatch = url.match(/(?:vimeo\.com\/(?:video\/)?([0-9]+))/);
            const dailymotionMatch = url.match(/(?:dailymotion\.com\/(?:video|hub)\/([a-zA-Z0-9]+))/);
            const soundcloudMatch = url.match(/(?:soundcloud\.com|snd\.sc)\/(.*)/);
            const directMediaMatch = /\.(mp4|webm|ogg|mp3|wav)(\?.*)?$/i.test(url);


            if (youtubeMatch) {
                processedUrl = `https://www.youtube.com/embed/${youtubeMatch[1]}?autoplay=1&controls=1`; // CORRIGIDO: URL correta para embed do YouTube
                mediaName = 'YouTube Video';
                mediaType = 'youtube';
                isValidEmbedOrDirectLink = true;
            } else if (twitchMatch) {
                const channel = twitchMatch[1];
                const videoId = twitchMatch[2];
                if (videoId) { // Twitch VOD
                    processedUrl = `https://player.twitch.tv/?video=${videoId}&parent=${window.location.hostname}&autoplay=true`;
                    mediaName = 'Twitch VOD';
                    mediaType = 'twitch_vod';
                } else { // Twitch Live Stream
                    processedUrl = `https://player.twitch.tv/?channel=${channel}&parent=${window.location.hostname}&autoplay=true`;
                    mediaName = `Twitch Live: ${channel}`;
                    mediaType = 'twitch_live';
                }
                isValidEmbedOrDirectLink = true;
            } else if (vimeoMatch) {
                processedUrl = `https://player.vimeo.com/video/${vimeoMatch[1]}?autoplay=1`;
                mediaName = 'Vimeo Video';
                mediaType = 'vimeo';
                isValidEmbedOrDirectLink = true;
            } else if (dailymotionMatch) {
                processedUrl = `https://www.dailymotion.com/embed/video/${dailymotionMatch[1]}?autoplay=1`;
                mediaName = 'DailyMotion Video';
                mediaType = 'dailymotion';
                isValidEmbedOrDirectLink = true;
            } else if (directMediaMatch) {
                mediaType = 'direct_link';
                mediaName = url.substring(url.lastIndexOf('/') + 1); // Nome do arquivo
                isValidEmbedOrDirectLink = true;
            } else {
                await customAlert('Link inv√°lido ou n√£o suportado. Tente um link direto para um arquivo de m√≠dia ou URLs de YouTube, Twitch, Vimeo, DailyMotion, SoundCloud.'); // Usar customAlert
                return;
            }

            if (isValidEmbedOrDirectLink) {
                playAndBroadcast(processedUrl, mediaType, mediaName);
                document.getElementById('fileMenuModal').style.display = 'none';
            } else {
                await customAlert('Link inv√°lido ou n√£o suportado para embed. Tente um link direto para um arquivo de m√≠dia ou URLs de YouTube, Twitch, Vimeo, DailyMotion, SoundCloud.'); // Usar customAlert
            }
        };

        document.getElementById('shareScreenBtn').onclick = async () => {
            if (!isAdmin) {
                addPrivateMessage('Apenas o administrador pode transmitir a tela.', true);
                return;
            }
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                mediaPlayer.srcObject = stream;
                mediaPlayer.style.display = 'block';
                if (externalPlayer.parentNode) {
                    externalPlayer.parentNode.removeChild(externalPlayer);
                }
                externalPlayer.style.display = 'none';
                mediaPlayer.play();
                addSystemMessage('Compartilhando sua tela. Outros usu√°rios ver√£o seu stream em breve.');
                // Para sincronizar, voc√™ precisaria de um servidor de streaming de verdade
                // Aqui, apenas simula o play localmente
                document.getElementById('fileMenuModal').style.display = 'none';
            } catch (err) {
                console.error('Erro ao iniciar compartilhamento de tela:', err);
                addPrivateMessage('N√£o foi poss√≠vel iniciar o compartilhamento de tela.', true);
            }
        };


        // Fun√ß√£o de sincroniza√ß√£o do player (simplificada para localStorage)
        // Em um sistema real, isso seria via WebSockets
        let currentMediaState = { url: '', type: '', name: '', currentTime: 0, paused: true };

        function syncPlayerState(newState) {
            if (isAdmin) { // Apenas o admin envia o estado do player
                currentMediaState = newState;
                localStorage.setItem(LOCAL_STORAGE_PREFIX + roomID + '_player', JSON.stringify(currentMediaState));
                console.log('[DEBUG_PLAYER] Estado do player sincronizado (admin).', currentMediaState);
            }
        }

        // Listener para o estado do player
        window.addEventListener('storage', (event) => {
            if (event.key === LOCAL_STORAGE_PREFIX + roomID + '_player' && !isAdmin) {
                try {
                    const newState = JSON.parse(event.newValue);
                    if (newState && newState.url !== currentMediaState.url) { // Se a URL mudou, carregar nova m√≠dia
                        console.log('[DEBUG_PLAYER] Nova m√≠dia detectada. Carregando...');
                        mediaPlayer.style.display = 'none';
                        externalPlayer.style.display = 'none';
                        if (externalPlayer.parentNode) {
                            externalPlayer.parentNode.removeChild(externalPlayer);
                        }

                        if (newState.type === 'file' || newState.type === 'direct_link') {
                            mediaPlayer.src = newState.url;
                            mediaPlayer.style.display = 'block';
                            mediaPlayer.load();
                            mediaPlayer.play();
                        } else if (['youtube', 'twitch_vod', 'twitch_live', 'vimeo', 'dailymotion'].includes(newState.type)) {
                            externalPlayer.src = newState.url;
                            mediaPlayerContainer.appendChild(externalPlayer);
                            externalPlayer.style.display = 'block';
                        }
                        currentMediaState = newState;
                        addSystemMessage(`Admin mudou a m√≠dia para: "${newState.name}"`);
                    }
                    // Sincronizar play/pause e tempo (muito simplificado para localStorage, melhor com WebSockets)
                    if (mediaPlayer.style.display === 'block') { // Se for o player de v√≠deo/audio HTML5
                        if (newState.paused && !mediaPlayer.paused) {
                            mediaPlayer.pause();
                            addSystemMessage('M√≠dia pausada pelo admin.');
                        } else if (!newState.paused && mediaPlayer.paused) {
                            mediaPlayer.play();
                            addSystemMessage('M√≠dia iniciada pelo admin.');
                        }
                        // Tenta sincronizar o tempo, mas localStorage n√£o √© ideal para isso em tempo real
                        // if (Math.abs(mediaPlayer.currentTime - newState.currentTime) > 2) { // Desvio de mais de 2 segundos
                        //     mediaPlayer.currentTime = newState.currentTime;
                        //     console.log('[DEBUG_PLAYER] Tempo sincronizado.');
                        // }
                    }
                    // Para iframes externos, a sincroniza√ß√£o de tempo/play/pause √© mais complexa ou imposs√≠vel via iframe API
                } catch (e) {
                    console.error('Erro ao parsear estado do player do localStorage:', e);
                }
            }
        });

        // Event listeners para o admin controlar o player e sincronizar
        if (isAdmin) {
            mediaPlayer.addEventListener('play', () => {
                syncPlayerState({ ...currentMediaState, currentTime: mediaPlayer.currentTime, paused: false });
            });
            mediaPlayer.addEventListener('pause', () => {
                syncPlayerState({ ...currentMediaState, currentTime: mediaPlayer.currentTime, paused: true });
            });
            mediaPlayer.addEventListener('seeked', () => {
                syncPlayerState({ ...currentMediaState, currentTime: mediaPlayer.currentTime });
            });
        }


        // --- L√≥gica de Chat e Comandos ---
        const chatInput = document.getElementById('chatInput');
        const sendChatBtn = document.getElementById('sendChatBtn'); // Get reference to the button

        // Function to send chat message
        function sendChatMessage() {
            const message = chatInput.value.trim();
            if (message) {
                if (message.startsWith('/')) {
                    handleCommand(message);
                } else {
                    addChatMessage(myName, message);
                    // Isso envia a mensagem para outras abas/clientes via localStorage
                    saveChatMessage(`${myName}: ${message}`, 'chat');

                    // Se a Fox estiver ativa e houver apenas 1 participante (o pr√≥prio usu√°rio)
                    if (aiChatbotActive && participants.length === 1 && participants[0].name === myName) {
                        getAIChatbotResponse(message);
                    }
                }
                chatInput.value = '';
            }
        }

        // Event listener for the "Enviar" button (only visible on mobile)
        sendChatBtn.onclick = sendChatMessage;

        // Event listener for Enter key in chat input
        chatInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.keyCode === 13) { // Check for Enter key
                event.preventDefault(); // Prevent newline in textarea
                sendChatMessage(); // Call the send message function
            }
        });

        // Auto-redimensionar o textarea do chat
        chatInput.addEventListener('input', function () {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });

        // --- Gemini API Integration: Chat Summarizer ---
        document.getElementById('summarizeChatBtn').onclick = async () => {
            if (!roomID) {
                await customAlert('Voc√™ precisa estar em uma sala para resumir o chat.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restri√ß√£o de idade.');
                return;
            }

            addSystemMessage('Gerando resumo do chat... Por favor, aguarde.');

            try {
                // Get chat messages from localStorage
                const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                if (chatMessages.length === 0) {
                    addSystemMessage('N√£o h√° mensagens no chat para resumir.');
                    return;
                }

                // Format messages for the LLM
                const chatHistoryForLLM = chatMessages.map(msg => {
                    return `${msg.message}`; // Simple format: "Sender: Message" or "System Message"
                }).join('\n');

                const prompt = `Por favor, resuma as seguintes mensagens de chat de forma concisa e √∫til. Inclua os principais t√≥picos e decis√µes, se houver. Se n√£o houver conte√∫do significativo, diga "O chat est√° vazio ou n√£o possui t√≥picos claros para resumir.":\n\n${chatHistoryForLLM}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                const apiKey = ""; // Leave as-is, Canvas will provide it
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const summary = result.candidates[0].content.parts[0].text;
                    addSystemMessage(`Resumo do Chat: ${summary}`);
                } else {
                    addSystemMessage('N√£o foi poss√≠vel gerar o resumo do chat. Tente novamente mais tarde.');
                    console.error('Gemini API response structure unexpected:', result);
                }
            } catch (error) {
                console.error('Error calling Gemini API:', error);
                addSystemMessage('Ocorreu um erro ao tentar resumir o chat. Verifique sua conex√£o ou tente novamente.');
            }
        };

        // --- Gemini API Integration: Content Suggester ---
        document.getElementById('suggestContentBtn').onclick = async () => {
            if (!roomID) {
                await customAlert('Voc√™ precisa estar em uma sala para obter sugest√µes de conte√∫do.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restri√ß√£o de idade.');
                return;
            }

            addSystemMessage('Gerando sugest√µes de conte√∫do... Por favor, aguarde.');

            try {
                let context = '';
                if (currentMediaState.name && currentMediaState.name !== 'Link Externo') {
                    context += `A m√≠dia atual sendo reproduzida √© "${currentMediaState.name}".`;
                } else {
                    const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                    if (chatMessages.length > 0) {
                        const recentMessages = chatMessages.slice(-10).map(msg => msg.message).join('\n'); // Last 10 messages
                        context += `As √∫ltimas mensagens do chat s√£o:\n${recentMessages}`;
                    } else {
                        context += 'N√£o h√° m√≠dia sendo reproduzida nem mensagens recentes no chat.';
                    }
                }

                const prompt = `Com base no seguinte contexto, sugira 3-5 ideias de v√≠deos (YouTube, filmes, s√©ries) ou t√≥picos de conversa interessantes para a sala. Seja criativo e conciso. Formate as sugest√µes como uma lista numerada. Se n√£o houver contexto, sugira t√≥picos gerais e populares. Contexto: ${context}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                const apiKey = ""; // Leave as-is, Canvas will provide it
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const suggestions = result.candidates[0].content.parts[0].text;
                    addSystemMessage(`Sugest√µes de Conte√∫do:\n${suggestions}`);
                } else {
                    addSystemMessage('N√£o foi poss√≠vel gerar sugest√µes de conte√∫do. Tente novamente mais tarde.');
                    console.error('Gemini API response structure unexpected:', result);
                }
            } catch (error) {
                console.error('Error calling Gemini API:', error);
                addSystemMessage('Ocorreu um erro ao tentar gerar sugest√µes de conte√∫do. Verifique sua conex√£o ou tente novamente.');
            }
        };

        // --- Gemini API Integration: Poll Question Generator ---
        document.getElementById('generatePollBtn').onclick = async () => {
            if (!roomID) {
                await customAlert('Voc√™ precisa estar em uma sala para gerar uma enquete.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restri√ß√£o de idade.');
                return;
            }
            if (activePoll) {
                await customAlert('J√° existe uma enquete ativa. Feche a enquete atual antes de criar uma nova.');
                return;
            }

            addSystemMessage('Gerando pergunta para enquete... Por favor, aguarde.');

            try {
                let context = '';
                if (currentMediaState.name && currentMediaState.name !== 'Link Externo') {
                    context += `A m√≠dia atual sendo reproduzida √© "${currentMediaState.name}".`;
                } else {
                    const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                    if (chatMessages.length > 0) {
                        const recentMessages = chatMessages.slice(-10).map(msg => msg.message).join('\n'); // Last 10 messages
                        context += `As √∫ltimas mensagens do chat s√£o:\n${recentMessages}`;
                    } else {
                        context += 'N√£o h√° m√≠dia sendo reproduzida nem mensagens recentes no chat.';
                    }
                }

                const prompt = `Gere uma pergunta de enquete interessante e concisa (m√°ximo 150 caracteres) baseada no seguinte contexto. Inclua 3-4 op√ß√µes de resposta curtas e variadas. Formate como: 'Pergunta: [Sua pergunta]\nOp√ß√µes:\n1. [Op√ß√£o 1]\n2. [Op√ß√£o 2]\n3. [Op√ß√£o 3]'. Se n√£o houver contexto claro, gere uma pergunta de enquete geral e divertida. Contexto: ${context}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                const apiKey = ""; // Leave as-is, Canvas will provide it
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const rawPollText = result.candidates[0].content.parts[0].text;
                    parseAndCreatePoll(rawPollText);
                } else {
                    addSystemMessage('N√£o foi poss√≠vel gerar a pergunta para enquete. Tente novamente mais tarde.');
                    console.error('Gemini API response structure unexpected:', result);
                }
            }
            catch (error) {
                console.error('Error calling Gemini API:', error);
                addSystemMessage('Ocorreu um erro ao tentar gerar a pergunta para enquete. Verifique sua conex√£o ou tente novamente.');
            }
        };

        // --- Gemini API Integration: Sentiment Analysis ---
        document.getElementById('analyzeSentimentBtn').onclick = analyzeChatSentiment;
        async function analyzeChatSentiment() {
            if (!roomID) {
                await customAlert('Voc√™ precisa estar em uma sala para analisar o sentimento.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restri√ß√£o de idade.');
                return;
            }

            addSystemMessage('Fox est√° analisando o sentimento do chat... Por favor, aguarde.');

            try {
                const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                if (chatMessages.length === 0) {
                    addSystemMessage('Fox: N√£o h√° mensagens no chat para analisar o sentimento.');
                    return;
                }

                const recentMessages = chatMessages.slice(-20).map(msg => msg.message).join('\n'); // Analyze last 20 messages

                const prompt = `Analise o sentimento geral das seguintes mensagens de chat. Responda com uma frase concisa descrevendo o humor predominante (ex: "O clima no chat est√° animado!", "Parece que o chat est√° um pouco quieto e pensativo.", "O chat tem um tom neutro."). Mensagens:\n\n${recentMessages}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                const apiKey = ""; // Leave as-is, Canvas will provide it
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const sentimentAnalysis = result.candidates[0].content.parts[0].text;
                    addChatMessage('Fox', `An√°lise de Sentimento: ${sentimentAnalysis}`);
                } else {
                    addSystemMessage('Fox: N√£o consegui analisar o sentimento do chat. Tente novamente mais tarde.');
                    console.error('Gemini API response structure unexpected for sentiment analysis:', result);
                }
            } catch (error) {
                console.error('Error calling Gemini API for sentiment analysis:', error);
                addSystemMessage('Fox: Ocorreu um erro ao tentar analisar o sentimento. Verifique sua conex√£o ou tente novamente.');
            }
        };

        // --- Gemini API Integration: Creative Prompt Generator ---
        document.getElementById('generateCreativePromptBtn').onclick = generateCreativePrompt;
        async function generateCreativePrompt() {
            if (!roomID) {
                await customAlert('Voc√™ precisa estar em uma sala para gerar uma ideia criativa.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restri√ß√£o de idade.');
                return;
            }

            addSystemMessage('Fox est√° gerando uma ideia criativa... Por favor, aguarde.');

            try {
                let context = '';
                if (currentMediaState.name && currentMediaState.name !== 'Link Externo') {
                    context += `A m√≠dia atual sendo reproduzida √© "${currentMediaState.name}".`;
                } else {
                    const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                    if (chatMessages.length > 0) {
                        const recentMessages = chatMessages.slice(-10).map(msg => msg.message).join('\n');
                        context += `As √∫ltimas mensagens do chat s√£o:\n${recentMessages}`;
                    } else {
                        context += 'N√£o h√° m√≠dia sendo reproduzida nem mensagens recentes no chat.';
                    }
                }

                const prompt = `Gere uma ideia criativa curta e interessante (ex: um in√≠cio de hist√≥ria, um cen√°rio de jogo, uma pergunta "e se...") baseada no seguinte contexto. Se o contexto for limitado, crie algo divertido e aleat√≥rio. Contexto: ${context}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                const apiKey = ""; // Leave as-is, Canvas will provide it
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const creativePrompt = result.candidates[0].content.parts[0].text;
                    addChatMessage('Fox', `Aqui est√° uma Ideia Criativa: ${creativePrompt} ‚ú®`);
                } else {
                    addSystemMessage('Fox: N√£o consegui gerar uma ideia criativa. Tente novamente mais tarde.');
                    console.error('Gemini API response structure unexpected for creative prompt:', result);
                }
            } catch (error) {
                console.error('Error calling Gemini API for creative prompt:', error);
                addSystemMessage('Fox: Ocorreu um erro ao tentar gerar uma ideia criativa. Verifique sua conex√£o ou tente novamente.');
            }
        };

        // --- Poll Functionality ---
        function parseAndCreatePoll(rawPollText) {
            const lines = rawPollText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            if (lines.length < 2 || !lines[0].startsWith('Pergunta:')) {
                addSystemMessage('Formato de enquete inv√°lido gerado pela Fox. Tente novamente.'); // Updated message
                return;
            }

            const question = lines[0].replace('Pergunta:', '').trim();
            const options = [];
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].match(/^\d+\./)) { // Checks for "1. Option" format
                    options.push({
                        text: lines[i].replace(/^\d+\./, '').trim(),
                        votes: 0,
                        voters: []
                    });
                }
            }

            if (options.length < 2) {
                addSystemMessage('N√£o foi poss√≠vel extrair op√ß√µes suficientes da enquete gerada pela Fox. Tente novamente.'); // Updated message
                return;
            }

            activePoll = {
                id: `poll-${Date.now()}`,
                question: question,
                options: options
            };
            savePollState();
            displayPollInChat();
            addSystemMessage('Nova enquete criada!');
        }

        function savePollState() {
            if (roomID && activePoll) {
                localStorage.setItem(LOCAL_STORAGE_ACTIVE_POLL + roomID, JSON.stringify(activePoll));
            } else {
                localStorage.removeItem(LOCAL_STORAGE_ACTIVE_POLL + roomID);
            }
        }

        function loadPollState() {
            if (roomID) {
                const storedPoll = localStorage.getItem(LOCAL_STORAGE_ACTIVE_POLL + roomID);
                if (storedPoll) {
                    activePoll = JSON.parse(storedPoll);
                    displayPollInChat();
                } else {
                    activePoll = null;
                    removePollFromChat();
                }
            }
        }

        function displayPollInChat() {
            removePollFromChat(); // Remove any existing poll display

            if (!activePoll) return;

            const chatLog = document.getElementById('chatLog');
            const pollContainer = document.createElement('div');
            pollContainer.id = 'activePollDisplay';
            pollContainer.className = 'poll-container';

            const questionElem = document.createElement('p');
            questionElem.className = 'poll-question';
            questionElem.textContent = `Enquete: ${activePoll.question}`;
            pollContainer.appendChild(questionElem);

            activePoll.options.forEach((option, index) => {
                const optionBtn = document.createElement('button');
                optionBtn.className = 'poll-option-btn';
                optionBtn.textContent = option.text;
                optionBtn.dataset.optionIndex = index;
                optionBtn.onclick = () => voteOnPoll(index);

                const percentageSpan = document.createElement('span');
                percentageSpan.className = 'poll-percentage';
                percentageSpan.textContent = `(0%)`; // Initial percentage
                optionBtn.appendChild(percentageSpan);

                if (option.voters.includes(myName)) {
                    optionBtn.classList.add('voted');
                }

                pollContainer.appendChild(optionBtn);
            });

            chatLog.appendChild(pollContainer);
            updatePollDisplayPercentages(); // Update percentages immediately
            chatLog.scrollTop = chatLog.scrollHeight;
        }

        function removePollFromChat() {
            const existingPoll = document.getElementById('activePollDisplay');
            if (existingPoll) {
                existingPoll.remove();
            }
        }

        function voteOnPoll(optionIndex) {
            if (!activePoll) {
                customAlert('N√£o h√° uma enquete ativa para votar.');
                return;
            }
            if (activePoll.options[optionIndex].voters.includes(myName)) {
                customAlert('Voc√™ j√° votou nesta op√ß√£o!');
                return;
            }

            // Remove previous vote if any
            activePoll.options.forEach(option => {
                const voterIndex = option.voters.indexOf(myName);
                if (voterIndex !== -1) {
                    option.voters.splice(voterIndex, 1);
                    option.votes--;
                }
            });

            // Add new vote
            activePoll.options[optionIndex].votes++;
            activePoll.options[optionIndex].voters.push(myName);

            savePollState(); // Save updated state
            updatePollDisplayPercentages(); // Update UI
            addSystemMessage(`${myName} votou em "${activePoll.options[optionIndex].text}" na enquete.`);
        }

        function updatePollDisplayPercentages() {
            if (!activePoll) return;

            const totalVotes = activePoll.options.reduce((sum, option) => sum + option.votes, 0);
            const pollButtons = document.querySelectorAll('#activePollDisplay .poll-option-btn');

            pollButtons.forEach((button, index) => {
                const option = activePoll.options[index];
                const percentage = totalVotes === 0 ? 0 : ((option.votes / totalVotes) * 100).toFixed(0);
                button.querySelector('.poll-percentage').textContent = `(${percentage}%)`;

                // Highlight voted option
                if (option.voters.includes(myName)) {
                    button.classList.add('voted');
                } else {
                    button.classList.remove('voted');
                }
            });
        }

        // --- AI Buttons Panel Toggle ---
        document.getElementById('toggleAIButtonsBtn').onclick = () => {
            const panel = document.getElementById('aiButtonsPanel');
            panel.classList.toggle('expanded');
        };


        // Fun√ß√£o para controlar a visibilidade dos bot√µes de IA
        function updateAIBottonVisibility() {
            const summarizeBtn = document.getElementById('summarizeChatBtn');
            const toggleAIButtonsBtn = document.getElementById('toggleAIButtonsBtn');
            const aiButtonsPanel = document.getElementById('aiButtonsPanel');
            const analyzeSentimentBtn = document.getElementById('analyzeSentimentBtn');
            const generateCreativePromptBtn = document.getElementById('generateCreativePromptBtn');

            if (currentRoomAgeRestricted) {
                summarizeBtn.style.display = 'none';
                toggleAIButtonsBtn.style.display = 'none';
                aiButtonsPanel.classList.remove('expanded'); // Garante que o painel esteja recolhido
                analyzeSentimentBtn.style.display = 'none';
                generateCreativePromptBtn.style.display = 'none';
            } else {
                summarizeBtn.style.display = 'flex'; // ou 'block' dependendo do layout
                toggleAIButtonsBtn.style.display = 'flex'; // ou 'block'
                analyzeSentimentBtn.style.display = 'flex';
                generateCreativePromptBtn.style.display = 'flex';
            }
        }

        // --- AI Chatbot ---
        async function getAIChatbotResponse(userMessage) {
            addSystemMessage('Fox est√° pensando...'); // Updated message
            try {
                // First, try to detect if it's a media playback request
                const mediaRequestPrompt = `O usu√°rio est√° pedindo para eu reproduzir um v√≠deo ou √°udio? Se sim, extraia o link ou o nome do conte√∫do. Responda em JSON.
                {
                    "isMediaRequest": boolean,
                    "mediaType": "link" | "search" | null,
                    "mediaContent": string | null,
                    "mediaName": string | null // Name for the playlist
                }
                Mensagem do usu√°rio: "${userMessage}"`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: mediaRequestPrompt }] });

                const mediaPayload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "isMediaRequest": { "type": "BOOLEAN" },
                                "mediaType": { "type": "STRING", "enum": ["link", "search", "null"] },
                                "mediaContent": { "type": "STRING", "nullable": true },
                                "mediaName": { "type": "STRING", "nullable": true }
                            },
                            "propertyOrdering": ["isMediaRequest", "mediaType", "mediaContent", "mediaName"]
                        }
                    }
                };

                const apiKey = ""; // Leave as-is, Canvas will provide it
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const mediaResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(mediaPayload)
                });

                const mediaResult = await mediaResponse.json();
                let mediaRequest = { isMediaRequest: false };

                if (mediaResult.candidates && mediaResult.candidates.length > 0 &&
                    mediaResult.candidates[0].content && mediaResult.candidates[0].content.parts &&
                    mediaResult.candidates[0].content.parts.length > 0) {
                    try {
                        mediaRequest = JSON.parse(mediaResult.candidates[0].content.parts[0].text);
                        // Ensure mediaType is valid
                        if (!["link", "search", "null"].includes(mediaRequest.mediaType)) {
                            mediaRequest.mediaType = null;
                        }
                    } catch (e) {
                        console.error('Failed to parse media request JSON:', e);
                        mediaRequest = { isMediaRequest: false }; // Fallback to non-media request
                    }
                }

                if (mediaRequest.isMediaRequest && mediaRequest.mediaContent) {
                    let playedSuccessfully = false;
                    let mediaToPlay = mediaRequest.mediaContent;
                    let mediaType = 'link'; // Default to link, will be refined by playAndBroadcast
                    let mediaName = mediaRequest.mediaName || 'Conte√∫do Solicitado';

                    // Try to play directly if it's a link request
                    if (mediaRequest.mediaType === 'link') {
                        // Attempt to determine media type more accurately before calling playAndBroadcast
                        const youtubeMatch = mediaToPlay.match(/(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
                        const twitchMatch = mediaToPlay.match(/(?:twitch\.tv\/([a-zA-Z0-9_]+)(?:\/videos\/(\d+))?)/);
                        const vimeoMatch = mediaToPlay.match(/(?:vimeo\.com\/(?:video\/)?([0-9]+))/);
                        const dailymotionMatch = mediaToPlay.match(/(?:dailymotion\.com\/(?:video|hub)\/([a-zA-Z0-9]+))/);
                        const directMediaMatch = /\.(mp4|webm|ogg|mp3|wav)(\?.*)?$/i.test(mediaToPlay);

                        if (youtubeMatch) {
                            mediaToPlay = `https://www.youtube.com/embed/${youtubeMatch[1]}?autoplay=1&controls=1`;
                            mediaType = 'youtube';
                        } else if (twitchMatch) {
                            const channel = twitchMatch[1];
                            const videoId = twitchMatch[2];
                            if (videoId) {
                                mediaToPlay = `https://player.twitch.tv/?video=${videoId}&parent=${window.location.hostname}&autoplay=true`;
                                mediaType = 'twitch_vod';
                            } else {
                                mediaToPlay = `https://player.twitch.tv/?channel=${channel}&parent=${window.location.hostname}&autoplay=true`;
                                mediaType = 'twitch_live';
                            }
                        } else if (vimeoMatch) {
                            mediaToPlay = `https://player.vimeo.com/video/${vimeoMatch[1]}?autoplay=1`;
                            mediaType = 'vimeo';
                        } else if (dailymotionMatch) {
                            mediaToPlay = `https://www.dailymotion.com/embed/video/${dailymotionMatch[1]}?autoplay=1`;
                            mediaType = 'dailymotion';
                        } else if (directMediaMatch) {
                            mediaType = 'direct_link';
                        } else {
                            // If it's not a recognized embeddable link, treat as search
                            mediaRequest.mediaType = 'search';
                            mediaName = mediaRequest.mediaContent; // Use the original content as search query
                        }

                        if (mediaRequest.mediaType === 'link') { // Only try to play if it's still considered a direct link
                            playedSuccessfully = playAndBroadcast(mediaToPlay, mediaType, mediaName, true);
                        }
                    }

                    // If direct play failed or it's a search request, try Google Search
                    if (!playedSuccessfully && mediaRequest.mediaType === 'search') {
                        addSystemMessage(`Fox: N√£o consegui reproduzir diretamente. Vou tentar pesquisar por "${mediaRequest.mediaContent}"...`);
                        const searchResults = await google_search.search(queries=[mediaRequest.mediaContent]);
                        
                        let foundSearchLink = null;
                        let foundSearchType = null;
                        let foundSearchName = null;

                        if (searchResults && searchResults.length > 0 && searchResults[0].results) {
                            for (const result of searchResults[0].results) {
                                const url = result.url;
                                if (url) {
                                    const youtubeMatch = url.match(/(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
                                    const twitchMatch = url.match(/(?:twitch\.tv\/([a-zA-Z0-9_]+)(?:\/videos\/(\d+))?)/);
                                    const vimeoMatch = url.match(/(?:vimeo\.com\/(?:video\/)?([0-9]+))/);
                                    const dailymotionMatch = url.match(/(?:dailymotion\.com\/(?:video|hub)\/([a-zA-Z0-9]+))/);
                                    const directMediaMatch = /\.(mp4|webm|ogg|mp3|wav)(\?.*)?$/i.test(url);

                                    if (youtubeMatch) {
                                        foundSearchLink = `https://www.youtube.com/embed/${youtubeMatch[1]}?autoplay=1&controls=1`;
                                        foundSearchType = 'youtube';
                                        foundSearchName = result.source_title || 'V√≠deo do YouTube';
                                        break;
                                    } else if (twitchMatch) {
                                        const channel = twitchMatch[1];
                                        const videoId = twitchMatch[2];
                                        if (videoId) {
                                            foundSearchLink = `https://player.twitch.tv/?video=${videoId}&parent=${window.location.hostname}&autoplay=true`;
                                            foundSearchType = 'twitch_vod';
                                            foundSearchName = result.source_title || 'VOD da Twitch';
                                        } else {
                                            foundSearchLink = `https://player.twitch.tv/?channel=${channel}&parent=${window.location.hostname}&autoplay=true`;
                                            foundSearchType = 'twitch_live';
                                            foundSearchName = result.source_title || 'Live da Twitch';
                                        }
                                        break;
                                    } else if (vimeoMatch) {
                                        foundSearchLink = `https://player.vimeo.com/video/${vimeoMatch[1]}?autoplay=1`;
                                        foundSearchType = 'vimeo';
                                        foundSearchName = result.source_title || 'V√≠deo do Vimeo';
                                        break;
                                    } else if (dailymotionMatch) {
                                        foundSearchLink = `https://www.dailymotion.com/embed/video/${dailymotionMatch[1]}?autoplay=1`;
                                        foundSearchType = 'dailymotion';
                                        foundSearchName = result.source_title || 'V√≠deo do DailyMotion';
                                        break;
                                    } else if (directMediaMatch) {
                                        foundSearchLink = url;
                                        foundSearchType = 'direct_link';
                                        foundSearchName = result.source_title || url.substring(url.lastIndexOf('/') + 1);
                                        break;
                                    }
                                }
                            }
                        }

                        if (foundSearchLink) {
                            playedSuccessfully = playAndBroadcast(foundSearchLink, foundSearchType, foundSearchName, true);
                            if (playedSuccessfully) {
                                addChatMessage('Fox', `Claro! Encontrei e estou come√ßando a reproduzir para voc√™! Espero que goste! ‚ú®`);
                            } else {
                                addChatMessage('Fox', `Ops! Encontrei algo, mas n√£o consegui reproduzir. Tem certeza que √© um link v√°lido?`);
                            }
                        } else {
                            addChatMessage('Fox', `Ah, que pena! Tentei encontrar o que voc√™ pediu, mas n√£o consegui achar nenhuma correspond√™ncia que eu possa reproduzir. Talvez possamos tentar outra coisa? üôÅ`);
                        }
                    } else if (playedSuccessfully) {
                        addChatMessage('Fox', `Claro! Estou reproduzindo o link para voc√™! Espero que goste! ‚ú®`);
                    } else {
                        // If it was a direct link request but failed and not a search, just say it failed.
                        addChatMessage('Fox', `Desculpe, n√£o consegui reproduzir o link que voc√™ me deu. Tem certeza que est√° correto?`);
                    }
                } else {
                    // If not a media request, proceed with general conversation
                    const generalPrompt = `Voc√™ √© uma chatbot amig√°vel chamada Fox em uma sala de chat. Responda √† seguinte mensagem do usu√°rio de forma concisa e √∫til, mantendo a conversa fluida. Mensagem do usu√°rio: "${userMessage}"`;

                    let generalChatHistory = [];
                    generalChatHistory.push({ role: "user", parts: [{ text: generalPrompt }] });

                    const generalPayload = { contents: generalChatHistory };
                    const generalResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(generalPayload)
                    });

                    const generalResult = await generalResponse.json();

                    if (generalResult.candidates && generalResult.candidates.length > 0 &&
                        generalResult.candidates[0].content && generalResult.candidates[0].content.parts &&
                        generalResult.candidates[0].content.parts.length > 0) {
                        const aiResponse = generalResult.candidates[0].content.parts[0].text;
                        addChatMessage('Fox', aiResponse);
                    } else {
                        addSystemMessage('Fox: N√£o consegui gerar uma resposta. Tente novamente.');
                        console.error('Gemini API response structure unexpected for chatbot:', generalResult);
                    }
                }
            } catch (error) {
                console.error('Error calling Gemini API for chatbot:', error);
                addSystemMessage('Fox: Ocorreu um erro ao processar sua mensagem. Verifique sua conex√£o ou tente novamente.');
            }
        }

        function handleCommand(command) {
            const parts = command.split(' ');
            const cmd = parts[0].toLowerCase();
            const aiSubCommand = parts[1] ? parts[1].toLowerCase() : '';
            const targetUser = parts[1];
            const reason = parts.slice(2).join(' '); // Para motivos de kick/ban
            let duration = 0; // Para banimento

            switch (cmd) {
                case '/help':
                    addPrivateMessage('Comandos dispon√≠veis:');
                    addPrivateMessage('/Version - Exibe a vers√£o do aplicativo.');
                    addPrivateMessage('/Admin - Mostra quem √© o admin da sala.');
                    addPrivateMessage('/sendlink [link] - Envia um link (vis√≠vel para todos).');
                    addPrivateMessage('/code - Mostra o c√≥digo da sala.');
                    addPrivateMessage('/exit - Sai da sala.');
                    addPrivateMessage('/AI entrar - Ativa a Fox (se estiver sozinho).'); // Updated message
                    addPrivateMessage('/AI gerar enquete [pergunta]? [Op√ß√£o 1]; [Op√ß√£o 2]; ... - Cria uma enquete.');
                    addPrivateMessage('/AI fechar enquete - Encerra a enquete ativa.');
                    addPrivateMessage('/AI analisar sentimento - A Fox analisa o humor do chat.');
                    addPrivateMessage('/AI ideia criativa - A Fox gera uma ideia criativa.');
                    if (isAdmin) {
                        addPrivateMessage('Comandos de Admin:');
                        addPrivateMessage('/Clear All - Limpa o chat para todos.');
                        addPrivateMessage('/Kick [Nome] [Motivo] - Expulsa um usu√°rio.');
                        addPrivateMessage('/Ban [Nome] [Motivo] [Tempo] - Bane um usu√°rio (ex: 10m, 2h, 0 para permanente).');
                        addPrivateMessage('/reload all - Recarrega a p√°gina para todos na sala.');
                        addPrivateMessage('/Admin [Nome] - Concede admin a algu√©m.');
                        addPrivateMessage('/Revoke-Admin [Nome] - Remove admin de algu√©m.');
                        addPrivateMessage('/Mod [Nome] - Concede moderador a algu√©m.');
                        addPrivateMessage('/Revoke-Mod [Nome] - Remove moderador de algu√©m.');
                        addPrivateMessage('/exitall - Tira todos da sala.');
                    }
                    break;
                case '/version':
                    addSystemMessage('Vers√£o do Aplicativo: 1.0.0 (Beta)');
                    break;
                case '/admin':
                    const roomState = loadRoomState(roomID);
                    if (roomState) {
                        const adminParticipant = roomState.participants.find(p => p.isAdmin);
                        if (adminParticipant) {
                            addSystemMessage(`O administrador da sala √©: ${adminParticipant.name}`);
                        } else {
                            addSystemMessage('N√£o h√° um administrador definido para esta sala.');
                        }
                    } else {
                        addSystemMessage('N√£o foi poss√≠vel carregar o estado da sala para encontrar o administrador.');
                    }
                    break;
                case '/sendlink':
                    if (parts.length > 1) {
                        const link = parts[1];
                        // Basic URL validation
                        try {
                            new URL(link);
                            addSystemMessage(`${myName} enviou um link para o admin: ${link}`);
                            saveChatMessage(`${myName} enviou um link para o admin: ${link}`, 'system');
                        } catch (e) {
                            addPrivateMessage('Link inv√°lido. Certifique-se de que √© uma URL completa e v√°lida.', true);
                        }
                    } else {
                        addPrivateMessage('Uso: /sendlink [link]', true);
                    }
                    break;
                case '/code':
                    if (roomID) {
                        addPrivateMessage(`O c√≥digo da sala √©: ${roomID}`);
                    } else {
                        addPrivateMessage('Voc√™ n√£o est√° em uma sala.', true);
                    }
                    break;
                case '/exit':
                    addSystemMessage(`${myName} saiu da sala.`);
                    // Remove o participante da lista
                    participants = participants.filter(p => p.name !== myName);
                    updateRoomStateInLocalStorage(); // Sincroniza a remo√ß√£o
                    // Redireciona para a tela inicial
                    showScreen('menuSetup');
                    roomID = '';
                    myName = '';
                    isAdmin = false;
                    waitingForApproval = false;
                    currentJoinRequestId = null;
                    clearTimeout(approvalTimeout);
                    currentRoomAgeRestricted = false; // Reseta a flag de restri√ß√£o de idade
                    updateAIBottonVisibility(); // Garante que os bot√µes de IA voltem ao normal no menu
                    break;
                case '/clear':
                    if (isAdmin && parts[1] && parts[1].toLowerCase() === 'all') {
                        localStorage.removeItem(LOCAL_STORAGE_CHAT_PREFIX + roomID);
                        loadChatMessages(); // Limpa o chat na UI
                        addSystemMessage('O chat foi limpo por um administrador.');
                    } else if (!isAdmin) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Clear All', true);
                    }
                    break;
                case '/kick':
                    if (isAdmin && targetUser) {
                        kickUser(targetUser, reason);
                    } else if (!isAdmin) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Kick [Nome] [Motivo (opcional)]', true);
                    }
                    break;
                case '/ban':
                    if (isAdmin && targetUser) {
                        let banReason = parts.slice(2).join(' ');
                        let banDuration = 0; // 0 for permanent

                        // Check if the last part is a duration (e.g., 10m, 2h)
                        const lastPart = parts[parts.length - 1];
                        const durationMatch = lastPart.match(/^(\d+)([mh])$/);
                        if (durationMatch) {
                            const value = parseInt(durationMatch[1]);
                            const unit = durationMatch[2];
                            if (unit === 'm') {
                                banDuration = value;
                            } else if (unit === 'h') {
                                banDuration = value * 60;
                            }
                            banReason = parts.slice(2, parts.length - 1).join(' '); // Remove duration from reason
                        }

                        banUser(targetUser, banReason, banDuration);
                    } else if (!isAdmin) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Ban [Nome] [Motivo (opcional)] [Tempo (ex: 10m, 2h, 0 para permanente)]', true);
                    }
                    break;
                case '/reload':
                    if (isAdmin && parts[1] && parts[1].toLowerCase() === 'all') {
                        addSystemMessage('Um administrador solicitou o recarregamento da p√°gina para todos.');
                        localStorage.setItem(LOCAL_STORAGE_RELOAD_ALL + roomID, 'true');
                        // For√ßa o recarregamento da pr√≥pria aba do admin tamb√©m
                        window.location.reload();
                    } else if (!isAdmin) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /reload all', true);
                    }
                    break;
                case '/admin':
                    if (isAdmin && targetUser) {
                        setParticipantRole(targetUser, 'isAdmin', true);
                    } else if (!isAdmin) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Admin [Nome]', true);
                    }
                    break;
                case '/revoke-admin':
                    if (isAdmin && targetUser) {
                        setParticipantRole(targetUser, 'isAdmin', false);
                    } else if (!isAdmin) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Revoke-Admin [Nome]', true);
                    }
                    break;
                case '/mod':
                    if (isAdmin && targetUser) {
                        setParticipantRole(targetUser, 'isMod', true);
                    } else if (!isAdmin) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Mod [Nome]', true);
                    }
                    break;
                case '/revoke-mod':
                    if (isAdmin && targetUser) {
                        setParticipantRole(targetUser, 'isMod', false);
                    } else if (!isAdmin) {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Revoke-Mod [Nome]', true);
                    }
                    break;
                case '/exitall':
                    if (isAdmin) {
                        addSystemMessage('Um administrador tirou todos da sala.');
                        // Envia um "kick" para todos os participantes, exceto o pr√≥prio admin
                        participants.forEach(p => {
                            if (p.name !== myName) {
                                let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
                                const kickNotificationId = `kick-${p.name}-${roomID}-${Date.now()}`;
                                requests.push({ id: kickNotificationId, roomID: roomID, name: p.name, status: 'rejected', reason: 'Voc√™ foi removido da sala pelo administrador.' });
                                localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
                            }
                        });
                        // Opcional: O admin tamb√©m pode sair ou permanecer. Por enquanto, ele permanece.
                    } else {
                        addPrivateMessage('Voc√™ n√£o tem permiss√£o para usar este comando.', true);
                    }
                    break;
                case '/me':
                    if (parts.length > 1) {
                        const action = parts.slice(1).join(' ');
                        addSystemMessage(`${myName} ${action}`);
                        saveChatMessage(`${myName} ${action}`, 'system');
                    } else {
                        addPrivateMessage('Uso: /me [sua a√ß√£o]', true);
                    }
                    break;
                case '/nick':
                    if (parts.length > 1) {
                        const newName = parts.slice(1).join(' ').trim();
                        if (newName && newName !== myName) {
                            // Verifica se o novo nome j√° est√° em uso por outro participante na sala atual
                            if (participants.some(p => p.name === newName)) {
                                addPrivateMessage(`O nome "${newName}" j√° est√° em uso nesta sala.`, true);
                            } else {
                                addSystemMessage(`${myName} mudou seu nome para ${newName}.`);
                                // Atualiza o nome na lista de participantes
                                const myParticipant = participants.find(p => p.name === myName);
                                if (myParticipant) {
                                    myParticipant.name = newName;
                                }
                                myName = newName;
                                updateParticipantList(); // Isso ir√° for√ßar a atualiza√ß√£o para todos via localStorage
                                saveChatMessage(`${myName} mudou seu nome para ${newName}.`, 'system');
                            }
                        } else {
                            addPrivateMessage('Uso: /nick [novo_nome]', true);
                        }
                    } else {
                        addPrivateMessage('Uso: /nick [novo_nome]', true);
                    }
                    break;
                case '/ai':
                    if (currentRoomAgeRestricted) {
                        addPrivateMessage('Funcionalidades de IA est√£o desativadas em salas com restri√ß√£o de idade.', true);
                        return;
                    }
                    if (aiSubCommand === 'entrar') {
                        if (participants.length === 1 && participants[0].name === myName) {
                            aiChatbotActive = true;
                            addSystemMessage('A Fox entrou na sala para conversar com voc√™! Diga ol√°!'); // Updated message
                        } else {
                            addPrivateMessage('A Fox s√≥ pode entrar se voc√™ for o √∫nico na sala.', true); // Updated message
                        }
                    } else if (aiSubCommand === 'gerar' && parts[2] === 'enquete') {
                        if (activePoll) {
                            customAlert('J√° existe uma enquete ativa. Feche a enquete atual antes de criar uma nova.');
                            return;
                        }
                        const pollContent = parts.slice(3).join(' '); // Get the rest of the command
                        if (pollContent.includes('?') && pollContent.includes(';')) {
                            const [questionPart, optionsPart] = pollContent.split('?');
                            const question = questionPart.trim();
                            const options = optionsPart.split(';').map(opt => opt.trim()).filter(opt => opt.length > 0);

                            if (question && options.length >= 2) {
                                activePoll = {
                                    id: `poll-${Date.now()}`,
                                    question: question,
                                    options: options.map(opt => ({ text: opt, votes: 0, voters: [] }))
                                };
                                savePollState();
                                displayPollInChat();
                                addSystemMessage('Nova enquete criada!');
                            } else {
                                addPrivateMessage('Uso: /AI gerar enquete [sua pergunta]? [Op√ß√£o 1]; [Op√ß√£o 2]; [Op√ß√£o 3]; ...', true);
                            }
                        } else {
                            addPrivateMessage('Uso: /AI gerar enquete [sua pergunta]? [Op√ß√£o 1]; [Op√ß√£o 2]; [Op√ß√£o 3]; ...', true);
                        }
                    } else if (aiSubCommand === 'fechar' && parts[2] === 'enquete') {
                        if (activePoll) {
                            activePoll = null;
                            savePollState(); // Clear from localStorage
                            removePollFromChat(); // Remove from UI
                            addSystemMessage('Enquete encerrada.');
                        } else {
                            addPrivateMessage('N√£o h√° enquete ativa para fechar.', true);
                        }
                    } else if (aiSubCommand === 'analisar' && parts[2] === 'sentimento') {
                        analyzeChatSentiment();
                    } else if (aiSubCommand === 'ideia' && parts[2] === 'criativa') {
                        generateCreativePrompt();
                    }
                    else {
                        addPrivateMessage(`Subcomando /AI desconhecido: ${aiSubCommand}. Use '/AI entrar', '/AI gerar enquete', '/AI fechar enquete', '/AI analisar sentimento', ou '/AI ideia criativa'.`, true);
                    }
                    break;
                default:
                    addPrivateMessage(`Comando desconhecido: ${command}. Digite /help para ver os comandos dispon√≠veis.`, true);
            }
        }

        // Inicializa a limpeza de chats antigos ao carregar a p√°gina
        document.addEventListener('DOMContentLoaded', () => {
            cleanOldChatMessages();
            // Exibir o aviso beta inicial
            const betaModal = document.getElementById('betaNoticeModal');
            if (betaModal) {
                betaModal.style.display = 'flex';
                // Opcional: fechar o modal ap√≥s alguns segundos
                setTimeout(() => {
                    betaModal.style.display = 'none';
                }, 5000); // Exibe por 5 segundos
            }
            updateAIBottonVisibility(); // Garante que os bot√µes de IA estejam ocultos no in√≠cio se a sala for restrita
            loadPollState(); // Carrega o estado da enquete ao iniciar
        });

        // Fechar o modal beta
        document.getElementById('betaNoticeContent').addEventListener('click', () => {
            document.getElementById('betaNoticeModal').style.display = 'none';
        });
    </script>
</body>
</html>
