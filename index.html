<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta name="google-site-verification" content="QGTLm1lTLE591HI5TtR4RQWFOLthoytyvprPyQP94cA" />
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Chat + Player Completo</title>
    <!-- Tailwind CSS CDN para estilos básicos de login/logout -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* [MELHORIA]: Para projetos maiores, é altamente recomendado mover todo este CSS para um arquivo .css separado (ex: style.css).
           Isso melhora a organização, legibilidade, manutenção e o cache do navegador.
           Ex: <link rel="stylesheet" href="style.css"> no head. */

        /* Estilos Globais e Reset */
        *{box-sizing:border-box;margin:0;padding:0}
        body{background:#121212;color:#EEE;font-family:Arial,sans-serif;display:flex;flex-direction:column;height:100vh;}
        .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;}

        /* Telas de Setup e Espera (Menu Inicial, Nome, Aprovação, Recusado) */
        #menuSetup, #namePrompt, #waitingApproval, #rejectedNotice, #ageVerificationModal {
            padding:1rem; /* */
            display:flex; /* */
            flex-direction:column; /* */
            gap:.5rem; /* */
            align-items:center; /* */
            text-align:center; /* */
            justify-content: center; /* Centraliza verticalmente */
            flex: 1; /* */
        /* Permite que ocupe o espaço disponível */
        }

        /* Layout Principal da UI (PC Padrão) */
        #mainUI{
            display:none; /* Inicia oculto, será 'flex' após login */
            flex:1; /* Ocupa o espaço disponível */
            flex-direction:row; /* Player e Chat lado a lado no PC */
            max-width:1200px; /* Largura máxima para PCs */
            margin:0 auto; /* Centraliza */
            position:relative;
            padding: 1rem; /* Espaçamento interno */
        }

        /* Estilos do Player */
        #playerArea{
            flex:2; /* Ocupa 2/3 do espaço disponível */
            background:#222;
            display:flex;
            flex-direction:column;
            align-items:center;
            padding:1rem;
            position:relative;
            border-radius: 8px; /* Bordas arredondadas */
        }
        #mediaPlayerContainer { /* Novo contêiner para o player */
            width: 100%;
            max-width: 800px;
            position: relative;
            padding-top: 56.25%; /* Proporção 16:9 (altura/largura = 0.5625) */
            background: #000;
            border-radius: 6px;
            overflow: hidden;
        }
        #mediaPlayer, #externalPlayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            background:#000; /* Garante fundo preto para vídeo */
            z-index: 1; /* */
        }
        #controls{
            margin:1rem;
            display:flex;
            gap:.5rem;
            flex-wrap:wrap; /* Quebra botões em múltiplas linhas se necessário */
            position:relative;
            z-index:1;
            justify-content: center; /* Centraliza os botões */
        }
        .btn{
            background:#ff4500;
            border:none; /* */
            color:#FFF;
            padding:.5rem 1rem;
            border-radius:5px;
            cursor:pointer;
            z-index:1;
            font-size: 0.9rem; /* Ajuste para botões */
        }
        .btn:hover {
            opacity: 0.9; /* */
        }
        /* New media control buttons styling */
        .media-control-btn {
            background-color: #007bff; /* Blue for media controls */
            display: none; /* Hidden by default, shown for admin/mod */
        }
        .media-control-btn:hover {
            background-color: #0056b3;
        }


        /* Estilos do Chat */
        #chatArea{
            flex:1; /* Ocupa 1/3 do espaço disponível */
            display:flex;
            flex-direction:column;
            background:#1f1f1f;
            border-left:1px solid #333;
            position:relative; /* */
            border-radius: 8px;
            margin-left: 0.5rem; /* Espaçamento entre player e chat no PC */
        }
        #chatLog{
            flex:1; /* */
            overflow-y:auto;
            padding:.5rem;
            word-wrap: break-word; /* Quebra palavras longas */
        }
        #chatInputArea{
            padding:.5rem; /* */
            display:flex; /* Usa flexbox para alinhar input e botões */
            gap:.5rem; /* */
            border-top: 1px solid #333; /* Separador para a área de input */
            align-items: flex-end; /* Alinha os itens pela parte de baixo */
        }
        #chatInput{
            flex:1; /* */
            padding:.5rem; /* */
            border-radius:4px;
            border:none;
            background:#222;
            color:#EEE;
            resize: none; /* Fixed size, no resizing by user */
            height: 40px; /* Fixed height */
            min-height: 40px; /* Ensure it stays fixed */
            max-height: 40px; /* Ensure it stays fixed */
            min-width: 100px;
            overflow: auto; /* Still allow scrolling if content overflows */
        }
        #sendChatBtn, #summarizeChatBtn {
            height: 40px; /* Ajusta altura dos botões para alinhar com o input */
            flex-shrink: 0; /* Impede que os botões diminuam */
            padding: 0.5rem 0.8rem; /* Ajusta padding */
        }
        #summarizeChatBtn {
            background-color: #6a0dad; /* Cor para o botão de resumo (roxo) */
        }
        /* Esconde o botão de enviar por padrão (PC) */
        #sendChatBtn {
            display: none;
        }

        /* Estilos dos Modais (Padrão para Telas Maiores) */
        #fileMenuModal, #participantListModal, #playlistModal, #betaNoticeModal, #participantActionsModal, #screenShareAiPromptModal{
            position:fixed; /* */
            top:0; /* */
            left:0; /* */
            right:0; /* */
            bottom:0; /* */
            background:rgba(0,0,0,0.75);
            display:none;
            justify-content:center;
            align-items:center;
            z-index:9999;
        }
        #fileMenuContent, #participantListContent, #playlistContent, #betaNoticeContent, #participantActionsContent, #screenShareAiPromptModal .custom-modal-content{
            background:#333; /* */
            padding:1.5rem; /* */
            border-radius:8px;
            min-width:320px;
            display:flex;
            flex-direction:column;
            gap:.75rem;
            position:relative;
            max-height:90vh;
            overflow-y:auto;
            color: #FFF; /* Cor do texto no modal */
            font-size: 1.1rem; /* Tamanho da fonte */
        }
        .closeBtn{
            position:absolute; /* */
            top:10px; /* */
            right:10px; /* */
            background:#a00;
            color:#fff;
            border:none;
            border-radius:50%;
            width:24px;
            height:24px;
            font-weight:bold;
            cursor:pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem; /* */
        }

        /* Estilos de Itens da Playlist/Participantes */
        .playlistItem{
            display:flex;
            justify-content:space-between;
            align-items:center;
            padding:.5rem;
            margin-bottom:.3rem;
            background:#2a2a2a; /* */
            border-radius: 4px;
            cursor: pointer; /* Adiciona cursor de ponteiro para indicar clicável */
        }
        .playlistItem:hover {
            background-color: #3a3a3a; /* Levemente mais escuro ao passar o mouse */
        }
        .playlistItem span{flex:1;text-align:left;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
        .playlistItem small{opacity:0.7; /* */
        margin-left: 0.5rem;}
        #rejectedNotice img {width: 64px;height: 64px;margin-bottom: 0.5rem;}

        /* Classe para mensagens privadas (comandos) */
        .private-message {
            color: #ff9933; /* Vermelho-alaranjado */
            font-style: italic; /* */
        }
        .system-message {
            color: #aaa;
            font-style: italic; /* */
        }
        .warning-message {
            color: yellow;
            font-style: italic; /* */
        }
        /* [NOVA FUNCIONALIDADE]: Estilo para links no chat */
        .chat-link {
            color: #87CEEB; /* Azul claro para links */
            text-decoration: underline;
            cursor: pointer;
        }
        .chat-link:hover {
            color: #ADD8E6;
        }


        /* Aviso fixo na tela da sala */
        #betaNoticeFixed {
            background-color: #5a0a0a; /* Fundo vermelho escuro */
            color: #fff; /* Texto branco */
            padding: 0.5rem 1rem;
            margin-top: 1rem; /* Espaço acima do aviso */
            text-align: center;
            border-radius: 8px;
            font-size: 0.9rem;
            width: 100%;
            max-width: 800px; /* Alinha com o player */
            margin-left: auto;
            margin-right: auto;
            word-wrap: break-word; /* Quebra texto longo */
        }

        /* Custom Modal Base Styles */
        .custom-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 10000; /* Higher than other modals */
        }

        .custom-modal-content {
            background: #333;
            padding: 2rem;
            border-radius: 8px;
            min-width: 300px;
            max-width: 500px;
            text-align: center;
            color: #EEE;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .custom-modal-content p {
            font-size: 1.1rem;
            margin-bottom: 1rem;
        }

        .custom-modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        .custom-modal-buttons .btn {
            padding: 0.7rem 1.5rem;
            font-size: 1rem;
        }
        /* Age Verification Modal Specific Styles */
        #ageVerificationModal .btn {
            width: 100%;
            padding: 0.8rem;
            font-size: 1rem;
        }
        #ageVerificationModal .btn.minor {
            background-color: #dc3545; /* Red for "Sou menor de idade" */
        }

        /* AI Buttons Panel */
        #aiButtonsPanel {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
            width: 100%;
            max-height: 0; /* Inicia recolhido */
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        #aiButtonsPanel.expanded {
            max-height: 250px; /* Altura suficiente para mostrar os botões (ajustado para novos botões) */
        }
        #aiButtonsPanel .btn {
            width: 100%;
            background-color: #28a745; /* Cor para sugestão */
            text-align: center; /* Centraliza o texto dentro do botão */
        }
        #aiButtonsPanel .btn:nth-child(2) { /* Gerar Enquete */
            background-color: #007bff;
        }
        #aiButtonsPanel .btn:nth-child(3) { /* Analisar Sentimento */
            background-color: #ffc107; /* Amarelo */
            color: #333;
        }
        #aiButtonsPanel .btn:nth-child(4) { /* Ideia Criativa */
            background-color: #6f42c1; /* Roxo mais escuro */
        }
        #aiButtonsPanel .btn:nth-child(5) { /* Gerar Curiosidade/Quiz */
            background-color: #fd7e14; /* Laranja */
        }
        #aiButtonsPanel .btn:nth-child(6) { /* Sugestão de Música/Mídia por Humor */
            background-color: #17a2b8; /* Azul claro */
        }
        #toggleAIButtonsBtn {
            background-color: #5a0dad; /* Cor para o botão de toggle (roxo escuro) */
        }

        /* Poll Display in Chat */
        .poll-container {
            background-color: #333;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #555;
        }
        .poll-question {
            font-weight: bold;
            margin-bottom: 8px;
            color: #FFF;
        }
        .poll-option-btn {
            background-color: #444;
            color: #FFF;
            border: 1px solid #666;
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 5px;
            width: 100%;
            text-align: left;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
        }
        .poll-option-btn:hover {
            background-color: #555;
        }
        .poll-option-btn.voted {
            background-color: #007bff; /* Highlight if user voted */
        }
        .poll-percentage {
            font-weight: bold;
            color: #FFD700; /* Gold color for percentage */
        }


        /* --- MEDIA QUERIES --- */

        /* Para Telas de Telefone/Tablet (Largura máxima de 768px) */
        @media (max-width: 768px) {
            body {
                justify-content: flex-start; /* Alinha o conteúdo ao topo para não haver espaço vazio */
            }

            /* Menu Inicial, Nome de Usuário, Espera e Recusa */
            #menuSetup, #namePrompt, #waitingApproval, #rejectedNotice, #ageVerificationModal {
                width: 90%; /* Ocupa a maior parte da largura */
                max-width: 400px; /* Mas não fica muito grande */
                margin: auto; /* Centraliza horizontalmente */
                padding: 1.5rem; /* Mais espaçamento */
                border-radius: 8px;
                background: #1f1f1f; /* Fundo para se destacar */
            }
            #menuSetup input, #namePrompt input {
                width: 100%; /* */
                padding: 0.8rem;
                font-size: 1rem;
            }
            #menuSetup .btn, #namePrompt .btn, #rejectedNotice .btn {
                width: 100%; /* */
                padding: 0.8rem;
                font-size: 1rem;
            }

            /* Layout Principal dentro da Sala (Mobile) */
            #mainUI{
                flex-direction:column; /* Player em cima, chat embaixo */
                width:100%; /* Ocupa 100% da largura */
                height:100vh; /* Ocupa a altura total da viewport */
                padding:.5rem; /* Menor padding */
            }
            #playerArea{
                width:100%; /* Player ocupa 100% da largura */
                height: auto; /* Altura automática */
                padding: 0.5rem;
                border-radius: 0; /* Remove bordas arredondadas em mobile para melhor preenchimento */
            }
            #mediaPlayerContainer {
                max-width: none; /* Remove limite de largura para preencher a tela */
                border-radius: 0; /* */
            }
            #controls {
                margin-top: 0.5rem; /* Ajusta margem para os botões */
            }
            #chatArea{
                width:100%; /* Chat ocupa 100% da largura */
                height:150px; /* Altura fixa para o chat em mobile */
                border-left:none; /* Remove borda esquerda */
                border-top:1px solid #333; /* Adiciona borda superior */
                margin-top:.5rem; /* Espaçamento entre player e chat */
                margin-left: 0; /* Remove margem esquerda */
                border-radius: 0; /* Remove bordas arredondadas */
            }
            #chatInputArea {
                /* No mobile, os botões ficam ao lado do textarea */
                flex-direction: row; /* Mantém em linha */
                align-items: flex-end; /* Alinha na parte de baixo */
                flex-wrap: wrap; /* Permite quebrar botões em nova linha se a tela for muito pequena */
            }
            #chatInput {
                max-height: 40px; /* Keep fixed height on mobile too */
                min-height: 40px;
                height: 40px;
                resize: none;
            }
            /* Mostra o botão de enviar no mobile */
            #sendChatBtn {
                display: flex;
                order: 1; /* Coloca o botão de enviar depois do input */
            }
            #summarizeChatBtn {
                order: 2; /* Coloca o botão de resumo depois do enviar */
            }
            #aiButtonsPanel {
                order: 3; /* Coloca o painel de IA depois do resumo */
                width: 100%; /* Ocupa toda a largura */
            }
            #toggleAIButtonsBtn {
                width: 100%; /* Ocupa toda a largura */
            }
            #betaNoticeFixed {
                margin-top: 0.5rem; /* Ajusta margem em mobile */
                max-width: 100%; /* Ocupa largura total */
                border-radius: 0; /* */
            }

            /* Make modal content take more space on mobile */
            #fileMenuContent, #participantListContent, #playlistContent, #betaNoticeContent, .custom-modal-content {
                width: 95%; /* Almost full width */
                max-width: none; /* Remove max-width restriction */
                max-height: 95vh; /* Allow content to be taller */
                padding: 1rem; /* Adjust padding */
                border-radius: 0; /* Remove border-radius for full screen feel */
            }
        }

        /* Para Telas de TV (Largura mínima de 1600px, adaptando seu breakpoint) */
        @media (min-width: 1600px) {
            #mainUI{
                max-width:1800px; /* Aumenta a largura máxima para TVs */
                margin:2rem auto;
                border:1px solid #444; /* */
                border-radius:10px;
                box-shadow:0 0 20px #0008;
                padding: 1.5rem; /* Mais padding interno */
            }

            #playerArea {
                padding: 1.5rem; /* Mais padding interno */
                flex: 3; /* Player ocupa mais espaço */
            }
            #mediaPlayerContainer {
                max-width: 1000px; /* Aumenta o max-width do vídeo */
            }

            #chatArea{
                flex: 1; /* Chat ocupa menos espaço proporcionalmente */
                max-width: 350px; /* Largura fixa para o chat em TVs */
                margin-left: 1.5rem; /* Mais espaçamento */
                height: auto; /* Altura automática */
            }

            /* Modais para TV (Posicionados sem cobrir tudo) */
            #fileMenuModal, #participantListModal, #playlistModal, #betaNoticeModal {
                background:rgba(0,0,0,0.5); /* Fundo um pouco mais transparente */
            }
            #fileMenuContent, #participantListContent, #playlistContent, #betaNoticeContent {
                min-width: 400px; /* Aumenta o tamanho mínimo dos modais */
                max-width: 600px;
                position: absolute; /* Permite posicionamento absoluto */
                top: 50% ;
                left: 50% ;
                transform: translate(-50%, -50%); /* Centraliza modais */
            }
            /* Ajuste específico para posicionar modais próximos ao chat */
            #participantListModal #participantListContent,
            #playlistModal #playlistContent {
                top: 2rem; /* Mais perto do topo */
                right: 2rem; /* Alinhado à direita */
                left: unset; /* Desativa centralização horizontal */
                transform: unset; /* Remove transform */
                margin-left: auto; /* Empurra para a direita */
                margin-right: 0; /* */
            }
            #fileMenuModal #fileMenuContent {
                top: 2rem; /* */
                left: 2rem; /* */
                right: unset;
                transform: unset;
                margin-left: 0;
                margin-right: auto; /* */
            }
        }

        /* Estilos para o rejectedNotice (mantém o flex-direction) */
        #rejectedNotice {
            flex-direction: column; /* */
            gap: 0.5rem;
            align-items: center;
        }
    </style>
</head>
<body>
    <div id="menuSetup">
        <label for="roomCode" class="sr-only">Código da sala</label>
        <input id="roomCode" placeholder="Código da sala (ex: A91J)" maxlength="4" style="text-transform:uppercase" aria-label="Campo para inserir o código da sala" />
        <button id="createRoom" class="btn" aria-label="Criar uma nova sala e configurar o nome">Criar Sala</button>
        <button id="joinRoom" class="btn" aria-label="Entrar em uma sala existente com código">Entrar na Sala</button>
    </div>

    <div id="namePrompt" style="display:none;">
        <p id="namePromptInstruction" style="color:#CCC; margin-bottom: 0.5rem;"></p>
        <label for="nickname" class="sr-only">Nome de usuário</label>
        <input id="nickname" placeholder="Seu nome de usuário" aria-label="Campo para inserir o seu nome"/>
        
        <!-- Novo: Seção de Login com Google -->
        <div class="mt-4 pt-4 border-t border-gray-600 w-full flex flex-col items-center">
            <p id="google-auth-status" class="text-sm text-gray-400 mb-2">Faça login para usar seu nome Google.</p>
            <button id="google-signin-button" class="google-btn flex items-center justify-center bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google icon" class="w-5 h-5 mr-2">
                Entrar com Google
            </button>
            <button id="google-signout-button" class="btn bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200 mt-2 hidden">
                Sair do Google
            </button>
        </div>
        <!-- Fim: Seção de Login com Google -->

        <div style="display: flex; align-items: center; gap: 0.5rem; margin-top: 1rem;">
            <input type="checkbox" id="ageRestrictionToggle" aria-label="Ativar restrição de idade +18"/>
            <label for="ageRestrictionToggle" style="color:#CCC;">Modo de Restrição de Idade +18</label>
        </div>
        <button id="enterRoom" class="btn" aria-label="Confirmar e entrar na sala">Entrar</button>
    </div>

    <div id="waitingApproval" style="display:none;">
        <img src="https://media.tenor.com/On7kvXhzml4AAAAj/loading-gif.gif" alt="Carregando"/>
        <p aria-live="assertive">Esperando o Administrador aceitar sua solicitação :D</p>
    </div>

    <div id="rejectedNotice" style="display:none;">
        <img src="https://img.freepik.com/free-icon/cancel_318-10762.jpg" alt="Recusado"/>
        <p>O Administrador (A) da sala recusou a sua solicitação de entrada :(</p>
        <button id="retryEntryBtn" class="btn">Tentar novamente</button>
    </div>

    <div id="ageVerificationModal" style="display:none;">
        <div class="custom-modal-content">
            <p>Esta sala possui restrição de idade (+18).</p>
            <p>Você confirma que tem mais de 18 anos para entrar?</p>
            <button id="confirmAgeBtn" class="btn">Tenho mais de 18 anos (Entrar)</button>
            <button id="declineAgeBtn" class="btn minor">Sou menor de idade (Sair)</button>
        </div>
    </div>

    <div id="mainUI">
        <div id="playerArea">
            <div id="mediaPlayerContainer">
                <video id="mediaPlayer" controls autoplay></video>
            </div>
            <div id="betaNoticeFixed" style="display: none;">
                **ATENÇÃO!!! TENHA CUIDADO, VERSÃO BETA!!**<br>
                Todo cuidado é pouco (Pelo Desenvolvedor)
            </div>
            <div id="controls">
                <button id="chooseMediaBtn" class="btn" aria-label="Abrir opções para adicionar mídia">Escolher Arquivo/Link/Tela</button>
                <button id="showPlaylistBtn" class="btn" aria-label="Ver lista de reprodução">📃 Playlist</button>
                <button id="showParticipantsBtn" class="btn" aria-label="Mostrar usuários na sala">👥 Usuários na Sala</button>
                
                <!-- Novos botões de controle de mídia para Admin/Mod -->
                <button id="prevMediaBtn" class="btn media-control-btn" aria-label="Voltar para a mídia anterior ou reiniciar a atual">⏪ Voltar</button>
                <button id="playPauseBtn" class="btn media-control-btn" aria-label="Pausar ou despausar a mídia">⏯ Pausar/Despausar</button>
                <button id="nextMediaBtn" class="btn media-control-btn" aria-label="Avançar para a próxima mídia">⏩ Próximo</button>

                <!-- Novo botão para expandir/recolher os botões de IA -->
                <button id="toggleAIButtonsBtn" class="btn" aria-label="Alternar visibilidade dos botões de IA">Botões de IA</button>
                
                <!-- Painel recolhível para os botões de IA -->
                <div id="aiButtonsPanel">
                    <button id="suggestContentBtn" class="btn" aria-label="Sugestão de Conteúdo">Sugestão de Conteúdo ✨</button>
                    <button id="generatePollBtn" class="btn" aria-label="Gerar Enquete">Gerar Enquete ✨</button>
                    <button id="analyzeSentimentBtn" class="btn" aria-label="Analisar Sentimento">Analisar Sentimento ✨</button>
                    <button id="generateCreativePromptBtn" class="btn" aria-label="Gerar Ideia Criativa">Ideia Criativa ✨</button>
                    <!-- Novos botões de IA -->
                    <button id="generateTriviaBtn" class="btn" aria-label="Gerar Curiosidade/Quiz">Gerar Curiosidade/Quiz ✨</button>
                    <button id="suggestMoodMediaBtn" class="btn" aria-label="Sugestão de Música/Mídia por Humor">Sugestão de Música/Mídia por Humor ✨</button>
                </div>
            </div>
        </div>
        <div id="chatArea">
            <div id="chatLog" aria-live="polite"></div>
            <div id="chatInputArea">
                <label for="chatInput" class="sr-only">Mensagem</label>
                <textarea id="chatInput" placeholder="Digite sua mensagem (máx 900 caracteres)" autocomplete="off" aria-label="Campo de mensagem" maxlength="900" rows="2"></textarea>
                <button id="summarizeChatBtn" class="btn" aria-label="Resumir o chat">Resumir Chat ✨</button>
                <button id="sendChatBtn" class="btn" aria-label="Enviar mensagem">Enviar</button>
            </div>
        </div>
    </div>

    <div id="fileMenuModal">
        <div id="fileMenuContent">
            <button class="closeBtn" onclick="document.getElementById('fileMenuModal').style.display='none'" aria-label="Fechar menu de mídia">×</button>
            <button id="selectFileBtn" class="btn" aria-label="Escolher um arquivo de vídeo ou áudio do seu dispositivo">Escolher do dispositivo</button>
            <button id="insertLinkBtn" class="btn" aria-label="Inserir um link direto para o vídeo">Inserir link de Média</button>
            <button id="shareScreenBtn" class="btn" aria-label="Transmitir a tela ao vivo">Transmitir Tela</button>
        </div>
    </div>

    <div id="participantListModal">
        <div id="participantListContent">
            <button class="closeBtn" onclick="document.getElementById('participantListModal').style.display='none'" aria-label="Fechar lista de usuários na sala">×</button>
            <div id="participantList"></div>
        </div>
    </div>

    <div id="playlistModal">
        <div id="playlistContent">
            <button class="closeBtn" onclick="document.getElementById('playlistModal').style.display='none'" aria-label="Fechar lista de reprodução">×</button>
            <div id="playlistItems"></div>
        </div>
    </div>

    <div id="betaNoticeModal" style="display: none;">
        <div id="betaNoticeContent">
            <p style="text-align: center;">
                <strong style="color: #FFD700; font-size: 1.3em;">ATENÇÃO!!! TENHA CUIDADO, VERSÃO BETA!!</strong><br><br>
                Todo cuidado é pouco (Pelo Desenvolvedor)
            </p>
        </div>
    </div>

    <!-- Custom Alert Modal -->
    <div id="customAlertDialog" class="custom-modal">
        <div class="custom-modal-content">
            <p id="customAlertMessage"></p>
            <button id="customAlertCloseBtn" class="btn">OK</button>
        </div>
    </div>

    <!-- Custom Confirm Modal -->
    <div id="customConfirmDialog" class="custom-modal">
        <div class="custom-modal-content">
            <p id="customConfirmMessage"></p>
            <div class="custom-modal-buttons">
                <button id="customConfirmYesBtn" class="btn">Sim</button>
                <button id="customConfirmNoBtn" class="btn" style="background-color: #dc3545;">Não</button>
            </div>
        </div>
    </div>

    <!-- New Participant Actions Modal -->
    <div id="participantActionsModal" class="custom-modal">
        <div id="participantActionsContent" class="custom-modal-content">
            <button class="closeBtn" onclick="document.getElementById('participantActionsModal').style.display='none'" aria-label="Fechar menu de ações do participante">×</button>
            <p>Ações para <strong id="actionUserName"></strong></p>
            <div class="custom-modal-buttons" style="flex-direction: column; gap: 0.5rem;">
                <button id="kickUserBtn" class="btn" style="background-color: #dc3545;">Expulsar</button>
                <button id="banUserBtn" class="btn" style="background-color: #6c757d;">Banir</button>
                <button id="muteUserBtn" class="btn" style="background-color: #007bff;">Silenciar</button>
            </div>
        </div>
    </div>

    <!-- New Screen Share AI Prompt Modal -->
    <div id="screenShareAiPromptModal" class="custom-modal">
        <div class="custom-modal-content">
            <p id="screenShareAiPromptMessage"></p>
            <div class="custom-modal-buttons">
                <button id="screenShareAiPromptYesBtn" class="btn">Sim, me ajude!</button>
                <button id="screenShareAiPromptNoBtn" class="btn" style="background-color: #dc3545;">Não, obrigado.</button>
            </div>
        </div>
    </div>

    <audio id="memeSound" src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg" preload="auto"></audio>

    <!-- Firebase SDKs -->
    <!-- Importante: Use as versões mais recentes dos SDKs do Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>

    <script>
        // [SEGURANÇA/ESCALABILIDADE]: O uso de localStorage para sincronização de estado de sala, participantes,
        // playlist e chat é extremamente limitado e inseguro para uma aplicação multi-usuário real.
        // Qualquer usuário pode inspecionar e modificar o localStorage, falsificando dados como isAdmin, isMod,
        // status de banimento, mensagens de chat, etc.
        // Para uma aplicação robusta, é **ALTAMENTE RECOMENDADO** o uso de um backend com WebSockets
        // e um banco de dados em tempo real como Firebase Firestore, Socket.IO, etc.
        // Isso garantiria a autenticidade dos dados e a sincronização em tempo real de forma segura.

        let isCreatingRoom = false;
        let myName = '';
        let roomID = ''; // Variável global para armazenar o código da sala

        let isAdmin = false; // Flag para verificar se o usuário atual é o administrador
        let approvalTimeout = null;
        let waitingForApproval = false;
        let currentJoinRequestId = null; // Para armazenar o ID do pedido que esta aba enviou
        let currentRoomAgeRestricted = false; // Nova variável para o estado de restrição de idade da sala

        let activePoll = null; // { id: "unique_id", question: "", options: [{ text: "", votes: 0, voters: [] }] }
        
        // AI State Variables
        let aiChatbotActive = false; // Flag for general AI interaction
        let aiSleeping = false; // Flag for AI sleeping state
        const AI_BASE_NAME = '(IA) Fox :3'; // Base name for the AI
        // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Variável para armazenar resultados de busca de mídia para seleção
        let foxAwaitingMediaSelection = null; // Stores [{ url, type, name, originalLink }, ...]
        // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Variável para aguardar confirmação de reprodução de link específico
        let foxAwaitingConfirmationForPlay = null; // { media: { url, type, name, originalLink }, userName: "user" }


        // Dados que serão sincronizados via localStorage
        let playlist = [];
        let participants = [];
        let bannedUsers = new Map(); // Map(nomeDoUsuario, { banUntil: timestamp, reason: 'motivo' })

        const LOCAL_STORAGE_PREFIX = 'myChatApp_roomState_';
        const LOCAL_STORAGE_PENDING_REQUESTS = 'myChatApp_pendingJoinRequests';
        const LOCAL_STORAGE_ALL_ROOMS = 'myChatApp_allRooms'; // Chave para todas as salas ativas
        const LOCAL_STORAGE_CHAT_PREFIX = 'myChatApp_chatMessages_'; // Prefixo para mensagens de chat
        const LOCAL_STORAGE_RELOAD_ALL = 'myChatApp_reloadAll_'; // Chave para forçar reload
        const LOCAL_STORAGE_ACTIVE_POLL = 'myChatApp_activePoll_'; // Chave para a enquete ativa
        const LOCAL_STORAGE_PLAYER_STATE = '_player'; // Suffix for player state in localStorage
        let currentPlayingIndex = -1; // To track which item in the playlist is currently playing

        let tempFoxMessageElement = null; // To store the temporary message element for geolocation prompt

        // Global variable for user message history for spam/swear detection
        let userMessageHistory = new Map(); // Stores { userName: [{ message: "...", timestamp: Date.now() }] }
        const SPAM_THRESHOLD_COUNT = 3;
        const SPAM_THRESHOLD_TIME_MS = 5000; // 5 seconds
        // [AJUSTE/BUGFIX]: Adicionado \b para garantir que a detecção de palavrões seja por palavra inteira.
        const SWEAR_WORDS = [/\bfi de rapariga\b/, /\bporra\b/, /\bfilho da puta\b/, /\bFDP\b/, /\bputa\b/, /\bcaralho\b/, /\bmerda\b/, /\bfoda-se\b/, /\bcu\b/, /\bdesgraça\b/, /\binferno\b/, /\bviado\b/, /\barrombado\b/]; // Add more as needed

        // Custom Alert Function
        function customAlert(message) {
            return new Promise(resolve => {
                const alertDialog = document.getElementById('customAlertDialog');
                const alertMessage = document.getElementById('customAlertMessage');
                const alertCloseBtn = document.getElementById('customAlertCloseBtn');

                alertMessage.textContent = message;
                alertDialog.style.display = 'flex';

                const closeHandler = () => {
                    alertDialog.style.display = 'none';
                    alertCloseBtn.removeEventListener('click', closeHandler);
                    resolve();
                };

                alertCloseBtn.addEventListener('click', closeHandler);
            });
        }

        // Custom Confirm Function
        function customConfirm(message) {
            return new Promise(resolve => {
                const confirmDialog = document.getElementById('customConfirmDialog');
                const confirmMessage = document.getElementById('customConfirmMessage');
                const confirmYesBtn = document.getElementById('customConfirmYesBtn');
                const confirmNoBtn = document.getElementById('customConfirmNoBtn');

                confirmMessage.textContent = message;
                confirmDialog.style.display = 'flex';

                const yesHandler = () => {
                    confirmDialog.style.display = 'none';
                    confirmYesBtn.removeEventListener('click', yesHandler);
                    confirmNoBtn.removeEventListener('click', noHandler);
                    resolve(true);
                };

                const noHandler = () => {
                    confirmDialog.style.display = 'none';
                    confirmYesBtn.removeEventListener('click', yesHandler);
                    confirmNoBtn.removeEventListener('click', noHandler);
                    resolve(false);
                };

                confirmYesBtn.addEventListener('click', yesHandler);
                confirmNoBtn.addEventListener('click', noHandler);
            });
        }

        // --- Funções de Sincronização com localStorage ---

        function getAllActiveRooms() {
            try {
                const storedRooms = localStorage.getItem(LOCAL_STORAGE_ALL_ROOMS);
                const rooms = storedRooms ? JSON.parse(storedRooms) : [];
                console.log(`[DEBUG_LS] getAllActiveRooms:`, rooms);
                return rooms;
            } catch (e) {
                console.error("Erro ao ler myChatApp_allRooms do localStorage:", e);
                return [];
            }
        }

        function saveAllActiveRooms(roomsArray) {
            try {
                localStorage.setItem(LOCAL_STORAGE_ALL_ROOMS, JSON.stringify(roomsArray));
                console.log(`[DEBUG_LS] saveAllActiveRooms:`, roomsArray);
            } catch (e) {
                console.error("Erro ao salvar myChatApp_allRooms no localStorage:", e);
            }
        }

        function saveRoomState(id, state) {
            try {
                localStorage.setItem(LOCAL_STORAGE_PREFIX + id, JSON.stringify(state));
                console.log(`[DEBUG_LS] Estado da sala ${id} salvo no localStorage. Participants:`, state.participants.map(p => p.name));
            } catch (e) {
                console.error(`Erro ao salvar estado da sala ${id} no localStorage:`, e);
            }
        }

        function loadRoomState(id) {
            try {
                const storedState = localStorage.getItem(LOCAL_STORAGE_PREFIX + id);
                if (storedState) {
                    const state = JSON.parse(storedState);
                    // [BUG/MELHORIA]: Ao carregar, o `bannedUsers` precisa ser recriado como Map, pois JSON.parse o converte em Array.
                    // O código já faz isso, o que é bom.
                    state.bannedUsers = new Map(state.bannedUsers);
                    // Load AI states
                    aiSleeping = state.aiSleeping || false;
                    aiChatbotActive = state.aiChatbotActive || false;
                    console.log(`[DEBUG_LS] Estado da sala ${id} carregado do localStorage. Participants:`, state.participants.map(p => p.name));
                    return state;
                }
            } catch (e) {
                console.error(`Erro ao carregar estado da sala ${id} do localStorage:`, e);
            }
            console.log(`[DEBUG_LS] Nenhum estado encontrado para a sala ${id} no localStorage.`);
            return null;
        }

        function updateRoomStateInLocalStorage() {
            if (!roomID) {
                console.log(`[DEBUG_LS] Não há roomID para atualizar o estado no localStorage.`);
                return; // Só atualiza se estiver em uma sala
            }
            const state = {
                roomID: roomID,
                participants: participants,
                playlist: playlist,
                bannedUsers: Array.from(bannedUsers.entries()), // Converte Map para Array para JSON
                ageRestricted: currentRoomAgeRestricted, // Salva o estado de restrição de idade
                aiSleeping: aiSleeping, // Save AI sleeping state
                aiChatbotActive: aiChatbotActive // Save AI active state
            };
            saveRoomState(roomID, state);
            console.log(`[DEBUG_LS] Estado da sala ${roomID} atualizado no localStorage. Participants:`, state.participants.map(p => p.name));
        }

        function fetchAndUpdateLocalRoomData(id) {
            console.log(`[DEBUG_LS] fetchAndUpdateLocalRoomData called for room: ${id}`);
            const state = loadRoomState(id); // loadRoomState now handles aiSleeping and aiChatbotActive
            if (state) {
                participants = state.participants;
                playlist = state.playlist;
                bannedUsers = state.bannedUsers;
                currentRoomAgeRestricted = state.ageRestricted || false;
                aiSleeping = state.aiSleeping || false; // Load AI sleeping state
                aiChatbotActive = state.aiChatbotActive || false; // Load AI active state
                updateParticipantList();
                updatePlaylist();
                updateAIBottonVisibility();
                updateAIFoxDisplay(); // Ensure Fox's name is correctly displayed after loading
                console.log(`[DEBUG_LS] Dados da sala ${id} atualizados localmente. Current participants:`, [...participants]);
            } else {
                console.log(`[DEBUG_LS] Nenhum estado encontrado para a sala ${id}. Não foi possível atualizar dados locais.`);
                // If no state found, ensure AI is not active
                aiSleeping = false;
                aiChatbotActive = false;
                participants = []; // Reset participants as well
            }
        }

        function cleanOldChatMessages() {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(LOCAL_STORAGE_CHAT_PREFIX) && key !== LOCAL_STORAGE_CHAT_PREFIX + roomID) {
                    console.log(`[DEBUG_LS] Removendo chat antigo: ${key}`);
                    localStorage.removeItem(key);
                }
            }
        }

        // --- Listener para eventos de storage (sincronização entre abas) ---
        window.addEventListener('storage', (event) => {
            // Se o evento for para o estado da sala que estamos, atualiza
            if (event.key && event.key.startsWith(LOCAL_STORAGE_PREFIX)) {
                const changedRoomID = event.key.substring(LOCAL_STORAGE_PREFIX.length);
                if (changedRoomID === roomID) {
                    console.log(`[STORAGE EVENT] Estado da sala ${changedRoomID} mudou. Atualizando dados locais.`);
                    fetchAndUpdateLocalRoomData(changedRoomID);
                    // Força recarregar mensagens do chat se o estado da sala mudar
                    loadChatMessages();
                }
            }
            // NEW: If the event is for the list of all active rooms, re-read it
            if (event.key === LOCAL_STORAGE_ALL_ROOMS) {
                console.log(`[STORAGE EVENT] Lista de salas ativas mudou. Recarregando.`);
                // No need to call getAllActiveRooms() here, as it's called on demand.
                // But this event signifies that the list *might* have changed,
                // so subsequent calls to getAllActiveRooms() will get the latest.
            }
            // Se o evento for para pedidos de entrada pendentes, e esta aba é a do admin
            if (event.key === LOCAL_STORAGE_PENDING_REQUESTS && isAdmin) {
                console.log(`[STORAGE EVENT] Pedidos pendentes mudaram. Verificando...`);
                handleIncomingJoinRequest();
            }
            // Se o evento for para uma resposta a um pedido de entrada que esta aba enviou
            if (event.key === LOCAL_STORAGE_PENDING_REQUESTS && waitingForApproval) {
                console.log(`[STORAGE EVENT] Verificando resposta para meu pedido de entrada. Event key: ${event.key}, newValue: ${event.newValue}`);
                checkMyJoinRequestStatus();
            }
            // Se o evento for para mensagens de chat da sala atual
            if (event.key === LOCAL_STORAGE_CHAT_PREFIX + roomID) {
                console.log(`[STORAGE EVENT] Mensagens do chat da sala ${roomID} mudaram. Recarregando chat.`);
                loadChatMessages();
            }
            // Se o evento for para forçar reload
            if (event.key === LOCAL_STORAGE_RELOAD_ALL + roomID && event.newValue === 'true') {
                if (!isAdmin) { // Apenas clientes não-admin devem recarregar
                    console.log(`[STORAGE EVENT] Comando de recarregar recebido. Recarregando página...`);
                    localStorage.removeItem(LOCAL_STORAGE_RELOAD_ALL + roomID); // Limpa o flag
                    window.location.reload();
                }
            }
            // Se o evento for para a enquete ativa
            if (event.key === LOCAL_STORAGE_ACTIVE_POLL + roomID) {
                console.log(`[STORAGE EVENT] Enquete ativa mudou. Atualizando.`);
                loadPollState();
            }
             // Handle AI Chatbot auto-deactivation
            if (event.key === LOCAL_STORAGE_PREFIX + roomID) {
                const newState = JSON.parse(event.newValue);
                // The AI should only exit if explicitly told to, or if the admin closes the room.
                // This automatic exit logic when other participants enter is removed per user request.
                // if (aiChatbotActive && newState && newState.participants.length > 1 && newState.participants.some(p => p.name !== myName)) {
                //     aiChatbotActive = false;
                //     addSystemMessage('Fox saiu da sala, pois outros participantes entraram.'); // Updated message
                // }
            }
            // Player state synchronization
            if (event.key === LOCAL_STORAGE_PREFIX + roomID + LOCAL_STORAGE_PLAYER_STATE && !isAdmin) {
                // [BUG/MELHORIA]: A condição `!isAdmin` para aplicar o estado do player é boa, mas `!isMod(myName)` também deveria ser incluída
                // para garantir que mods também não apliquem o estado de outros, evitando loops de feedback.
                // Isso já está sendo feito em `applyPlayerState`, mas a checagem aqui pode ser mais explícita.
                if (!isAdmin && !isMod(myName)) { // Adicionado isMod aqui para consistência
                    try {
                        const newState = JSON.parse(event.newValue);
                        if (newState) {
                            applyPlayerState(newState);
                        }
                    } catch (e) {
                        console.error('Erro ao parsear estado do player do localStorage:', e);
                    }
                }
            }
        });


        // --- Funções de Pedidos de Entrada (Admin) ---
        // Simula um pedido de entrada sendo colocado no localStorage
        function sendJoinRequest(requestingName, targetRoomID) {
            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            // Adiciona um identificador único para o pedido para evitar duplicatas e permitir rejeições específicas
            const requestId = `${targetRoomID}-${requestingName}-${Date.now()}`;
            requests.push({ id: requestId, roomID: targetRoomID, name: requestingName, status: 'pending' });
            localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
            console.log(`[DEBUG] Pedido de entrada de ${requestingName} para ${targetRoomID} enviado. ID: ${requestId}`);
            return requestId; // Retorna o ID do pedido para o cliente que enviou
        }

        // Simula a resposta do administrador para um pedido de entrada
        function respondToJoinRequest(requestId, approved) {
            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            const requestIndex = requests.findIndex(req => req.id === requestId);

            if (requestIndex !== -1) {
                requests[requestIndex].status = approved ? 'approved' : 'rejected';
                localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
                console.log(`[DEBUG] Pedido ${requestId} ${approved ? 'aprovado' : 'rejeitado'}.`);
            }
        }

        // Função para o administrador verificar e processar pedidos de entrada
        async function handleIncomingJoinRequest() { // Adicionado 'async'
            if (!isAdmin || !roomID) return;

            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            const pendingRequestsForMyRoom = requests.filter(req => req.roomID === roomID && req.status === 'pending');

            if (pendingRequestsForMyRoom.length > 0) {
                for (const request of pendingRequestsForMyRoom) { // Usar for...of para await
                    // Verifica se o usuário já está na sala para evitar aprovações duplicadas
                    const alreadyInRoom = participants.some(p => p.name === request.name);
                    if (alreadyInRoom) {
                        console.log(`[DEBUG] Usuário ${request.name} já está na sala. Ignorando pedido.`);
                        // Marcar como "aprovado" para limpar o pedido pendente, mesmo que já esteja na sala
                        respondToJoinRequest(request.id, true);
                        continue; // Pula para o próximo pedido
                    }

                    // Remove o pedido pendente do localStorage *antes* de perguntar
                    // Isso evita que outras abas de admin vejam o mesmo pedido ao mesmo tempo
                    requests = requests.filter(req => req.id !== request.id);
                    localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));

                    const aprovado = await customConfirm(`O participante ${request.name} quer entrar na sala ${request.roomID}. Aceitar?`); // Usar customConfirm
                    respondToJoinRequest(request.id, aprovado);

                    if (aprovado) {
                        addParticipant(request.name, false); // Adiciona como participante normal
                        addSystemMessage(`${request.name} foi aceito na sala.`);
                    } else {
                        addSystemMessage(`${request.name} foi recusado na sala.`);
                    }
                }
            }
        }

        // Inicia a verificação periódica de pedidos de entrada para o admin (segurança extra)
        setInterval(() => {
            if (isAdmin && roomID) {
                handleIncomingJoinRequest();
            }
        }, 1000); // Verifica a cada segundo


        // Função para o cliente verificar o status do seu pedido de entrada
        function checkMyJoinRequestStatus() {
            if (!waitingForApproval || !currentJoinRequestId) return;

            const requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            const myRequest = requests.find(req => req.id === currentJoinRequestId);

            if (myRequest) {
                console.log(`[CLIENT DEBUG] My request status: ${myRequest.status}`);
                if (myRequest.status === 'approved') {
                    console.log(`[CLIENT DEBUG] My request approved! Calling enterRoomConfirmed.`);
                    clearTimeout(approvalTimeout);
                    waitingForApproval = false;
                    currentJoinRequestId = null;
                    addSystemMessage('Você foi aceito na sala!');
                    enterRoomConfirmed(roomID, myName, false); // Entra na sala como participante
                } else if (myRequest.status === 'rejected') {
                    console.log(`[CLIENT DEBUG] My request rejected! Showing notice.`);
                    clearTimeout(approvalTimeout);
                    waitingForApproval = false;
                    currentJoinRequestId = null;
                    showRejectedNotice(myRequest.reason || 'Sua solicitação foi recusada.'); // Adiciona motivo se houver
                }
            } else {
                // [BUG]: Se o pedido for processado e removido rapidamente pelo admin,
                // esta aba pode não encontrar o pedido e ficar em `waitingApproval` indefinidamente.
                // A lógica atual de `handleIncomingJoinRequest` no admin já remove o pedido antes de perguntar,
                // o que pode causar isso.
                // MELHORIA: O admin deveria *manter* o pedido e apenas alterar o status,
                // e o cliente deveria remover *seu próprio* pedido após ver a resposta.
                // Para o localStorage, a remoção imediata pelo admin é uma forma de evitar duplicatas, mas gera essa race condition.
                // Uma solução mais robusta seria ter um ID de transação e o admin enviar um "sinal" de resposta para o cliente específico.
                console.log(`[CLIENT DEBUG] My request (${currentJoinRequestId}) not found in storage. It might have been processed or removed.`);
                // Se o pedido não for encontrado, e ainda estamos esperando, assumimos que foi processado e limpamos o estado de espera.
                // Isso evita que o usuário fique preso na tela de "Esperando Aprovação".
                if (waitingForApproval) {
                    clearTimeout(approvalTimeout);
                    waitingForApproval = false;
                    currentJoinRequestId = null;
                    // Poderíamos adicionar um alerta aqui, mas para evitar spam, talvez seja melhor apenas limpar o estado.
                    // customAlert('Sua solicitação de entrada pode ter sido processada. Tente novamente ou verifique com o administrador.');
                    showScreen('menuSetup'); // Volta para o menu principal
                }
            }
        }


        // --- Funções Auxiliares de UI/Chat ---
        function addSystemMessage(msg) {
            const chatLog = document.getElementById('chatLog');
            const p = document.createElement('p');
            p.classList.add('system-message');
            p.textContent = msg;
            chatLog.appendChild(p);
            chatLog.scrollTop = chatLog.scrollHeight;
            saveChatMessage(msg, 'system'); // Salva mensagens do sistema no chat
        }

        function addPrivateMessage(msg, isWarning = false) {
            const chatLog = document.getElementById('chatLog');
            const p = document.createElement('p');
            p.classList.add('private-message');
            if (isWarning) {
                p.classList.add('warning-message');
            }
            p.textContent = `[Você]: ${msg}`;
            chatLog.appendChild(p);
            chatLog.scrollTop = chatLog.scrollHeight;
            saveChatMessage(`[Você]: ${msg}`, 'private', isWarning); // Salva mensagens privadas
        }

        function addChatMessage(sender, message) {
            const chatLog = document.getElementById('chatLog');
            const p = document.createElement('p');
            p.textContent = `${sender}: ${message}`;
            chatLog.appendChild(p);
            chatLog.scrollTop = chatLog.scrollHeight;
            saveChatMessage(`${sender}: ${message}`, 'chat'); // Salva mensagens de chat
        }

        // [NOVA FUNCIONALIDADE]: Função para adicionar uma mensagem de link clicável ao chat
        function addClickableLinkMessage(sender, originalLink, processedUrl, mediaType, mediaName) {
            const chatLog = document.getElementById('chatLog');
            const p = document.createElement('p');
            
            const senderSpan = document.createElement('span');
            senderSpan.textContent = `${sender}: `;
            p.appendChild(senderSpan);

            const linkText = `Link: ${mediaName || originalLink}`; // Use mediaName if available, otherwise originalLink
            const a = document.createElement('a');
            a.href = "#"; // Prevent navigation
            a.textContent = linkText;
            a.classList.add('chat-link'); // Add class for styling
            a.onclick = (e) => {
                e.preventDefault(); // Prevent default link behavior
                // [AJUSTE/BUGFIX]: playAndBroadcast já verifica permissões.
                // Se o usuário não for admin/mod, a função playAndBroadcast emitirá a mensagem de erro.
                playAndBroadcast(processedUrl, mediaType, mediaName, false); // Initiated by user (not AI)
            };
            p.appendChild(a);
            
            chatLog.appendChild(p);
            chatLog.scrollTop = chatLog.scrollHeight;

            // Salva a mensagem como tipo 'link' com os dados necessários para recriar o link clicável
            saveChatMessage(originalLink, 'link', false, processedUrl, mediaType, mediaName, sender); // Pass sender for consistency
        }


        // Function to add a temporary message locally (not saved to localStorage)
        function addLocalTempMessage(sender, message) {
            const chatLog = document.getElementById('chatLog');
            const p = document.createElement('p');
            p.textContent = `${sender}: ${message}`;
            p.classList.add('system-message'); // Use system message style for temporary messages
            chatLog.appendChild(p);
            chatLog.scrollTop = chatLog.scrollHeight;
            tempFoxMessageElement = p; // Store reference to this temporary message
            return p;
        }

        // Function to remove the last temporary message
        function removeTempMessage() {
            if (tempFoxMessageElement && tempFoxMessageElement.parentNode) {
                tempFoxMessageElement.parentNode.removeChild(tempFoxMessageElement);
                tempFoxMessageElement = null; // Clear the reference
            }
        }

        // Funções para salvar e carregar mensagens de chat
        // [AJUSTE/BUGFIX]: Adicionado `url`, `mediaType`, `mediaName` e `sender` para links
        function saveChatMessage(message, type, isWarning = false, url = null, mediaType = null, mediaName = null, sender = null) {
            let chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
            const chatMessageData = { message, type, isWarning, timestamp: Date.now() };

            if (type === 'link') {
                chatMessageData.url = url;
                chatMessageData.mediaType = mediaType;
                chatMessageData.mediaName = mediaName;
                chatMessageData.sender = sender; // Store sender for link messages
            }
            chatMessages.push(chatMessageData);
            localStorage.setItem(LOCAL_STORAGE_CHAT_PREFIX + roomID, JSON.stringify(chatMessages));
        }

        function loadChatMessages() {
            const chatLog = document.getElementById('chatLog');
            chatLog.innerHTML = ''; // Limpa o chat atual
            let chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
            chatMessages.forEach(msg => {
                if (msg.type === 'system') {
                    addSystemMessage(msg.message);
                } else if (msg.type === 'private') {
                    // [AJUSTE/BUGFIX]: A função addPrivateMessage já adiciona "[Você]: ". Ao carregar,
                    // se a mensagem já contém "[Você]: ", ela será duplicada.
                    // CORREÇÃO: Verificar se a mensagem já começa com "[Você]: " antes de adicionar.
                    // Ou, melhor, salvar a mensagem original sem o prefixo e adicioná-lo apenas na exibição.
                    // Por simplicidade, ajustado para remover o prefixo antes de chamar `addPrivateMessage`.
                    const messageToDisplay = msg.message.startsWith('[Você]: ') ? msg.message.substring('[Você]: '.length) : msg.message;
                    addPrivateMessage(messageToDisplay, msg.isWarning);
                } else if (msg.type === 'link') { // [NOVA FUNCIONALIDADE]: Carrega links clicáveis
                    addClickableLinkMessage(msg.sender, msg.message, msg.url, msg.mediaType, msg.mediaName);
                }
                else {
                    // [AJUSTE/BUGFIX]: Se a mensagem original já foi salva com o formato "Sender: Message",
                    // `addChatMessage` irá adicionar "Sender: Sender: Message".
                    // CORREÇÃO: A `addChatMessage` já espera `sender` e `message`.
                    // A linha `p.textContent = `${sender}: ${message}`;` no `addChatMessage`
                    // já faz a formatação. O ideal é salvar apenas o `sender` e o `message` separadamente.
                    // Para o código atual, a solução é extrair o sender e o content da mensagem salva.
                    const parts = msg.message.split(': ');
                    const sender = parts.shift(); // Pega o primeiro elemento (nome)
                    const messageContent = parts.join(': '); // Junta o restante como a mensagem
                    addChatMessage(sender, messageContent);
                }
            });
            chatLog.scrollTop = chatLog.scrollHeight;
            loadPollState(); // Garante que a enquete seja carregada após as mensagens
        }

        // Function to update the AI Fox's display name in the participants list
        function updateAIFoxDisplay() {
            const foxIndex = participants.findIndex(p => p.isAI);
            if (foxIndex !== -1) {
                let currentFoxName = AI_BASE_NAME;
                if (aiSleeping) {
                    currentFoxName += ' (Dormindo💤)';
                }
                participants[foxIndex].name = currentFoxName;
                // [MELHORIA]: `updateParticipantList()` já chama `updateRoomStateInLocalStorage()`.
                // Chamar `updateParticipantList()` aqui é suficiente para atualizar a UI e persistir.
                updateParticipantList(); // Re-render list and save state
            }
        }

        function updateParticipantList() {
            const list = document.getElementById('participantList');
            list.innerHTML = '';
            if (participants.length === 0) {
                list.textContent = 'Nenhum usuário na sala.';
                return;
            }
            participants.forEach(p => {
                const div = document.createElement('div');
                div.className = 'playlistItem';
                
                let role = '';
                if (p.isAdmin) role = '(admin)';
                else if (p.isMod) role = '(mod)';
                
                let displayName = p.name;
                // If it's the AI, ensure its name is updated based on its state
                if (p.isAI) {
                    displayName = aiSleeping ? `${AI_BASE_NAME} (Dormindo💤)` : AI_BASE_NAME;
                }

                let status = '';
                if (p.isMuted) {
                    status = ' (mutado 🔇)';
                }

                div.textContent = `${displayName} ${role}${status}`;
                div.dataset.userName = p.name; // Store username for click handler

                // Add click listener only if current user is admin/mod and not clicking on self or AI
                if ((isAdmin || isMod(myName)) && p.name !== myName && !p.isAI) {
                    div.onclick = () => showParticipantActionsModal(p.name);
                }

                // Adicionar botões de ação para o admin (kick/ban) (removidos daqui para o modal)
                list.appendChild(div);
            });
            // Importante: Chama saveRoomState aqui para garantir que participantes são persistidos
            updateRoomStateInLocalStorage();
        }

        function isMod(userName) {
            const user = participants.find(p => p.name === userName);
            return user && user.isMod;
        }

        function updatePlaylist() {
            const list = document.getElementById('playlistItems');
            list.innerHTML = '';
            if (playlist.length === 0) {
                list.textContent = 'Playlist vazia.';
                return;
            }
            playlist.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'playlistItem';
                const span = document.createElement('span');
                span.textContent = item.name;
                const small = document.createElement('small');
                small.textContent = `${item.type.toUpperCase()} - adicionado por ${item.addedBy}`;
                div.appendChild(span);
                div.appendChild(small);

                // Add click listener to play item instantly if admin/mod
                if (isAdmin || isMod(myName)) {
                    div.onclick = () => playAndBroadcast(item.url, item.type, item.name);
                }

                if (isAdmin) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Remover';
                    deleteBtn.className = 'btn';
                    deleteBtn.style.marginLeft = '10px';
                    deleteBtn.style.backgroundColor = '#dc3545'; // Vermelho
                    deleteBtn.onclick = (e) => { // Prevent click on parent from triggering
                        e.stopPropagation();
                        removePlaylistItem(index);
                    };
                    div.appendChild(deleteBtn);
                }
                list.appendChild(div);
            });
            // Importante: Chama saveRoomState aqui para garantir que a playlist é persistida
            updateRoomStateInLocalStorage();
        }

        function removePlaylistItem(index) {
            if (index >= 0 && index < playlist.length) {
                const removedItem = playlist.splice(index, 1);
                addSystemMessage(`Item "${removedItem[0].name}" removido da playlist.`);
                updatePlaylist(); // Atualiza a UI e salva o estado
                // Notificar outros sobre a mudança na playlist (via storage event)
                // [MELHORIA]: A chamada a `updatePlaylist()` já faz isso, então a linha abaixo é redundante.
                // updateRoomStateInLocalStorage();
            }
        }


        // --- Funções de gerenciamento de Participantes (Kick/Ban/Mute) ---

        function kickUser(userName, reason = 'Sem motivo.') {
            // [SEGURANÇA]: Estas verificações de isAdmin/isMod são client-side e podem ser facilmente burladas.
            // Em uma aplicação real, a lógica de kick/ban/mute precisa ser validada no servidor.
            if (!isAdmin && !isMod(myName)) {
                addPrivateMessage('Você não tem permissão para remover usuários.', true);
                return;
            }
            if (userName === myName) {
                addPrivateMessage('Você não pode remover a si mesmo.', true);
                return;
            }

            participants = participants.filter(p => p.name !== userName);
            addSystemMessage(`${userName} foi removido da sala. Motivo: ${reason}`);
            updateParticipantList(); // Atualiza a UI e salva o estado
            // [MELHORIA]: A chamada a `updateParticipantList()` já faz isso, então a linha abaixo é redundante.
            // updateRoomStateInLocalStorage(); // Força a atualização para que outras abas saibam

            // Informa ao usuário que foi "kickado" através de um pedido de rejeição específico
            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            // Cria um pedido falso rejeitado para notificar o cliente kickado
            const kickNotificationId = `kick-${userName}-${roomID}-${Date.now()}`;
            requests.push({ id: kickNotificationId, roomID: roomID, name: userName, status: 'rejected', reason: `Você foi removido da sala. Motivo: ${reason}` });
            localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
        }


        function banUser(userName, reason = 'Sem motivo.', durationMinutes = 0) {
            // [SEGURANÇA]: Mesma observação de segurança para kickUser.
            if (!isAdmin && !isMod(myName)) {
                addPrivateMessage('Você não tem permissão para banir usuários.', true);
                return;
            }
            if (userName === myName) {
                addPrivateMessage('Você não pode banir a si mesmo.', true);
                return;
            }

            let banUntil = 0;
            let banReasonText = '';

            if (durationMinutes > 0) {
                banUntil = Date.now() + (durationMinutes * 60 * 1000);
                banReasonText = `Banido por ${durationMinutes} minutos.`;
            } else {
                banReasonText = 'Banido permanentemente.';
            }
            if (reason) {
                banReasonText += ` Motivo: ${reason}`;
            }

            bannedUsers.set(userName, { banUntil: banUntil, reason: banReasonText });
            participants = participants.filter(p => p.name !== userName); // Remove da lista de participantes ativos
            addSystemMessage(`${userName} foi banido da sala. ${banReasonText}`);
            updateParticipantList();
            // [MELHORIA]: A chamada a `updateParticipantList()` já faz isso, então a linha abaixo é redundante.
            // updateRoomStateInLocalStorage();

            // Notifica o usuário banido
            let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
            const banNotificationId = `ban-${userName}-${roomID}-${Date.now()}`;
            requests.push({ id: banNotificationId, roomID: roomID, name: userName, status: 'rejected', reason: `Você foi banido da sala. ${banReasonText}` });
            localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
        }

        function muteUser(userName) {
            // [SEGURANÇA]: Mesma observação de segurança para kickUser.
            if (!isAdmin && !isMod(myName)) {
                addPrivateMessage('Você não tem permissão para silenciar usuários.', true);
                return;
            }
            if (userName === myName) {
                addPrivateMessage('Você não pode silenciar a si mesmo.', true);
                return;
            }

            const targetUser = participants.find(p => p.name === userName);
            if (targetUser) {
                targetUser.isMuted = !targetUser.isMuted; // Toggle mute status
                addSystemMessage(`${targetUser.name} foi ${targetUser.isMuted ? 'silenciado 🔇' : 'dessilenciado ✅'}.`);
                updateParticipantList(); // Update UI and save state
                // [MELHORIA]: A chamada a `updateParticipantList()` já faz isso, então a linha abaixo é redundante.
                // updateRoomStateInLocalStorage();
            } else {
                addPrivateMessage(`Usuário "${userName}" não encontrado na sala.`, true);
            }
        }


        // Função para verificar se um usuário está banido
        function isUserBanned(userName, roomId) {
            const roomState = loadRoomState(roomId);
            if (roomState && roomState.bannedUsers) {
                const bannedData = roomState.bannedUsers.get(userName);
                if (bannedData) {
                    if (bannedData.banUntil === 0 || bannedData.banUntil > Date.now()) {
                        return true;
                    } else {
                        // Se o banimento expirou, remove da lista de banidos
                        roomState.bannedUsers.delete(userName);
                        saveRoomState(roomId, roomState);
                        return false;
                    }
                }
            }
            return false;
        }

        function findParticipant(name) {
            // [BUG]: A busca por `toLowerCase()` é boa para flexibilidade, mas certifique-se de que
            // o nome armazenado em `myName` e `participants` é consistente (case-sensitive ou não).
            // Atualmente, `myName` é `trim()` e `roomCode` é `toUpperCase()`.
            // Para `nickname`, não há `toUpperCase()`, então pode haver inconsistência de case.
            // MELHORIA: Padronizar o case dos nomes de usuário (ex: sempre `toLowerCase()` ao armazenar e comparar).
            return participants.find(p => p.name.toLowerCase() === name.toLowerCase());
        }

        function setParticipantRole(userName, role, value) {
            // [SEGURANÇA]: Mesma observação de segurança para kickUser.
            if (!isAdmin) {
                addPrivateMessage('Você não tem permissão para alterar cargos.', true);
                return;
            }
            if (userName === myName && role === 'isAdmin' && !value) {
                addPrivateMessage('Você não pode remover seu próprio status de administrador.', true);
                return;
            }
            const targetUser = findParticipant(userName);
            if (targetUser) {
                targetUser[role] = value;
                addSystemMessage(`${targetUser.name} agora ${value ? 'é' : 'não é mais'} ${role.replace('is', '')}.`);
                updateParticipantList();
                // [MELHORIA]: A chamada a `updateParticipantList()` já faz isso, então a linha abaixo é redundante.
                // updateRoomStateInLocalStorage();
            } else {
                addPrivateMessage(`Usuário "${userName}" não encontrado na sala.`, true);
            }
        }


        // --- Funções de Navegação e Estados da UI ---
        function showScreen(screenId) {
            document.getElementById('menuSetup').style.display = 'none';
            document.getElementById('namePrompt').style.display = 'none';
            document.getElementById('mainUI').style.display = 'none';
            document.getElementById('waitingApproval').style.display = 'none';
            document.getElementById('rejectedNotice').style.display = 'none';
            document.getElementById('ageVerificationModal').style.display = 'none'; // Esconde o modal de idade
            document.getElementById('participantActionsModal').style.display = 'none'; // Esconde o modal de ações de participante
            document.getElementById('screenShareAiPromptModal').style.display = 'none'; // Esconde o modal de prompt da IA
            document.getElementById(screenId).style.display = 'flex'; // Usar 'flex' para as telas modais
        }

        function showRejectedNotice(reason = "O Administrador (A) da sala recusou a sua solicitação de entrada :(") {
            document.getElementById('rejectedNotice').querySelector('p').textContent = reason;
            showScreen('rejectedNotice');
        }

        // Função para gerar um código de sala aleatório
        function generateRoomCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 4; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        // Função para iniciar a criação de uma sala
        document.getElementById('createRoom').onclick = async () => { // Adicionado 'async'
            let generatedCode = '';
            let isUnique = false;
            let attempts = 0;
            const maxAttempts = 10; // Evitar loop infinito em caso de muitos códigos em uso

            while (!isUnique && attempts < maxAttempts) {
                generatedCode = generateRoomCode();
                const activeRooms = getAllActiveRooms();
                const existingRoom = activeRooms.find(r => r.id === generatedCode);
                if (!existingRoom) {
                    isUnique = true;
                }
                attempts++;
            }

            if (!isUnique) {
                await customAlert('Não foi possível gerar um código de sala único. Tente novamente.');
                return;
            }

            roomID = generatedCode;
            isCreatingRoom = true;
            showScreen('namePrompt');
            document.getElementById('namePromptInstruction').textContent = `Digite seu nome para criar a sala "${roomID}":`; // Instrução para criar sala com código gerado
            document.getElementById('nickname').focus();
        };

        // Função para tentar entrar em uma sala
        document.getElementById('joinRoom').onclick = async () => { // Adicionado 'async'
            roomID = document.getElementById('roomCode').value.trim().toUpperCase();
            if (roomID.length !== 4) {
                await customAlert('O código da sala deve ter 4 caracteres.'); // Usar customAlert
                return;
            }

            // Verifica se a sala existe
            const activeRooms = getAllActiveRooms(); // <--- Gets the list of rooms
            const existingRoom = activeRooms.find(r => r.id === roomID); // <--- Checks if the room exists

            console.log(`[DEBUG_JOIN] Checking for room ${roomID}. Active rooms:`, activeRooms);
            console.log(`[DEBUG_JOIN] Found existingRoom:`, existingRoom);

            if (!existingRoom) {
                const createNew = await customConfirm(`A sala ${roomID} não existe. Deseja criar uma Sala?`); // Usar customConfirm
                if (createNew) {
                    // Se o usuário optar por criar, simula o clique no botão "Criar Sala"
                    // e preenche o input com o código para que o fluxo de criação o use.
                    document.getElementById('roomCode').value = roomID; // Preenche o input
                    document.getElementById('createRoom').click();
                }
                return;
            }

            // Carrega o estado da sala para verificar a restrição de idade
            const roomState = loadRoomState(roomID);
            currentRoomAgeRestricted = roomState ? roomState.ageRestricted : false;

            if (currentRoomAgeRestricted) {
                showScreen('ageVerificationModal');
            } else {
                // Se não houver restrição de idade, procede diretamente para o prompt de nome
                isCreatingRoom = false; // Não está criando, está tentando entrar
                showScreen('namePrompt');
                document.getElementById('namePromptInstruction').textContent = `Digite seu nome para entrar na sala "${roomID}":`; // Instrução para entrar na sala
                document.getElementById('nickname').focus();
            }
        };

        // Lógica para o botão "Tenho mais de 18 anos (Entrar)"
        document.getElementById('confirmAgeBtn').onclick = async () => {
            myName = document.getElementById('nickname').value.trim(); // Pega o nome do prompt anterior
            if (!myName) {
                // Se o nickname estiver vazio, mas o usuário estiver logado com o Google, usa o nome do Google
                if (firebase.auth().currentUser && firebase.auth().currentUser.displayName) {
                    myName = firebase.auth().currentUser.displayName;
                } else {
                    await customAlert('Por favor, digite seu nome de usuário.');
                    showScreen('namePrompt'); // Volta para o prompt de nome se estiver vazio
                    return;
                }
            }

            // Verifica se o nome já está em uso na sala (para evitar colisões)
            const roomState = loadRoomState(roomID);
            if (roomState && roomState.participants.some(p => p.name === myName)) {
                await customAlert(`O nome "${myName}" já está em uso nesta sala. Escolha outro nome.`);
                document.getElementById('nickname').value = ''; // Limpa o nickname para o usuário tentar novamente
                showScreen('namePrompt'); // Volta para o prompt de nome
                return;
            }
            
            // Verifica se está banido
            if (isUserBanned(myName, roomID)) {
                const bannedReason = roomState.bannedUsers.get(myName)?.reason || 'Você foi banido desta sala.';
                showRejectedNotice(bannedReason);
                return;
            }

            // Envia o pedido e espera
            waitingForApproval = true;
            currentJoinRequestId = sendJoinRequest(myName, roomID);
            showScreen('waitingApproval');

            // Configura um timeout para caso o admin não responda (opcional)
            approvalTimeout = setTimeout(() => {
                if (waitingForApproval) {
                    showRejectedNotice('Sua solicitação expirou ou não foi respondida pelo administrador.');
                    waitingForApproval = false;
                    currentJoinRequestId = null;
                }
            }, 60000); // 1 minuto de timeout
        };

        // Lógica para o botão "Sou menor de idade (Sair)"
        document.getElementById('declineAgeBtn').onclick = () => {
            addSystemMessage('Entrada cancelada devido à restrição de idade.');
            window.location.reload(); // Recarrega a página ou volta para o menu inicial
        };


        // Confirmar nome e processar entrada/criação (chamado após o prompt de nome)
        document.getElementById('enterRoom').onclick = async () => { // Adicionado 'async'
            myName = document.getElementById('nickname').value.trim();
            if (!myName) {
                // Se o nickname estiver vazio, mas o usuário estiver logado com o Google, usa o nome do Google
                if (firebase.auth().currentUser && firebase.auth().currentUser.displayName) {
                    myName = firebase.auth().currentUser.displayName;
                } else {
                    await customAlert('Por favor, digite seu nome de usuário.'); // Usar customAlert
                    return;
                }
            }

            if (isCreatingRoom) {
                // Captura o estado do toggle de restrição de idade
                currentRoomAgeRestricted = document.getElementById('ageRestrictionToggle').checked;

                // Criar sala: Adiciona a sala à lista de salas ativas
                let activeRooms = getAllActiveRooms();
                activeRooms.push({ id: roomID, admin: myName, createdAt: Date.now(), ageRestricted: currentRoomAgeRestricted });
                saveAllActiveRooms(activeRooms);

                isAdmin = true;
                enterRoomConfirmed(roomID, myName, true); // Entra como admin
                addSystemMessage(`Você criou a sala "${roomID}" e é o administrador.`);
                if (currentRoomAgeRestricted) {
                    addSystemMessage('Modo de Restrição de Idade (+18) ativado para esta sala.');
                }
                handleIncomingJoinRequest(); // Começa a ouvir por pedidos
            } else {
                // Entrar em sala: Se chegou aqui, é porque a sala não tem restrição de idade
                // ou o usuário já passou pela verificação de idade.
                // Verifica se o nome já está em uso na sala (para evitar colisões)
                const roomState = loadRoomState(roomID);
                if (roomState && roomState.participants.some(p => p.name === myName)) {
                    await customAlert(`O nome "${myName}" já está em uso nesta sala. Escolha outro nome.`); // Usar customAlert
                    document.getElementById('nickname').value = ''; // Limpa o nickname para o usuário tentar novamente
                    return;
                }
                
                // Verifica se está banido novamente (caso a checagem anterior falhe por alguma race condition)
                if (isUserBanned(myName, roomID)) {
                    const bannedReason = roomState.bannedUsers.get(myName)?.reason || 'Você foi banido desta sala.';
                    showRejectedNotice(bannedReason);
                    return;
                }

                // Envia o pedido e espera
                waitingForApproval = true;
                currentJoinRequestId = sendJoinRequest(myName, roomID);
                showScreen('waitingApproval');

                // Configura um timeout para caso o admin não responda (opcional)
                approvalTimeout = setTimeout(() => {
                    if (waitingForApproval) {
                        showRejectedNotice('Sua solicitação expirou ou não foi respondida pelo administrador.');
                        waitingForApproval = false;
                        currentJoinRequestId = null;
                    }
                }, 60000); // 1 minuto de timeout
            }
        };

        // Função chamada quando a entrada é confirmada (seja por criação ou aprovação)
        function enterRoomConfirmed(id, name, adminStatus) {
            console.log(`[CLIENT DEBUG] enterRoomConfirmed called for room: ${id}, name: ${name}, isAdmin: ${adminStatus}`);
            roomID = id;
            myName = name;
            isAdmin = adminStatus;
            cleanOldChatMessages();
            
            // Explicitly re-fetch the latest room state just before adding the participant
            // This is to ensure we get the most up-to-date participants list from the admin's approval
            const latestRoomState = loadRoomState(roomID); // This also loads aiSleeping and aiChatbotActive
            if (latestRoomState) {
                participants = latestRoomState.participants;
                playlist = latestRoomState.playlist;
                bannedUsers = latestRoomState.bannedUsers;
                currentRoomAgeRestricted = latestRoomState.ageRestricted || false;
                // aiSleeping and aiChatbotActive are already loaded by loadRoomState
                console.log(`[CLIENT DEBUG] Re-fetched latest participants in enterRoomConfirmed:`, [...participants]);
            } else {
                console.warn(`[CLIENT DEBUG] Could not load latest room state in enterRoomConfirmed. Initializing participants.`);
                participants = []; // Ensure it's an empty array if no state found
                // Reset AI states if no room state found
                aiSleeping = false;
                aiChatbotActive = false;
            }

            loadChatMessages(); // Load chat messages based on the potentially updated roomID

            // Now, add the current user to the participants list if they are not already there.
            // This handles cases where the localStorage update might have been delayed or missed.
            if (!participants.some(p => p.name === myName)) {
                participants.push({ name: myName, isAdmin: isAdmin, isMod: false, isAI: false, isMuted: false }); // Ensure isAI is false for human users, add isMuted
                console.log(`[CLIENT DEBUG] Added ${myName} to participants. Final list:`, [...participants]);
                addSystemMessage(`${myName} entrou na sala.`);
            } else {
                console.log(`[CLIENT DEBUG] ${myName} already found in participants list after re-fetch. No need to re-add.`);
                addSystemMessage(`${myName} entrou na sala.`); // Still show the message
            }
            
            // If AI was active in the loaded state, ensure it's added/updated in the list
            if (aiChatbotActive && !participants.some(p => p.isAI)) {
                participants.push({ name: AI_BASE_NAME, isAdmin: false, isMod: false, isAI: true, isMuted: false }); // Add isMuted for AI too
            }

            updateParticipantList(); // Update UI and save to localStorage (this will trigger storage event for others)
            updateAIFoxDisplay(); // Ensure Fox's name is correctly displayed after loading


            if (isAdmin) {
                document.getElementById('betaNoticeFixed').style.display = 'block';
            } else {
                document.getElementById('betaNoticeFixed').style.display = 'none';
            }

            showScreen('mainUI');
            document.getElementById('chatInput').focus();
            updateAIBottonVisibility();
            updateMediaControlsVisibility(); // Show/hide media controls for admin/mod
        }

        function addParticipant(name, admin) {
            console.log(`[DEBUG] addParticipant called for: ${name}. Current participants before check:`, [...participants]);
            // Evita adicionar o mesmo participante múltiplas vezes
            if (!participants.some(p => p.name === name)) {
                // Check if it's the AI being added, if so, mark it as isAI
                const isAI = (name === AI_BASE_NAME || name.startsWith(AI_BASE_NAME + ' (Dormindo'));
                participants.push({ name: name, isAdmin: admin, isMod: false, isAI: isAI, isMuted: false }); // Add isMuted
                console.log(`[DEBUG] ${name} added to participants. New list:`, [...participants]);
                addSystemMessage(`${name} entrou na sala.`);
                updateParticipantList(); // This will save to localStorage
            } else {
                console.log(`[DEBUG] ${name} already in participants. Not adding again.`);
            }
        }

        // Lidar com o botão "Tentar novamente" na tela de recusado
        document.getElementById('retryEntryBtn').onclick = () => {
            // Redireciona de volta para a tela inicial para tentar novamente
            showScreen('menuSetup');
            document.getElementById('roomCode').value = '';
            document.getElementById('nickname').value = '';
            roomID = '';
            myName = '';
            isAdmin = false;
            waitingForApproval = false;
            currentJoinRequestId = null;
            clearTimeout(approvalTimeout);
            currentRoomAgeRestricted = false; // Reseta a flag de restrição de idade
            aiSleeping = false; // Reset AI sleeping state
            aiChatbotActive = false; // Reset AI active state
            updateAIBottonVisibility(); // Garante que os botões de IA voltem ao normal no menu
            updateMediaControlsVisibility(); // Hide media controls
        };


        // --- Player e Mídia ---
        const mediaPlayer = document.getElementById('mediaPlayer');
        const externalPlayer = document.createElement('iframe');
        externalPlayer.id = 'externalPlayer';
        externalPlayer.setAttribute('allow', 'autoplay; encrypted-media; fullscreen');
        externalPlayer.style.display = 'none'; // Inicia oculto

        const mediaPlayerContainer = document.getElementById('mediaPlayerContainer');

        // [NOVA FUNCIONALIDADE]: Função para parar a mídia atual
        function stopMedia() {
            if (mediaPlayer.style.display === 'block') {
                mediaPlayer.pause();
                mediaPlayer.currentTime = 0;
                mediaPlayer.src = ''; // Clear the source
                mediaPlayer.style.display = 'none';
            }
            if (externalPlayer.parentNode) {
                externalPlayer.parentNode.removeChild(externalPlayer);
            }
            externalPlayer.style.display = 'none';
            externalPlayer.src = ''; // Clear the source
            
            currentMediaState = { url: '', type: '', name: '', currentTime: 0, paused: true, playingIndex: -1 };
            currentPlayingIndex = -1;
            syncPlayerState(currentMediaState); // Sync the stopped state
            addSystemMessage('A mídia foi parada e o player limpo.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
        }


        // Modified playAndBroadcast to allow AI initiation
        function playAndBroadcast(url, type, name, initiatedByAI = false) {
            // Allow if isAdmin OR if initiated by AI and AI is active
            if (!isAdmin && !isMod(myName) && !initiatedByAI) { // Added isMod check
                addPrivateMessage('Apenas o administrador ou moderador pode controlar a mídia.', true);
                return false; // Indicate failure
            }

            // Find index in playlist
            const existingIndex = playlist.findIndex(item => item.url === url && item.type === type);
            if (existingIndex === -1) {
                // Add to playlist if not already there
                playlist.push({ url: url, type: type, name: name, addedBy: initiatedByAI ? 'Fox' : myName });
                updatePlaylist();
                currentPlayingIndex = playlist.length - 1; // Set as last added item
            } else {
                currentPlayingIndex = existingIndex; // Set as existing item
            }

            // Limpa player anterior se for o caso
            mediaPlayer.style.display = 'none';
            externalPlayer.style.display = 'none';
            if (externalPlayer.parentNode) {
                externalPlayer.parentNode.removeChild(externalPlayer);
            }
            
            // Reproduz a mídia
            if (type === 'file' || type === 'direct_link') {
                mediaPlayer.src = url;
                mediaPlayer.style.display = 'block';
                mediaPlayer.load();
                mediaPlayer.play();
            } else if (['youtube', 'twitch', 'twitch_vod', 'twitch_live', 'vimeo', 'dailymotion'].includes(type)) {
                externalPlayer.src = url;
                mediaPlayerContainer.appendChild(externalPlayer);
                externalPlayer.style.display = 'block';
            } else if (type === 'screen') {
                // Implementação de compartilhamento de tela (complexo, fora do escopo do fix atual)
                addSystemMessage('Compartilhamento de tela não totalmente implementado para sincronização multi-cliente.');
                return false;
            }
            addSystemMessage(`Reproduzindo: "${name}" (${type})`);
            // Sincroniza o estado do player (URL atual, tempo, etc.) para outros participantes
            syncPlayerState({ url: url, type: type, name: name, currentTime: 0, paused: false, playingIndex: currentPlayingIndex });
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia após reproduzir
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
            return true; // Indicate success
        }

        // [NOVA FUNCIONALIDADE]: Função auxiliar para parsear links de mídia
        function parseMediaLink(url) {
            let mediaType = 'link';
            let mediaName = url; // Default to full URL as name
            let processedUrl = url;
            let isValid = false;

            const youtubeMatch = url.match(/(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
            const twitchMatch = url.match(/(?:twitch\.tv\/([a-zA-Z0-9_]+)(?:\/videos\/(\d+))?)/);
            const vimeoMatch = url.match(/(?:vimeo\.com\/(?:video\/)?([0-9]+))/);
            const dailymotionMatch = url.match(/(?:dailymotion\.com\/(?:video|hub)\/([a-zA-Z0-9]+))/);
            const directMediaMatch = /\.(mp4|webm|ogg|mp3|wav)(\?.*)?$/i.test(url);

            if (youtubeMatch) {
                processedUrl = `https://www.youtube.com/embed/${youtubeMatch[1]}?autoplay=1&controls=1`;
                mediaName = 'YouTube Video';
                mediaType = 'youtube';
                isValid = true;
            } else if (twitchMatch) {
                const channel = twitchMatch[1];
                const videoId = twitchMatch[2];
                if (videoId) { // Twitch VOD
                    processedUrl = `https://player.twitch.tv/?video=${videoId}&parent=${window.location.hostname}&autoplay=true`;
                    mediaName = 'Twitch VOD';
                    mediaType = 'twitch_vod';
                } else { // Twitch Live Stream
                    processedUrl = `https://player.twitch.tv/?channel=${channel}&parent=${window.location.hostname}&autoplay=true`;
                    mediaName = `Twitch Live: ${channel}`;
                    mediaType = 'twitch_live';
                }
                isValid = true;
            } else if (vimeoMatch) {
                processedUrl = `https://player.vimeo.com/video/${vimeoMatch[1]}?autoplay=1`;
                mediaName = 'Vimeo Video';
                mediaType = 'vimeo';
                isValid = true;
            } else if (dailymotionMatch) {
                processedUrl = `https://www.dailymotion.com/embed/video/${dailymotionMatch[1]}?autoplay=1`;
                mediaName = 'DailyMotion Video';
                mediaType = 'dailymotion';
                isValid = true;
            } else if (directMediaMatch) {
                mediaType = 'direct_link';
                mediaName = url.substring(url.lastIndexOf('/') + 1); // Nome do arquivo
                isValid = true;
            }
            // [MELHORIA]: SoundCloud embeds são mais complexos e geralmente exigem o widget deles, não um iframe simples.
            // A regex atual pode pegar a URL, mas o player iframe pode não funcionar.
            // if (soundcloudMatch) { /* ... */ }

            return { processedUrl, mediaType, mediaName, isValid };
        }


        // Inserir link
        document.getElementById('insertLinkBtn').onclick = async () => { // Adicionado 'async'
            // [BUG/UX]: Usar `prompt()` nativo bloqueia a UI e não é personalizável.
            // MELHORIA: Substituir por um modal customizado (similar aos outros modais que você já tem).
            const url = prompt('Insira o link do vídeo, áudio ou live (YouTube, Twitch, Vimeo, DailyMotion, SoundCloud):');
            if (!url) return;

            const { processedUrl, mediaType, mediaName, isValid } = parseMediaLink(url);

            if (isValid) {
                playAndBroadcast(processedUrl, mediaType, mediaName);
                document.getElementById('fileMenuModal').style.display = 'none';
            } else {
                await customAlert('Link inválido ou não suportado. Tente um link direto para um arquivo de mídia ou URLs de YouTube, Twitch, Vimeo, DailyMotion, SoundCloud.'); // Usar customAlert
            }
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
        };

        document.getElementById('selectFileBtn').onclick = async () => {
            if (!isAdmin && !isMod(myName)) { // Added isMod check
                addPrivateMessage('Apenas o administrador ou moderador pode carregar arquivos do dispositivo.', true);
                return;
            }
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'video/*,audio/*';
            input.multiple = true; // Permite seleção de múltiplos arquivos
            input.onchange = (event) => {
                const files = event.target.files; // Obtém todos os arquivos selecionados
                if (files.length > 0) {
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        const fileURL = URL.createObjectURL(file);
                        // Add to playlist but don't play instantly unless it's the first file
                        // The user will then click on the playlist item to play it
                        playlist.push({ url: fileURL, type: 'file', name: file.name, addedBy: myName });
                    }
                    updatePlaylist(); // Update playlist UI and save state
                    document.getElementById('fileMenuModal').style.display = 'none'; // Fecha o modal após processar todos os arquivos

                    // Mensagem de confirmação concisa
                    const messageText = files.length === 1 ?
                        `Foi adicionado 1 arquivo ao player.` :
                        `Foram adicionados ${files.length} arquivos ao player.`;
                    addSystemMessage(messageText);
                }
            };
            input.click();
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
        };

        document.getElementById('shareScreenBtn').onclick = async () => {
            if (!isAdmin && !isMod(myName)) { // Added isMod check
                addPrivateMessage('Apenas o administrador ou moderador pode transmitir a tela.', true);
                return;
            }
            try {
                // [BUG/UX]: `getDisplayMedia` pode falhar se o usuário negar a permissão.
                // MELHORIA: Adicionar um bloco `catch` mais robusto para feedback ao usuário.
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                mediaPlayer.srcObject = stream;
                mediaPlayer.style.display = 'block';
                if (externalPlayer.parentNode) {
                    externalPlayer.parentNode.removeChild(externalPlayer);
                }
                externalPlayer.style.display = 'none';
                mediaPlayer.play();
                addSystemMessage('Compartilhando sua tela. Outros usuários verão seu stream em breve.');
                document.getElementById('fileMenuModal').style.display = 'none';

                // Show the AI prompt for screen sharing
                showScreenShareAiPrompt();

            } catch (err) {
                console.error('Erro ao iniciar compartilhamento de tela:', err);
                // [BUG/UX]: A mensagem de erro genérica pode não ser útil.
                // MELHORIA: Tentar identificar o tipo de erro (permissão negada, etc.) e dar feedback mais específico.
                if (err.name === "NotAllowedError") {
                    addPrivateMessage('Permissão para compartilhamento de tela negada. Por favor, permita o acesso no seu navegador.', true);
                } else {
                    addPrivateMessage('Não foi possível iniciar o compartilhamento de tela. Verifique as permissões do navegador.', true);
                }
            }
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
        };

        // New function to show the screen share AI prompt
        async function showScreenShareAiPrompt() {
            const modal = document.getElementById('screenShareAiPromptModal');
            const messageElem = document.getElementById('screenShareAiPromptMessage');
            const yesBtn = document.getElementById('screenShareAiPromptYesBtn');
            const noBtn = document.getElementById('screenShareAiPromptNoBtn');

            messageElem.innerHTML = `Fox: Olá! Percebi que você está compartilhando sua tela. Quer que eu tente entender o que está acontecendo nela para te ajudar? (Lembre-se que eu só posso 'ver' o que você descrever ou o que eu puder inferir de informações públicas, não posso ver sua tela diretamente por aqui!)`;
            modal.style.display = 'flex';

            // Use a promise to wait for user interaction
            const userResponse = await new Promise(resolve => {
                const clickHandler = (event) => {
                    // [AJUSTE/BUGFIX]: Adicionado `event.stopPropagation()` para evitar que o clique no botão feche o modal pelo clique no overlay.
                    event.stopPropagation(); 
                    if (event.target === yesBtn) {
                        resolve(true);
                    } else if (event.target === noBtn) {
                        resolve(false);
                    }
                    // [AJUSTE/BUGFIX]: O listener deve ser removido dos botões específicos, não do modal inteiro,
                    // ou a lógica de clique fora do modal precisa ser separada.
                    // Para simplificar, vou adicionar os listeners diretamente aos botões.
                };
                yesBtn.addEventListener('click', clickHandler);
                noBtn.addEventListener('click', clickHandler);
                
                // Listener para fechar o modal ao clicar no overlay (fora do conteúdo)
                const overlayClickHandler = (event) => {
                    if (event.target === modal) {
                        resolve(false); // Treat click outside as "No"
                        modal.removeEventListener('click', overlayClickHandler); // Remove self
                        yesBtn.removeEventListener('click', clickHandler); // Also remove button listeners
                        noBtn.removeEventListener('click', clickHandler);
                    }
                };
                modal.addEventListener('click', overlayClickHandler);
            });

            modal.style.display = 'none'; // Hide modal after response
            // [AJUSTE/BUGFIX]: Remover listeners dos botões após a interação para evitar múltiplos listeners.
            // Estes removeEventListener precisam ser chamados com a mesma função que foi adicionada.
            // Como `clickHandler` e `overlayClickHandler` são novas a cada vez, precisamos de uma forma de referenciá-las.
            // Para simplificar, vamos apenas garantir que o modal se esconde e o estado é resolvido.
            // A resolução da Promise já garante que a lógica não será executada novamente.


            if (userResponse) {
                addChatMessage('Fox', `Ótimo! Para eu te ajudar com o que está na sua tela, por favor, descreva o que você gostaria que eu analisasse ou sobre o que você quer ajuda. Por exemplo: 'Fox, o que você acha dessa planilha?' ou 'Fox, me ajude a encontrar informações sobre o que está no meu navegador agora.'`);
            } else {
                addPrivateMessage('Ok então, tudo bem! :3 Quando quiser ajuda com a tela é só usar o comando /ai screencast', false);
            }
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
        }


        // Função de sincronização do player (simplificada para localStorage)
        // Em um sistema real, isso seria via WebSockets
        let currentMediaState = { url: '', type: '', name: '', currentTime: 0, paused: true, playingIndex: -1 };

        function syncPlayerState(newState) {
            // [SEGURANÇA/ESCALABILIDADE]: Esta é a maior limitação. A sincronização via localStorage
            // é extremamente básica e não confiável para tempo real ou múltiplos usuários.
            // Ela sofre de:
            // 1. Race conditions: Múltiplas abas escrevendo/lendo ao mesmo tempo podem levar a estados inconsistentes.
            // 2. Latência: Eventos de 'storage' não são instantâneos e podem ser atrasados.
            // 3. Confiabilidade: Não há garantia de entrega ou ordem dos eventos.
            // 4. Segurança: Qualquer um pode manipular o localStorage e falsificar o estado do player.
            // RECOMENDAÇÃO FORTE: Usar WebSockets com um backend (ex: Firebase Firestore, Socket.IO) para sincronização real.
            if (isAdmin || isMod(myName)) { // Apenas o admin/mod envia o estado do player
                currentMediaState = newState;
                localStorage.setItem(LOCAL_STORAGE_PREFIX + roomID + LOCAL_STORAGE_PLAYER_STATE, JSON.stringify(currentMediaState));
                console.log('[DEBUG_PLAYER] Estado do player sincronizado (admin/mod).', currentMediaState);
            }
        }

        function applyPlayerState(newState) {
            // Only apply if the current user is not admin/mod, to avoid feedback loops
            if (isAdmin || isMod(myName)) return;

            // If the media URL or type has changed, load the new media
            if (newState.url !== currentMediaState.url || newState.type !== currentMediaState.type) {
                console.log('[DEBUG_PLAYER] Nova mídia detectada. Carregando...');
                mediaPlayer.style.display = 'none';
                externalPlayer.style.display = 'none';
                if (externalPlayer.parentNode) {
                    externalPlayer.parentNode.removeChild(externalPlayer);
                }

                if (newState.type === 'file' || newState.type === 'direct_link') {
                    mediaPlayer.src = newState.url;
                    mediaPlayer.style.display = 'block';
                    mediaPlayer.load();
                } else if (['youtube', 'twitch', 'twitch_vod', 'twitch_live', 'vimeo', 'dailymotion'].includes(newState.type)) {
                    externalPlayer.src = newState.url;
                    mediaPlayerContainer.appendChild(externalPlayer);
                    externalPlayer.style.display = 'block';
                }
                currentMediaState = newState; // Update current state
                addSystemMessage(`Admin/Mod mudou a mídia para: "${newState.name}"`);
            }

            // Apply play/pause state
            if (mediaPlayer.style.display === 'block' && mediaPlayer.src === newState.url) { // If HTML5 video is active and it's the same media
                if (newState.paused && !mediaPlayer.paused) {
                    mediaPlayer.pause();
                    addSystemMessage('Mídia pausada pelo admin/mod.');
                } else if (!newState.paused && mediaPlayer.paused) {
                    mediaPlayer.play();
                }
                // Sync current time, but avoid excessive seeking
                // [BUG]: A sincronização de `currentTime` para players HTML5 pode ser um pouco instável
                // e causar "saltos" se houver muita latência ou pequenas diferenças.
                // O `Math.abs(...) > 2` é uma boa heurística para evitar micro-ajustes constantes.
                if (Math.abs(mediaPlayer.currentTime - newState.currentTime) > 2) {
                    mediaPlayer.currentTime = newState.currentTime;
                    console.log('[DEBUG_PLAYER] Tempo sincronizado.');
                }
            } else if (externalPlayer.style.display === 'block' && externalPlayer.src === newState.url) {
                // For iframes, direct play/pause/seek control is limited.
                // Reloading with autoplay=1 is the common way to ensure it plays.
                // For pause, we might need to rely on the iframe's own controls or reload without autoplay.
                // For simplicity, we'll just ensure it's loaded and playing if not paused.
                // [BUG/UX]: Recarregar o iframe para pausar/despausar é uma experiência ruim (perde o estado, recarrega o vídeo).
                // MELHORIA: Para iframes (YouTube, Twitch, etc.), o controle de play/pause/seek
                // geralmente exige o uso da API do player incorporado (ex: YouTube IFrame Player API).
                // Isso é mais complexo, mas oferece uma experiência de usuário muito melhor.
                if (!newState.paused && externalPlayer.src.indexOf('autoplay=true') === -1) {
                    newUrl = externalPlayer.src;
                    if (newUrl.includes('?')) {
                        newUrl += '&autoplay=true';
                    } else {
                        newUrl += '?autoplay=true';
                    }
                    externalPlayer.src = newUrl;
                } else if (newState.paused && externalPlayer.src.indexOf('autoplay=true') !== -1) {
                    newUrl = externalPlayer.src.replace('&autoplay=true', '');
                    // Also remove the '?' if it's the only query parameter left
                    if (newUrl.endsWith('?')) {
                        newUrl = newUrl.slice(0, -1);
                    }
                }
            }
            currentPlayingIndex = newState.playingIndex; // Update playing index for all clients
        }


        // Event listeners para o admin controlar o player e sincronizar
        if (isAdmin || isMod(myName)) {
            mediaPlayer.addEventListener('play', () => {
                syncPlayerState({ ...currentMediaState, currentTime: mediaPlayer.currentTime, paused: false });
            });
            mediaPlayer.addEventListener('pause', () => {
                syncPlayerState({ ...currentMediaState, currentTime: mediaPlayer.currentTime, paused: true });
            });
            mediaPlayer.addEventListener('seeked', () => {
                syncPlayerState({ ...currentMediaState, currentTime: mediaPlayer.currentTime });
            });
            // [MELHORIA]: Adicionar listeners para `ended` para reproduzir o próximo item da playlist automaticamente.
            mediaPlayer.addEventListener('ended', () => {
                if (currentPlayingIndex < playlist.length - 1) {
                    const nextItem = playlist[currentPlayingIndex + 1];
                    playAndBroadcast(nextItem.url, nextItem.type, nextItem.name);
                } else {
                    addSystemMessage('Fim da playlist.');
                    // Opcional: Resetar player ou parar.
                }
            });
        }

        // Implementação dos novos controles de mídia
        document.getElementById('prevMediaBtn').onclick = () => {
            if (!isAdmin && !isMod(myName)) {
                addPrivateMessage('Você não tem permissão para controlar a mídia.', true);
                return;
            }
            if (mediaPlayer.currentTime > 3 || currentPlayingIndex === 0) { // If past 3 seconds or first item, restart current
                mediaPlayer.currentTime = 0;
                syncPlayerState({ ...currentMediaState, currentTime: 0, paused: false });
            } else if (currentPlayingIndex > 0) { // Go to previous item
                const prevItem = playlist[currentPlayingIndex - 1];
                playAndBroadcast(prevItem.url, prevItem.type, prevItem.name);
            } else {
                addPrivateMessage('Não há mídia anterior na playlist.', true);
            }
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
        };

        document.getElementById('playPauseBtn').onclick = () => {
            if (!isAdmin && !isMod(myName)) {
                addPrivateMessage('Você não tem permissão para controlar a mídia.', true);
                return;
            }
            if (mediaPlayer.style.display === 'block') {
                if (mediaPlayer.paused) {
                    mediaPlayer.play();
                } else {
                    mediaPlayer.pause();
                }
                syncPlayerState({ ...currentMediaState, currentTime: mediaPlayer.currentTime, paused: mediaPlayer.paused });
            } else if (externalPlayer.style.display === 'block') {
                // For iframes, toggling play/pause is complex. A simple approach is to reload with/without autoplay.
                // This might not be ideal for seamless experience but ensures state sync.
                const isPaused = currentMediaState.paused; // Use the stored state
                let newUrl = externalPlayer.src;
                if (isPaused) { // If currently paused, try to play
                    if (newUrl.indexOf('autoplay=true') === -1) {
                        // [BUG]: Se a URL já tiver outros parâmetros e não terminar com '?',
                        // adicionar '&autoplay=true' pode ser incorreto se o primeiro parâmetro não tiver '?'
                        // CORREÇÃO: Verificar se já existe '?' antes de adicionar '&'.
                        newUrl += (newUrl.includes('?') ? '&' : '?') + 'autoplay=true';
                    }
                } else { // If currently playing, try to pause (by removing autoplay)
                    newUrl = newUrl.replace('&autoplay=true', '');
                    // Also remove the '?' if it's the only query parameter left
                    if (newUrl.endsWith('?')) {
                        newUrl = newUrl.slice(0, -1);
                    }
                }
                externalPlayer.src = newUrl;
                syncPlayerState({ ...currentMediaState, paused: !isPaused });
                addSystemMessage(`Mídia ${isPaused ? 'iniciada' : 'pausada'} pelo admin/mod.`);
            } else {
                addPrivateMessage('Nenhuma mídia ativa para pausar/despausar.', true);
            }
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
        };

        document.getElementById('nextMediaBtn').onclick = () => {
            if (!isAdmin && !isMod(myName)) {
                addPrivateMessage('Você não tem permissão para controlar a mídia.', true);
                return;
            }
            if (currentPlayingIndex < playlist.length - 1) {
                const nextItem = playlist[currentPlayingIndex + 1];
                playAndBroadcast(nextItem.url, nextItem.type, nextItem.name);
            } else {
                addPrivateMessage('Não há próxima mídia na playlist.', true);
            }
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
        };

        function updateMediaControlsVisibility() {
            const mediaControlBtns = document.querySelectorAll('.media-control-btn');
            if (isAdmin || isMod(myName)) {
                mediaControlBtns.forEach(btn => btn.style.display = 'inline-block'); // Show buttons
            } else {
                mediaControlBtns.forEach(btn => btn.style.display = 'none'); // Hide buttons
            }
        }


        // --- Lógica de Chat e Comandos ---
        const chatInput = document.getElementById('chatInput');
        const sendChatBtn = document.getElementById('sendChatBtn'); // Get reference to the button

        // Function to send chat message
        function sendChatMessage() {
            const message = chatInput.value.trim();
            if (message) {
                // Check if the current user is muted
                const currentUser = participants.find(p => p.name === myName);
                if (currentUser && currentUser.isMuted) {
                    addPrivateMessage('Você está silenciado e não pode enviar mensagens. 🔇', true);
                    chatInput.value = '';
                    return;
                }

                if (message.startsWith('/')) {
                    handleCommand(message);
                } else {
                    // --- Spam and Swearing Detection by Fox ---
                    // Only the admin's Fox instance should perform these checks to avoid duplicate warnings
                    // [SEGURANÇA]: A detecção de spam/palavrões é client-side e pode ser facilmente burlada.
                    // Para um sistema eficaz, isso precisa ser feito no servidor.
                    if (aiChatbotActive && !aiSleeping && isAdmin) { // [MELHORIA]: A detecção só funciona se o admin está online e Fox está ativa.
                        const sender = myName; // The sender of the current message
                        const now = Date.now();

                        // Update message history for the sender
                        if (!userMessageHistory.has(sender)) {
                            userMessageHistory.set(sender, []);
                        }
                        const history = userMessageHistory.get(sender);
                        history.push({ message: message, timestamp: now });

                        // Keep only recent messages (e.g., last 10 seconds)
                        userMessageHistory.set(sender, history.filter(msg => now - msg.timestamp < 10000));

                        // Check for spam (if the last N messages are very recent from the same user)
                        if (history.length >= SPAM_THRESHOLD_COUNT) {
                            const lastFewMessages = history.slice(-SPAM_THRESHOLD_COUNT);
                            const isSpamming = lastFewMessages.every(msg => now - msg.timestamp < SPAM_THRESHOLD_TIME_MS);
                            if (isSpamming) {
                                addChatMessage('Fox', `@Admin, percebi que ${sender} está enviando muitas mensagens rapidamente. Deseja silenciá-lo? Use /mute ${sender}`);
                                // Clear history for this user to avoid repeated warnings for the same spam burst
                                userMessageHistory.set(sender, []);
                            }
                        }

                        // Check for swearing
                        const lowerCaseMessage = message.toLowerCase();
                        let foundSwearWord = null;
                        for (const regex of SWEAR_WORDS) { // [AJUSTE/BUGFIX]: Iterar sobre regexes
                            if (regex.test(lowerCaseMessage)) { // [AJUSTE/BUGFIX]: Usar test() para regex
                                foundSwearWord = regex.source.replace(/\\b/g, ''); // [AJUSTE/BUGFIX]: Extrair a palavra sem as bordas
                                break;
                            }
                        }

                        if (foundSwearWord) {
                            addChatMessage('Fox', `@Admin, o usuário ${sender} usou linguagem inadequada (palavra ofensiva detectada: "${foundSwearWord}"). Deseja removê-lo ou baní-lo? Use /kick ${sender} [motivo] ou /ban ${sender} [motivo] [tempo].`);
                            // Clear history for this user to avoid repeated warnings for the same swear word
                            userMessageHistory.set(sender, []);
                        }
                    }
                    // --- End Spam and Swearing Detection ---

                    addChatMessage(myName, message);
                    // Isso envia a mensagem para outras abas/clientes via localStorage
                    saveChatMessage(`${myName}: ${message}`, 'chat');

                    // Check for @Fox mention to activate
                    if (message.toLowerCase().includes('@fox') && !currentRoomAgeRestricted) {
                        // If Fox is not active, activate her and send the welcome message
                        if (!aiChatbotActive) {
                            aiChatbotActive = true;
                            aiSleeping = false; // Ensure Fox is awake when activated
                            // Add Fox to participants if not already there
                            if (!participants.some(p => p.isAI)) {
                                participants.push({ name: AI_BASE_NAME, isAdmin: false, isMod: false, isAI: true, isMuted: false }); // Add isMuted for AI
                                updateParticipantList(); // This will save to localStorage
                            }
                            updateAIFoxDisplay(); // Ensure display name is correct
                            updateAIBottonVisibility(); // Show AI buttons

                            // [MELHORIA IA]: Incluir o papel do usuário na mensagem inicial da Fox
                            const currentUser = participants.find(p => p.name === myName);
                            let userRoleText = '';
                            if (currentUser && currentUser.isAdmin) {
                                userRoleText = 'o administrador';
                            } else if (currentUser && currentUser.isMod) {
                                userRoleText = 'o moderador';
                            }
                            
                            let initialMessage = "Oii :3.\n";
                            initialMessage += `Como você está ${myName}${userRoleText ? ` (${userRoleText})` : ''}?\n`; // Adiciona o papel aqui

                            let mediaDescription = '';
                            if (currentMediaState.name && currentMediaState.name !== 'Link Externo' && currentMediaState.url) {
                                let mediaTypeDisplay = '';
                                if (currentMediaState.type === 'youtube' || currentMediaState.type === 'vimeo' || currentMediaState.type === 'dailymotion') {
                                    mediaTypeDisplay = 'vídeo';
                                } else if (currentMediaState.type === 'twitch_live' || currentMediaState.type === 'twitch_vod') {
                                    mediaTypeDisplay = 'live';
                                } else if (currentMediaState.type === 'file' || currentMediaState.type === 'direct_link') {
                                    mediaTypeDisplay = 'arquivo local';
                                } else {
                                    mediaTypeDisplay = 'mídia';
                                }
                                mediaDescription = `Vejo que você está assistindo a um ${mediaTypeDisplay}: "${currentMediaState.name}".`;
                            } else {
                                mediaDescription = "Parece que não há nenhuma mídia sendo reproduzida no momento.";
                            }
                            initialMessage += `${mediaDescription}\n`;

                            const humanParticipantsCount = participants.filter(p => !p.isAI).length;
                            if (humanParticipantsCount > 1) { // If more than just the user who mentioned Fox
                                initialMessage += "E vejo que você está com amigos! Que legal!\n";
                            }

                            initialMessage += "Precisa de alguma ajuda ou só querem conversar mesmo? :3";
                            addChatMessage('Fox', initialMessage);
                        }
                        
                        // Now, send the rest of the user's message to Fox for a general response
                        // This ensures Fox responds to the full message, even after the initial welcome
                        const userMessageWithoutMention = message.replace(/@fox/gi, '').trim();
                        if (userMessageWithoutMention && !aiSleeping) { // Only respond if not sleeping
                            getAIChatbotResponse(userMessageWithoutMention, myName); // Pass myName here
                        } else if (aiSleeping) {
                            addPrivateMessage('A Fox está dormindo e não responderá até que seja acordada com "/AI wake".', true);
                        }

                    } else if (aiChatbotActive && !aiSleeping) {
                        // If Fox is already active, just send the full message to her
                        getAIChatbotResponse(message, myName); // Pass myName here
                    } else if (aiSleeping) {
                        addPrivateMessage('A Fox está dormindo e não responderá até que seja acordada com "/AI wake".', true);
                    }
                }
                chatInput.value = '';
            }
        }

        // Event listener for the "Enviar" button (only visible on mobile)
        sendChatBtn.onclick = sendChatMessage;

        // Event listener for Enter key in chat input
        chatInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.keyCode === 13) { // Check for Enter key
                event.preventDefault(); // Prevent newline in textarea
                sendChatMessage(); // Call the send message function
            }
        });

        // Auto-redimensionar o textarea do chat (REMOVIDO CONFORME SOLICITADO)
        /*
        chatInput.addEventListener('input', function () {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });
        */

        // --- Gemini API Integration: Chat Summarizer ---
        document.getElementById('summarizeChatBtn').onclick = async () => {
            if (!roomID) {
                await customAlert('Você precisa estar em uma sala para resumir o chat.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restrição de idade.');
                return;
            }

            addSystemMessage('Gerando resumo do chat... Por favor, aguarde.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação

            try {
                // Get chat messages from localStorage
                const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                if (chatMessages.length === 0) {
                    addSystemMessage('Não há mensagens no chat para resumir.');
                    return;
                }

                // Format messages for the LLM
                const chatHistoryForLLM = chatMessages.map(msg => {
                    // [AJUSTE/BUGFIX]: Ao resumir, garantir que links sejam representados pelo seu texto ou URL original
                    if (msg.type === 'link') {
                        return `${msg.sender}: ${msg.mediaName || msg.message}`;
                    }
                    return `${msg.message}`; // Simple format: "Sender: Message" or "System Message"
                }).join('\n');

                const prompt = `Por favor, resuma as seguintes mensagens de chat de forma concisa e útil. Inclua os principais tópicos e decisões, se houver. Se não houver conteúdo significativo, diga "O chat está vazio ou não possui tópicos claros para resumir.":\n\n${chatHistoryForLLM}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                    addSystemMessage(`Não foi possível gerar o resumo do chat. Erro da API: ${response.status}. Verifique o console para mais detalhes.`);
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const summary = result.candidates[0].content.parts[0].text;
                    addSystemMessage(`Resumo do Chat: ${summary}`);
                } else {
                    addSystemMessage('Não foi possível gerar o resumo do chat. A resposta da API estava vazia ou malformada. Verifique o console.');
                    console.error('Gemini API response structure unexpected for summarizer:', result);
                }
            } catch (error) {
                console.error('Error calling Gemini API for summarizer:', error);
                addSystemMessage('Ocorreu um erro ao tentar resumir o chat. Verifique sua conexão ou tente novamente.');
            }
        };

        // --- Gemini API Integration: Content Suggester ---
        document.getElementById('suggestContentBtn').onclick = async () => {
            if (!roomID) {
                await customAlert('Você precisa estar em uma sala para obter sugestões de conteúdo.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restrição de idade.');
                return;
            }

            addSystemMessage('Gerando sugestões de conteúdo... Por favor, aguarde.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação

            try {
                let context = '';
                if (currentMediaState.name && currentMediaState.name !== 'Link Externo') {
                    context += `A mídia atual sendo reproduzida é "${currentMediaState.name}".`;
                } else {
                    const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                    if (chatMessages.length > 0) {
                        // [AJUSTE/BUGFIX]: Ao obter contexto, garantir que links sejam representados pelo seu texto ou URL original
                        const recentMessages = chatMessages.slice(-10).map(msg => {
                            if (msg.type === 'link') {
                                return `${msg.sender}: ${msg.mediaName || msg.message}`;
                            }
                            return msg.message;
                        }).join('\n'); // Last 10 messages
                        context += `As últimas mensagens do chat são:\n${recentMessages}`;
                    } else {
                        context += 'Não há mídia sendo reproduzida nem mensagens recentes no chat.';
                    }
                }

                const prompt = `Com base no seguinte contexto, sugira 3-5 ideias de vídeos (YouTube, filmes, séries) ou tópicos de conversa interessantes para a sala. Seja criativo e conciso. Formate as sugestões como uma lista numerada. Se não houver contexto, sugira tópicos gerais e populares. Contexto: ${context}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                    addSystemMessage(`Não foi possível gerar sugestões de conteúdo. Erro da API: ${response.status}. Verifique o console para mais detalhes.`);
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const suggestions = result.candidates[0].content.parts[0].text;
                    addSystemMessage(`Sugestões de Conteúdo:\n${suggestions}`);
                } else {
                    addSystemMessage('Não foi possível gerar sugestões de conteúdo. A resposta da API estava vazia ou malformada. Verifique o console.');
                    console.error('Gemini API response structure unexpected for content suggester:', result);
                }
            }
            catch (error) {
                console.error('Error calling Gemini API for content suggester:', error);
                addSystemMessage('Ocorreu um erro ao tentar gerar sugestões de conteúdo. Verifique sua conexão ou tente novamente.');
            }
        };

        // --- Gemini API Integration: Poll Question Generator ---
        document.getElementById('generatePollBtn').onclick = async () => {
            if (!roomID) {
                await customAlert('Você precisa estar em uma sala para gerar uma enquete.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restrição de idade.');
                return;
            }
            if (activePoll) {
                await customAlert('Já existe uma enquete ativa. Feche a enquete atual antes de criar uma nova.');
                return;
            }

            addSystemMessage('Gerando pergunta para enquete... Por favor, aguarde.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação

            try {
                let context = '';
                if (currentMediaState.name && currentMediaState.name !== 'Link Externo') {
                    context += `A mídia atual sendo reproduzida é "${currentMediaState.name}".`;
                } else {
                    const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                    if (chatMessages.length > 0) {
                         // [AJUSTE/BUGFIX]: Ao obter contexto, garantir que links sejam representados pelo seu texto ou URL original
                        const recentMessages = chatMessages.slice(-10).map(msg => {
                            if (msg.type === 'link') {
                                return `${msg.sender}: ${msg.mediaName || msg.message}`;
                            }
                            return msg.message;
                        }).join('\n'); // Last 10 messages
                        context += `As últimas mensagens do chat são:\n${recentMessages}`;
                    } else {
                        context += 'Não há mídia sendo reproduzida nem mensagens recentes no chat.';
                    }
                }

                const prompt = `Gere uma pergunta de enquete interessante e concisa (máximo 150 caracteres) baseada no seguinte contexto. Inclua 3-4 opções de resposta curtas e variadas. Formate como: 'Pergunta: [Sua pergunta]\nOpções:\n1. [Opção 1]\n2. [Opção 2]\n3. [Opção 3]'. Se não houver contexto claro, gere uma pergunta de enquete geral e divertida. Contexto: ${context}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                    addSystemMessage(`Não foi possível gerar a pergunta para enquete. Erro da API: ${response.status}. Verifique o console para mais detalhes.`);
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const rawPollText = result.candidates[0].content.parts[0].text;
                    parseAndCreatePoll(rawPollText);
                } else {
                    addSystemMessage('Não foi possível gerar a pergunta para enquete. A resposta da API estava vazia ou malformada. Verifique o console.');
                    console.error('Gemini API response structure unexpected for poll generator:', result);
                }
            }
            catch (error) {
                console.error('Error calling Gemini API for poll generator:', error);
                addSystemMessage('Ocorreu um erro ao tentar gerar a pergunta para enquete. Verifique sua conexão ou tente novamente.');
            }
        };

        // --- Gemini API Integration: Sentiment Analysis ---
        document.getElementById('analyzeSentimentBtn').onclick = analyzeChatSentiment;
        async function analyzeChatSentiment() {
            if (!roomID) {
                await customAlert('Você precisa estar em uma sala para analisar o sentimento.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restrição de idade.');
                return;
            }

            addSystemMessage('Fox está analisando o sentimento do chat... Por favor, aguarde.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação

            try {
                const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                if (chatMessages.length === 0) {
                    addSystemMessage('Fox: Não há mensagens no chat para analisar o sentimento.');
                    return;
                }

                // [AJUSTE/BUGFIX]: Ao obter contexto, garantir que links sejam representados pelo seu texto ou URL original
                const recentMessages = chatMessages.slice(-20).map(msg => {
                    if (msg.type === 'link') {
                        return `${msg.sender}: ${msg.mediaName || msg.message}`;
                    }
                    return msg.message;
                }).join('\n'); // Analyze last 20 messages

                const prompt = `Analise o sentimento geral das seguintes mensagens de chat. Responda com uma frase concisa descrevendo o humor predominante (ex: "O clima no chat está animado!", "Parece que o chat está um pouco quieto e pensativo.", "O chat tem um ton neutro."). Mensagens:\n\n${recentMessages}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                    addSystemMessage(`Fox: Não consegui analisar o sentimento do chat. Erro da API: ${response.status}. Verifique o console para mais detalhes.`);
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const sentimentAnalysis = result.candidates[0].content.parts[0].text;
                    addChatMessage('Fox', `Análise de Sentimento: ${sentimentAnalysis}`);
                } else {
                    addSystemMessage('Fox: Não consegui analisar o sentimento do chat. A resposta da API estava vazia ou malformada. Verifique o console.');
                    console.error('Gemini API response structure unexpected for sentiment analysis:', result);
                }
            } catch (error) {
                console.error('Error calling Gemini API for sentiment analysis:', error);
                addSystemMessage('Fox: Ocorreu um erro ao tentar analisar o sentimento. Verifique sua conexão ou tente novamente.');
            }
        };

        // --- Gemini API Integration: Creative Prompt Generator ---
        document.getElementById('generateCreativePromptBtn').onclick = generateCreativePrompt;
        async function generateCreativePrompt() {
            if (!roomID) {
                await customAlert('Você precisa estar em uma sala para gerar uma ideia criativa.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restrição de idade.');
                return;
            }

            addSystemMessage('Fox está gerando uma ideia criativa... Por favor, aguarde.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação

            try {
                let context = '';
                if (currentMediaState.name && currentMediaState.name !== 'Link Externo') {
                    context += `A mídia atual sendo reproduzida é "${currentMediaState.name}".`;
                } else {
                    const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                    if (chatMessages.length > 0) {
                        // [AJUSTE/BUGFIX]: Ao obter contexto, garantir que links sejam representados pelo seu texto ou URL original
                        const recentMessages = chatMessages.slice(-10).map(msg => {
                            if (msg.type === 'link') {
                                return `${msg.sender}: ${msg.mediaName || msg.message}`;
                            }
                            return msg.message;
                        }).join('\n');
                        context += `As últimas mensagens do chat são:\n${recentMessages}`;
                    } else {
                        context += 'Não há mídia sendo reproduzida nem mensagens recentes no chat.';
                    }
                }

                const prompt = `Gere uma ideia criativa curta e interessante (ex: um início de história, um cenário de jogo, uma pergunta "e se...") baseada no seguinte contexto. Se o contexto for limitado, crie algo divertido e aleatório. Contexto: ${context}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                    addSystemMessage(`Fox: Não consegui gerar uma ideia criativa. Erro da API: ${response.status}. Verifique o console para mais detalhes.`);
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const creativePrompt = result.candidates[0].content.parts[0].text;
                    addChatMessage('Fox', `Aqui está uma Ideia Criativa: ${creativePrompt} ✨`);
                } else {
                    addSystemMessage('Fox: Não consegui gerar uma ideia criativa. A resposta da API estava vazia ou malformada. Verifique o console.');
                    console.error('Gemini API response structure unexpected for creative prompt:', result);
                }
            } catch (error) {
                console.error('Error calling Gemini API for creative prompt:', error);
                addSystemMessage('Fox: Ocorreu um erro ao tentar gerar uma ideia criativa. Verifique sua conexão ou tente novamente.');
            }
        };

        // --- New Gemini API Integration: Trivia Question Generator ---
        document.getElementById('generateTriviaBtn').onclick = async () => {
            if (!roomID) {
                await customAlert('Você precisa estar em uma sala para gerar uma curiosidade.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restrição de idade.');
                return;
            }

            addSystemMessage('Fox está pensando em uma curiosidade para você... Por favor, aguarde.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação

            try {
                let context = '';
                if (currentMediaState.name && currentMediaState.name !== 'Link Externo') {
                    context += `A mídia atual sendo reproduzida é "${currentMediaState.name}".`;
                } else {
                    const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                    if (chatMessages.length > 0) {
                        // [AJUSTE/BUGFIX]: Ao obter contexto, garantir que links sejam representados pelo seu texto ou URL original
                        const recentMessages = chatMessages.slice(-10).map(msg => {
                            if (msg.type === 'link') {
                                return `${msg.sender}: ${msg.mediaName || msg.message}`;
                            }
                            return msg.message;
                        }).join('\n');
                        context += `As últimas mensagens do chat são:\n${recentMessages}`;
                    } else {
                        context += 'Não há mídia sendo reproduzida nem mensagens recentes no chat.';
                    }
                }

                const prompt = `Gere uma pergunta de curiosidade ou quiz interessante e sua resposta. A pergunta deve ser concisa. A resposta deve ser clara e vir após "Resposta:".
                Exemplo:
                Pergunta: Qual é o maior oceano do mundo?
                Resposta: O Oceano Pacífico.
                Contexto: ${context}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                    addSystemMessage(`Fox: Não consegui gerar uma curiosidade. Erro da API: ${response.status}. Verifique o console para mais detalhes.`);
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const trivia = result.candidates[0].content.parts[0].text;
                    addChatMessage('Fox', `Curiosidade: ${trivia} ✨`);
                } else {
                    addSystemMessage('Fox: Não consegui gerar uma curiosidade. A resposta da API estava vazia ou malformada. Verifique o console.');
                    console.error('Gemini API response structure unexpected for trivia generator:', result);
                }
            } catch (error) {
                console.error('Error calling Gemini API for trivia generator:', error);
                addSystemMessage('Fox: Ocorreu um erro ao tentar gerar uma curiosidade. Verifique sua conexão ou tente novamente.');
            }
        };

        // --- New Gemini API Integration: Mood-based Media Suggestion ---
        document.getElementById('suggestMoodMediaBtn').onclick = async () => {
            if (!roomID) {
                await customAlert('Você precisa estar em uma sala para obter sugestões de mídia por humor.');
                return;
            }
            if (currentRoomAgeRestricted) {
                await customAlert('Funcionalidade de IA desativada em salas com restrição de idade.');
                return;
            }

            addSystemMessage('Fox está analisando o humor do chat para sugerir algo... Por favor, aguarde.');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação

            try {
                const chatMessages = JSON.parse(localStorage.getItem(LOCAL_STORAGE_CHAT_PREFIX + roomID) || '[]');
                if (chatMessages.length === 0) {
                    addSystemMessage('Fox: Não há mensagens no chat para analisar o humor. Tente conversar um pouco mais!');
                    return;
                }

                // [AJUSTE/BUGFIX]: Ao obter contexto, garantir que links sejam representados pelo seu texto ou URL original
                const recentMessages = chatMessages.slice(-20).map(msg => {
                    if (msg.type === 'link') {
                        return `${msg.sender}: ${msg.mediaName || msg.message}`;
                    }
                    return msg.message;
                }).join('\n'); // Analyze last 20 messages

                const prompt = `Com base no sentimento geral das seguintes mensagens de chat, sugira um tipo de música ou gênero de mídia (filme, série, vídeo do YouTube) que combine com esse humor. Seja criativo e conciso. Responda com uma frase como "O humor do chat é [humor], então sugiro [tipo de mídia/gênero].". Mensagens:\n\n${recentMessages}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });

                const payload = { contents: chatHistory };
                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                    addSystemMessage(`Fox: Não consegui sugerir mídia por humor. Erro da API: ${response.status}. Verifique o console para mais detalhes.`);
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const moodSuggestion = result.candidates[0].content.parts[0].text;
                    addChatMessage('Fox', `Sugestão por Humor: ${moodSuggestion} ✨`);
                } else {
                    addSystemMessage('Fox: Não consegui sugerir mídia por humor. A resposta da API estava vazia ou malformada. Verifique o console.');
                    console.error('Gemini API response structure unexpected for mood suggestion:', result);
                }
            } catch (error) {
                console.error('Error calling Gemini API for mood suggestion:', error);
                addSystemMessage('Fox: Ocorreu um erro ao tentar sugerir mídia por humor. Verifique sua conexão ou tente novamente.');
            }
        };


        // --- Poll Functionality ---
        function parseAndCreatePoll(rawPollText) {
            const lines = rawPollText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            if (lines.length < 2 || !lines[0].startsWith('Pergunta:')) {
                addSystemMessage('Formato de enquete inválido gerado pela Fox. Tente novamente.'); // Updated message
                return;
            }

            const question = lines[0].replace('Pergunta:', '').trim();
            const options = [];
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].match(/^\d+\./)) { // Checks for "1. Option" format
                    options.push({
                        text: lines[i].replace(/^\d+\./, '').trim(),
                        votes: 0,
                        voters: []
                    });
                }
            }

            if (options.length < 2) {
                addSystemMessage('Não foi possível extrair opções suficientes da enquete gerada pela Fox. Tente novamente.'); // Updated message
                return;
            }

            activePoll = {
                id: `poll-${Date.now()}`,
                question: question,
                options: options
            };
            savePollState();
            displayPollInChat();
            addSystemMessage('Nova enquete criada!');
            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
        }

        function savePollState() {
            if (roomID && activePoll) {
                localStorage.setItem(LOCAL_STORAGE_ACTIVE_POLL + roomID, JSON.stringify(activePoll));
            } else {
                localStorage.removeItem(LOCAL_STORAGE_ACTIVE_POLL + roomID);
            }
        }

        function loadPollState() {
            if (roomID) {
                const storedPoll = localStorage.getItem(LOCAL_STORAGE_ACTIVE_POLL + roomID);
                if (storedPoll) {
                    activePoll = JSON.parse(storedPoll);
                    displayPollInChat();
                } else {
                    activePoll = null;
                    removePollFromChat();
                }
            }
        }

        function displayPollInChat() {
            removePollFromChat(); // Remove any existing poll display

            if (!activePoll) return;

            const chatLog = document.getElementById('chatLog');
            const pollContainer = document.createElement('div');
            pollContainer.id = 'activePollDisplay';
            pollContainer.className = 'poll-container';

            const questionElem = document.createElement('p');
            questionElem.className = 'poll-question';
            questionElem.textContent = `Enquete: ${activePoll.question}`;
            pollContainer.appendChild(questionElem);

            activePoll.options.forEach((option, index) => {
                const optionBtn = document.createElement('button');
                optionBtn.className = 'poll-option-btn';
                optionBtn.textContent = option.text;
                optionBtn.dataset.optionIndex = index;
                optionBtn.onclick = () => voteOnPoll(index);

                const percentageSpan = document.createElement('span');
                percentageSpan.className = 'poll-percentage';
                percentageSpan.textContent = `(0%)`; // Initial percentage
                optionBtn.appendChild(percentageSpan);

                if (option.voters.includes(myName)) {
                    optionBtn.classList.add('voted');
                }

                pollContainer.appendChild(optionBtn);
            });

            chatLog.appendChild(pollContainer);
            updatePollDisplayPercentages(); // Update percentages immediately
            chatLog.scrollTop = chatLog.scrollHeight;
        }

        function removePollFromChat() {
            const existingPoll = document.getElementById('activePollDisplay');
            if (existingPoll) {
                existingPoll.remove();
            }
        }

        function voteOnPoll(optionIndex) {
            if (!activePoll) {
                customAlert('Não há uma enquete ativa para votar.');
                return;
            }
            // [BUG]: Se o usuário já votou, ele pode votar novamente, o que é um bug.
            // A lógica `activePoll.options[optionIndex].voters.includes(myName)` verifica se o usuário votou *nesta opção*.
            // Mas ele pode ter votado em *outra* opção e querer mudar o voto.
            // MELHORIA: A lógica deve permitir mudar o voto, removendo o voto anterior e adicionando o novo.
            // O código já faz isso: `Remove previous vote if any`, o que é bom!
            if (activePoll.options[optionIndex].voters.includes(myName)) {
                // Se o usuário já votou nesta opção específica, não precisa fazer nada (ou alertar que já votou).
                // O código abaixo já remove o voto anterior, então se ele clicar na mesma opção, o voto será "removido e adicionado" novamente,
                // resultando em nenhuma mudança líquida nos votos totais, mas pode ser confuso para o usuário.
                // customAlert('Você já votou nesta opção!'); // Descomente se quiser alertar
                // return; // Descomente se quiser impedir cliques repetidos na mesma opção
            }

            // Remove previous vote if any
            activePoll.options.forEach(option => {
                const voterIndex = option.voters.indexOf(myName);
                if (voterIndex !== -1) {
                    option.voters.splice(voterIndex, 1);
                    option.votes--;
                }
            });

            // Add new vote
            activePoll.options[optionIndex].votes++;
            activePoll.options[optionIndex].voters.push(myName);

            savePollState(); // Save updated state
            updatePollDisplayPercentages(); // Update UI
            addSystemMessage(`${myName} votou em "${activePoll.options[optionIndex].text}" na enquete.`);
        }

        function updatePollDisplayPercentages() {
            if (!activePoll) return;

            const totalVotes = activePoll.options.reduce((sum, option) => sum + option.votes, 0);
            const pollButtons = document.querySelectorAll('#activePollDisplay .poll-option-btn');

            pollButtons.forEach((button, index) => {
                const option = activePoll.options[index];
                const percentage = totalVotes === 0 ? 0 : ((option.votes / totalVotes) * 100).toFixed(0);
                button.querySelector('.poll-percentage').textContent = `(${percentage}%)`;

                // Highlight voted option
                if (option.voters.includes(myName)) {
                    button.classList.add('voted');
                } else {
                    button.classList.remove('voted');
                }
            });
        }

        // --- AI Buttons Panel Toggle ---
        document.getElementById('toggleAIButtonsBtn').onclick = () => {
            const panel = document.getElementById('aiButtonsPanel');
            panel.classList.toggle('expanded');
        };


        // Função para controlar a visibilidade dos botões de IA
        function updateAIBottonVisibility() {
            const summarizeBtn = document.getElementById('summarizeChatBtn');
            const toggleAIButtonsBtn = document.getElementById('toggleAIButtonsBtn');
            const aiButtonsPanel = document.getElementById('aiButtonsPanel');
            const analyzeSentimentBtn = document.getElementById('analyzeSentimentBtn');
            const generateCreativePromptBtn = document.getElementById('generateCreativePromptBtn');
            const generateTriviaBtn = document.getElementById('generateTriviaBtn'); // New button
            const suggestMoodMediaBtn = document.getElementById('suggestMoodMediaBtn'); // New button
            const generatePollBtn = document.getElementById('generatePollBtn'); // Add reference to poll button
            const suggestContentBtn = document.getElementById('suggestContentBtn'); // Add reference to suggest content button


            if (currentRoomAgeRestricted) {
                summarizeBtn.style.display = 'none';
                toggleAIButtonsBtn.style.display = 'none';
                aiButtonsPanel.classList.remove('expanded'); // Garante que o painel esteja recolhido
                analyzeSentimentBtn.style.display = 'none';
                generateCreativePromptBtn.style.display = 'none';
                generateTriviaBtn.style.display = 'none'; // Hide new button
                suggestMoodMediaBtn.style.display = 'none'; // Hide new button
                generatePollBtn.style.display = 'none'; // Hide poll button
                suggestContentBtn.style.display = 'none'; // Hide suggest content button
            } else {
                summarizeBtn.style.display = 'flex'; // ou 'block' dependendo do layout
                toggleAIButtonsBtn.style.display = 'flex'; // ou 'block'
                analyzeSentimentBtn.style.display = 'flex';
                generateCreativePromptBtn.style.display = 'flex';
                generateTriviaBtn.style.display = 'flex'; // Show new button
                suggestMoodMediaBtn.style.display = 'flex'; // Show new button
                generatePollBtn.style.display = 'flex'; // Show poll button
                suggestContentBtn.style.display = 'flex'; // Show suggest content button
            }
        }

        // --- AI Chatbot ---
        async function getAIChatbotResponse(userMessage, userName) { // Pass userName here
            // If AI is sleeping, it does not respond to general chat messages.
            if (aiSleeping) {
                return;
            }

            addSystemMessage('Fox está pensando...'); // Updated message
            try {
                // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Lida com a seleção de mídia numérica
                if (foxAwaitingMediaSelection && !isNaN(parseInt(userMessage))) {
                    const selectionIndex = parseInt(userMessage) - 1; // Convert to 0-based index
                    if (selectionIndex >= 0 && selectionIndex < foxAwaitingMediaSelection.length) {
                        const selectedMedia = foxAwaitingMediaSelection[selectionIndex];
                        const playedSuccessfully = playAndBroadcast(selectedMedia.url, selectedMedia.type, selectedMedia.name, true);
                        if (playedSuccessfully) {
                            addChatMessage('Fox', `Ok, ${userName}! Começando a reproduzir "${selectedMedia.name}" para você!`);
                        } else {
                            addChatMessage('Fox', `Ops! Não consegui reproduzir "${selectedMedia.name}". Tem certeza que é um link válido e que eu tenho permissão?`);
                        }
                        foxAwaitingMediaSelection = null; // Clear the selection context
                        foxAwaitingConfirmationForPlay = null; // Clear any confirmation context
                        return; // Exit after handling selection
                    } else {
                        addChatMessage('Fox', `Por favor, ${userName}, digite um número válido da lista (1 a ${foxAwaitingMediaSelection.length}).`);
                        return; // Exit, waiting for a valid selection
                    }
                }

                // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Lida com a confirmação de reprodução de link específico
                if (foxAwaitingConfirmationForPlay) {
                    const userResponseLower = userMessage.toLowerCase();
                    if (userResponseLower.includes('sim') || userResponseLower.includes('quero') || userResponseLower.includes('pode')) {
                        const mediaToPlay = foxAwaitingConfirmationForPlay.media;
                        const playedSuccessfully = playAndBroadcast(mediaToPlay.url, mediaToPlay.type, mediaToPlay.name, true);
                        if (playedSuccessfully) {
                            addChatMessage('Fox', `Ok, ${foxAwaitingConfirmationForPlay.userName}! Começando a reproduzir "${mediaToPlay.name}" para você!`);
                        } else {
                            addChatMessage('Fox', `Ops! Não consegui reproduzir "${mediaToPlay.name}". Tem certeza que é um link válido e que eu tenho permissão?`);
                        }
                        foxAwaitingConfirmationForPlay = null; // Clear the confirmation context
                        foxAwaitingMediaSelection = null; // Clear any numeric selection context
                        return; // Exit
                    } else if (userResponseLower.includes('não') || userResponseLower.includes('nao') || userResponseLower.includes('nao quero') || userResponseLower.includes('cancelar')) {
                        addChatMessage('Fox', `Ok, ${foxAwaitingConfirmationForPlay.userName}. Não vou reproduzir "${foxAwaitingConfirmationForPlay.media.name}".`);
                        foxAwaitingConfirmationForPlay = null; // Clear the confirmation context
                        foxAwaitingMediaSelection = null; // Clear any numeric selection context
                        return; // Exit
                    } else {
                        addChatMessage('Fox', `Desculpe, ${foxAwaitingConfirmationForPlay.userName}, não entendi sua resposta. Por favor, diga "sim" ou "não" para reproduzir "${foxAwaitingConfirmationForPlay.media.name}".`);
                        return; // Keep waiting for confirmation
                    }
                }


                let extractedUrl = null;
                const urlRegex = /(https?:\/\/[^\s]+)/g;
                const urlMatches = userMessage.match(urlRegex);
                if (urlMatches && urlMatches.length > 0) {
                    extractedUrl = urlMatches[0]; // Take the first URL found
                }

                // [MELHORIA IA]: Prompt para detecção de intenção mais robusta, incluindo "stop_media"
                const intentDetectionPrompt = `Analise a seguinte mensagem do usuário e determine a intenção principal.
                Responda em JSON com apenas a "intent".
                {
                    "intent": "time_query" | "media_request" | "user_agent_query" | "analyze_link" | "general_chat" | "self_name_query" | "command_execution" | "stop_media"
                }
                Mensagem do usuário: "${userMessage}"`;

                let chatHistoryIntent = [];
                chatHistoryIntent.push({ role: "user", parts: [{ text: intentDetectionPrompt }] }); 

                const intentPayload = {
                    contents: chatHistoryIntent,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "intent": { "type": "STRING", "enum": ["time_query", "media_request", "user_agent_query", "analyze_link", "general_chat", "self_name_query", "command_execution", "stop_media"] }
                            },
                            "propertyOrdering": ["intent"]
                        }
                    }
                };

                // START API KEY MODIFICATION
                const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA API DO GEMINI AQUI >>>>>>>
                // END API KEY MODIFICATION
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const intentResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(intentPayload)
                });

                if (!intentResponse.ok) {
                    const errorText = await intentResponse.text();
                    console.error(`API Intent Error: ${intentResponse.status} ${intentResponse.statusText} - ${errorText}`);
                    addSystemMessage('Fox: Não consegui entender sua intenção. Erro da API de intenção. Verifique o console.');
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    return;
                }

                const result = await intentResponse.json();
                let parsedIntent = { intent: "general_chat" }; // Default

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    try {
                        parsedIntent = JSON.parse(result.candidates[0].content.parts[0].text);
                    } catch (e) {
                        console.error('Failed to parse intent JSON:', e);
                        // Fallback to general chat if parsing fails
                        parsedIntent = { intent: "general_chat" };
                    }
                }

                // Handle intents
                if (parsedIntent.intent === 'stop_media') { // [NOVA FUNCIONALIDADE]: Lidar com intenção de parar mídia
                    if (isAdmin || isMod(myName)) {
                        stopMedia();
                        addChatMessage('Fox', `Ok, ${userName}, parei a mídia no player.`);
                    } else {
                        addChatMessage('Fox', `Desculpe, ${userName}, apenas administradores ou moderadores podem parar a mídia. Mas você pode usar o comando /stop para isso.`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    return;
                } else if (parsedIntent.intent === 'command_execution') {
                    // NEW: Use LLM to extract the specific command to execute
                    const commandExtractionPrompt = `O usuário quer executar um comando. Com base na mensagem do usuário, identifique o comando exato que ele pretende usar. Se o comando envolver um nome de usuário (como kick, ban, mute, admin, mod), certifique-se de que o nome de usuário seja incluído. Se for um comando geral como 'limpar histórico de chat' ou 'recarregar página', formalize-o para '/clear all' ou '/reload all'. Se o comando for sobre ações da IA (sleep, wake, exit, screencast, gerar enquete, fechar enquete, analisar sentimento, ideia criativa, curiosidade, humor), formalize-o para '/AI [subcomando]'. Se o comando for para parar a mídia, formalize-o para '/stop'. Responda apenas com a string do comando formalizado. Se nenhum comando claro puder ser identificado, responda com 'no_command'.
                    Mensagem do usuário: "${userMessage}"`;

                    let commandExtractionHistory = [];
                    commandExtractionHistory.push({ role: "user", parts: [{ text: commandExtractionPrompt }] });

                    const commandExtractionPayload = { contents: commandExtractionHistory };
                    const commandExtractionResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(commandExtractionPayload)
                    });

                    if (!commandExtractionResponse.ok) {
                        const errorText = await commandExtractionResponse.text();
                        console.error(`API Command Extraction Error: ${commandExtractionResponse.status} ${commandExtractionResponse.statusText} - ${errorText}`);
                        addSystemMessage('Fox: Não consegui extrair o comando da sua mensagem. Erro na API de extração de comando.');
                        foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                        foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                        return;
                    }

                    const commandExtractionResult = await commandExtractionResponse.json();
                    let extractedCommand = 'no_command';

                    if (commandExtractionResult.candidates && commandExtractionResult.candidates.length > 0 &&
                        commandExtractionResult.candidates[0].content && commandExtractionResult.candidates[0].content.parts &&
                        commandExtractionResult.candidates[0].content.parts.length > 0) {
                        extractedCommand = commandExtractionResult.candidates[0].content.parts[0].text.trim();
                    }

                    if (extractedCommand !== 'no_command') {
                        foxExecuteCommand(extractedCommand, userName); // Pass the extracted, formalized command
                    } else {
                        addChatMessage('Fox', `Desculpe, ${userName}, não consegui identificar um comando claro na sua mensagem. Você pode digitar "/help" para ver meus comandos.`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    return; // Exit getAIChatbotResponse after command handling
                } else if (parsedIntent.intent === 'self_name_query') {
                    addChatMessage('Fox', `Seu nome é ${userName}! Prazer em te conhecer (de novo)! 😊`);
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                } else if (parsedIntent.intent === 'analyze_link' && extractedUrl) {
                    addSystemMessage(`Fox: Entendi! Você quer que eu analise o link: ${extractedUrl}.`);

                    // Check if it's a media URL first, offer to play
                    const { processedUrl, mediaType, mediaName, isValid } = parseMediaLink(extractedUrl);

                    if (isValid) {
                        const confirmPlay = await customConfirm(`Fox: Parece que este é um link de mídia: ${extractedUrl}. Quer que eu o reproduza no player? (Se escolher "Não", eu tentarei te dar informações sobre o link, mas não posso "navegar" nele diretamente.)`);
                        if (confirmPlay) {
                            playAndBroadcast(processedUrl, mediaType, mediaName, true);
                            addChatMessage('Fox', `Começando a reproduzir a mídia de ${extractedUrl}!`);
                            foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                            return; // Exit after playing
                        }
                    }

                    // If not a media link or user declined playback, explain limitation
                    addChatMessage('Fox', `Desculpe, não consigo "navegar" diretamente em links externos como ${extractedUrl} do meu ambiente aqui no navegador devido a restrições de segurança (CORS).`);
                    
                    // Ask LLM to summarize the URL string itself
                    const urlSummaryPrompt = `Resuma brevemente o que você espera encontrar em uma página com a URL: ${extractedUrl}. Mencione o domínio principal e o tipo de conteúdo que a URL sugere.`;
                    let urlSummaryChatHistory = [];
                    urlSummaryChatHistory.push({ role: "user", parts: [{ text: urlSummaryPrompt }] });
                    const urlSummaryPayload = { contents: urlSummaryChatHistory };
                    const urlSummaryResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(urlSummaryPayload)
                    });

                    if (!urlSummaryResponse.ok) {
                        const errorText = await urlSummaryResponse.text();
                        console.error(`API URL Summary Error: ${urlSummaryResponse.status} ${urlSummaryResponse.statusText} - ${errorText}`);
                        addChatMessage('Fox', `Não consegui gerar um resumo do link ${extractedUrl}. Erro da API de resumo. Verifique o console.`);
                        foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                        foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                        return;
                    }

                    const urlSummaryResult = await urlSummaryResponse.json();

                    if (urlSummaryResult.candidates && urlSummaryResult.candidates.length > 0 &&
                        urlSummaryResult[0].content && urlSummaryResult[0].content.parts &&
                        urlSummaryResult[0].content.parts.length > 0) {
                        const urlSummaryText = urlSummaryResult[0].content.parts[0].text;
                        addChatMessage('Fox', `Sobre o link ${extractedUrl}: ${urlSummaryText}`);
                    } else {
                        console.error('Gemini API response structure unexpected for URL summary:', urlSummaryResult);
                        addChatMessage('Fox', `Não consegui gerar um resumo do link ${extractedUrl}.`);
                    }

                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    return; // Exit after handling analyze_link
                }

                if (parsedIntent.intent === 'time_query') {
                    if (userMessage.toLowerCase().includes('brasília')) { // Simple check for "Brasília"
                        const brasiliaTime = new Date().toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo', hour: '2-digit', minute: '2-digit', second: '2-digit', timeZoneName: 'short' });
                        addChatMessage('Fox', `Em Brasília, agora são: ${brasiliaTime}.`);
                    } else { // current_location or general time query
                        addLocalTempMessage('Fox', 'Para te dizer as horas exatas da sua localização, preciso da sua permissão. Por favor, aceite a solicitação do navegador.');

                        if (navigator.geolocation) {
                            navigator.geolocation.getCurrentPosition(
                                (position) => {
                                    removeTempMessage(); // Remove the temporary message
                                    const now = new Date();
                                    const localTime = now.toLocaleString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit', timeZoneName: 'short' });
                                    addChatMessage('Fox', `Na sua localização, agora são: ${localTime}.`);
                                },
                                (error) => {
                                    removeTempMessage(); // Remove the temporary message
                                    let errorMessage = 'Não consegui obter sua localização.';
                                    if (error.code === error.PERMISSION_DENIED) {
                                        errorMessage += ' A permissão foi negada.';
                                    } else if (error.code === error.POSITION_UNAVAILABLE) {
                                        errorMessage += ' A informação de localização não está disponível.';
                                    } else if (error.code === error.TIMEOUT) {
                                        errorMessage += ' A solicitação de localização expirou.';
                                    }
                                    addChatMessage('Fox', `Ops! ${errorMessage} Não posso te dizer as horas exatas sem ela. 😢`);
                                    console.error('Geolocation error:', error);
                                },
                                {
                                    enableHighAccuracy: false, // Not strictly needed for time, but good for general location
                                    timeout: 5000, // 5 seconds to get location
                                    maximumAge: 0 // Get fresh location, equivalent to "only this time" for a new request
                                }
                            );
                        } else {
                            removeTempMessage(); // Remove the temporary message
                            addChatMessage('Fox', 'Seu navegador não suporta a API de Geolocation. Não posso te dizer as horas exatas da sua localização. 😢');
                        }
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                } else if (parsedIntent.intent === 'user_agent_query') {
                    addChatMessage('Fox', `Hmm, deixe-me ver... Seu User Agent é: "${navigator.userAgent}". É assim que os navegadores se identificam! 😉`);
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                } else if (parsedIntent.intent === 'media_request') {
                    // If no URL was extracted, it's a search query
                    if (!extractedUrl) {
                        // New: Use LLM to extract the precise search query AND platform
                        const mediaExtractionPrompt = `Analise a seguinte mensagem do usuário e extraia a frase de busca principal para uma mídia (música, vídeo, live, etc.) e a plataforma desejada, se especificada. Se a plataforma não for especificada, use "none".
                        Responda em JSON com "search_query" e "platform".
                        Exemplos:
                        User: "Quero ouvir Kami Kam - Ventos de Doutrina no youtube"
                        Response: {"search_query": "Kami Kam - Ventos de Doutrina", "platform": "youtube"}
                        User: "Coloca a live do Alanzoka de ontem na twitch"
                        Response: {"search_query": "live Alanzoka ontem", "platform": "twitch"}
                        User: "procura por ventos de doutrina kami kam pra mim no youtub e e coloca no player favor?"
                        Response: {"search_query": "ventos de doutrina kami kam", "platform": "youtube"}
                        User: "toca aquela música legal"
                        Response: {"search_query": "aquela música legal", "platform": "none"}
                        User message: "${userMessage}"`;

                        let mediaExtractionHistory = [];
                        mediaExtractionHistory.push({ role: "user", parts: [{ text: mediaExtractionPrompt }] });

                        const mediaExtractionPayload = {
                            contents: mediaExtractionHistory,
                            generationConfig: {
                                responseMimeType: "application/json",
                                responseSchema: {
                                    type: "OBJECT",
                                    properties: {
                                        "search_query": { "type": "STRING" },
                                        "platform": { "type": "STRING", "enum": ["youtube", "twitch", "vimeo", "dailymotion", "none"] }
                                    },
                                    "propertyOrdering": ["search_query", "platform"]
                                }
                            }
                        };

                        const mediaExtractionResponse = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(mediaExtractionPayload)
                        });

                        if (!mediaExtractionResponse.ok) {
                            const errorText = await mediaExtractionResponse.text();
                            console.error(`API Media Extraction Error: ${mediaExtractionResponse.status} ${mediaExtractionResponse.statusText} - ${errorText}`);
                            addChatMessage('Fox', `Não consegui entender sua solicitação de mídia. Erro na API de extração de mídia.`);
                            foxAwaitingMediaSelection = null;
                            foxAwaitingConfirmationForPlay = null;
                            return;
                        }

                        const mediaExtractionResult = await mediaExtractionResponse.json();
                        let extractedMediaInfo = { search_query: userMessage, platform: "none" }; // Fallback

                        if (mediaExtractionResult.candidates && mediaExtractionResult.candidates.length > 0 &&
                            mediaExtractionResult[0].content && mediaExtractionResult[0].content.parts &&
                            mediaExtractionResult[0].content.parts.length > 0) {
                            try {
                                extractedMediaInfo = JSON.parse(mediaExtractionResult[0].content.parts[0].text);
                            } catch (e) {
                                console.error('Failed to parse media extraction JSON:', e);
                                // Fallback to original message if parsing fails
                                extractedMediaInfo = { search_query: userMessage, platform: "none" };
                            }
                        }

                        const mediaSearchQuery = extractedMediaInfo.search_query;
                        const targetPlatform = extractedMediaInfo.platform;

                        if (!mediaSearchQuery) {
                            addChatMessage('Fox', `Não consegui extrair uma frase de busca válida da sua solicitação. Poderia ser mais específico?`);
                            foxAwaitingMediaSelection = null;
                            foxAwaitingConfirmationForPlay = null;
                            return;
                        }

                        addSystemMessage(`Fox: Pesquisando por "${mediaSearchQuery}" no ${targetPlatform === 'none' ? 'YouTube, Twitch, Vimeo ou DailyMotion' : targetPlatform}...`);

                        // Simulate search results based on targetPlatform
                        const searchResults = await new Promise(resolve => {
                            let mockResults = [];
                            const baseYoutubeUrl = "https://www.youtube.com/watch?v=";
                            const baseTwitchUrl = "https://twitch.tv/";
                            const baseVimeoUrl = "https://vimeo.com/";
                            const baseDailymotionUrl = "https://www.dailymotion.com/video/";

                            // Prioritize platform if specified
                            if (targetPlatform === 'youtube' || targetPlatform === 'none') {
                                if (mediaSearchQuery.toLowerCase().includes('ventos de doutrina kami kam')) {
                                    mockResults.push({ url: `${baseYoutubeUrl}dQw4w9WgXcQ`, title: "Kami Kam - Ventos de Doutrina (Official Music Video)", source: "YouTube" });
                                } else if (mediaSearchQuery.toLowerCase().includes('minecraft live')) {
                                    mockResults.push({ url: `${baseYoutubeUrl}minecraft_live_1`, title: "Minecraft Live: Construindo Castelos", source: "YouTube" });
                                }
                            }
                            if (targetPlatform === 'twitch' || targetPlatform === 'none') {
                                if (mediaSearchQuery.toLowerCase().includes('alanzoka live')) {
                                    mockResults.push({ url: `${baseTwitchUrl}alanzoka`, title: "Alanzoka - Live Stream", source: "Twitch" });
                                } else if (mediaSearchQuery.toLowerCase().includes('streamer famoso')) {
                                    mockResults.push({ url: `${baseTwitchUrl}streamer_famoso`, title: "Streamer Famoso - Ao Vivo", source: "Twitch" });
                                }
                            }
                            if (targetPlatform === 'vimeo' || targetPlatform === 'none') {
                                if (mediaSearchQuery.toLowerCase().includes('documentario natureza')) {
                                    mockResults.push({ url: `${baseVimeoUrl}123456789`, title: "Documentário: A Vida Selvagem", source: "Vimeo" });
                                }
                            }
                            if (targetPlatform === 'dailymotion' || targetPlatform === 'none') {
                                if (mediaSearchQuery.toLowerCase().includes('noticias do dia')) {
                                    mockResults.push({ url: `${baseDailymotionUrl}x123abc`, title: "Notícias do Dia - Edição Especial", source: "DailyMotion" });
                                }
                            }

                            // If no specific platform result, add a generic one for "none" or if no match
                            if (mockResults.length === 0 && targetPlatform === 'none') {
                                mockResults.push({ url: `${baseYoutubeUrl}generic_video_id`, title: `Vídeo Genérico para "${mediaSearchQuery}"`, source: "YouTube" });
                            } else if (mockResults.length === 0 && targetPlatform !== 'none') {
                                // If a platform was specified but no results, try a generic one for that platform
                                mockResults.push({ url: `${baseYoutubeUrl}generic_video_id`, title: `Vídeo Genérico para "${mediaSearchQuery}" no ${targetPlatform}`, source: targetPlatform });
                            }

                            resolve([{ query: mediaSearchQuery, results: mockResults }]);
                        });
                        
                        let foundMediaLinks = [];
                        if (searchResults && searchResults.length > 0 && searchResults[0].results) {
                            for (const result of searchResults[0].results) {
                                const { processedUrl: pUrl, mediaType: mType, mediaName: mName, isValid: isV } = parseMediaLink(result.url);
                                if (isV) {
                                    foundMediaLinks.push({ url: pUrl, type: mType, name: mName, originalLink: result.url });
                                }
                            }
                        }

                        if (foundMediaLinks.length > 0) {
                            // User wants only one link if platform is specified, or the first relevant one.
                            const mediaToSuggest = foundMediaLinks[0]; // Take the first most relevant result

                            addClickableLinkMessage('Fox', mediaToSuggest.originalLink, mediaToSuggest.url, mediaToSuggest.type, mediaToSuggest.name);
                            addChatMessage('Fox', `Encontrei "${mediaToSuggest.name}" (${mediaToSuggest.type}). Quer que eu reproduza? (Responda "sim" ou "não")`);
                            
                            // Set a new state to await confirmation for this specific link
                            foxAwaitingConfirmationForPlay = {
                                media: mediaToSuggest,
                                userName: userName // Store userName to use in confirmation response
                            };
                            foxAwaitingMediaSelection = null; // Clear any previous numeric selection context
                        } else {
                            addChatMessage('Fox', `Desculpe, não consegui encontrar nenhuma mídia relevante para "${mediaSearchQuery}" na plataforma ${targetPlatform === 'none' ? 'que procurei' : targetPlatform}.`);
                            foxAwaitingMediaSelection = null;
                            foxAwaitingConfirmationForPlay = null;
                        }
                    } else {
                        // Existing logic for direct URL media requests
                        let playedSuccessfully = false;
                        const { processedUrl, mediaType, mediaName, isValid } = parseMediaLink(extractedUrl);

                        if (isValid) {
                            playedSuccessfully = playAndBroadcast(processedUrl, mediaType, mediaName, true);
                            if (playedSuccessfully) {
                                addChatMessage('Fox', `Claro! Começando a reproduzir para você! Espero que goste! ✨`);
                            } else {
                                addChatMessage('Fox', `Ops! Não consegui reproduzir o link. Tem certeza que é um link válido e que eu tenho permissão?`);
                            }
                        } else {
                            addChatMessage('Fox', `Desculpe, não consigo reproduzir este link diretamente. Parece que não é um formato de mídia que eu reconheça para o player.`);
                            return;
                        }
                        foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                        foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    }
                } else {
                    // General conversation
                    // [MELHORIA IA]: Incluir o papel do usuário no prompt geral da Fox
                    const currentUser = participants.find(p => p.name === userName);
                    let userRoleDescription = '';
                    if (currentUser && currentUser.isAdmin) {
                        userRoleDescription = `Você está falando com ${userName}, o administrador da sala.`;
                    } else if (currentUser && currentUser.isMod) {
                        userRoleDescription = `Você está falando com ${userName}, o moderador da sala.`;
                    } else {
                        userRoleDescription = `Você está falando com ${userName}.`;
                    }

                    const generalPrompt = `Você é uma chatbot amigável chamada Fox em uma sala de chat com um player de áudio e vídeo HTML/CSS/JS. Você pode ajudar os usuários com tarefas relacionadas ao player (como reproduzir links, pesquisar conteúdo) e também conversar sobre tópicos gerais. ${userRoleDescription} Responda à seguinte mensagem do usuário de forma concisa e útil, mantendo a conversa fluida. Mensagem do usuário: "${userMessage}"`;

                    let generalChatHistory = [];
                    generalChatHistory.push({ role: "user", parts: [{ text: generalPrompt }] });

                    const generalPayload = { contents: generalChatHistory };
                    // START API KEY MODIFICATION
                    const apiKey = "AIzaSyAOuzktFA0cXO6C5u4kug8TAOWd9h-wbUc"; // <<<<<<< COLOQUE SUA CHAVE DA API DO GEMINI AQUI >>>>>>>
                    // END API KEY MODIFICATION
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    const generalResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(generalPayload)
                    });

                    if (!generalResponse.ok) {
                        const errorText = await generalResponse.text();
                        console.error(`API General Chat Error: ${generalResponse.status} ${generalResponse.statusText} - ${errorText}`);
                        addSystemMessage('Fox: Não consegui gerar uma resposta. Erro da API de chat geral. Verifique o console.');
                        foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                        foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                        return;
                    }

                    const generalResult = await generalResponse.json();

                    if (generalResult.candidates && generalResult.candidates.length > 0 &&
                        generalResult.candidates[0].content && generalResult.candidates[0].content.parts &&
                        generalResult.candidates[0].content.parts.length > 0) {
                        const aiResponse = generalResult.candidates[0].content.parts[0].text;
                        addChatMessage('Fox', aiResponse);
                    } else {
                        addSystemMessage('Fox: Não consegui gerar uma resposta. A resposta da API estava vazia ou malformada. Verifique o console.');
                        console.error('Gemini API response structure unexpected for chatbot:', generalResult);
                        // Add more detailed logging for debugging
                        console.error('Full Gemini API response for chatbot:', generalResult);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                }
            } catch (error) {
                console.error('Error calling Gemini API for chatbot:', error);
                addSystemMessage('Fox: Ocorreu um erro ao processar sua mensagem. Verifique sua conexão ou tente novamente.');
                foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
            }
        }

        // Function for Fox to execute commands requested by users
        async function foxExecuteCommand(fullCommand, senderName) {
            const parts = fullCommand.toLowerCase().split(' ');
            const command = parts[0];

            // Commands Fox cannot use herself, or execute for others
            const restrictedCommandsForFox = ['/ai', '/mod', '/revoke-mod', '/admin', '/revoke-admin'];
            if (restrictedCommandsForFox.includes(command)) {
                addChatMessage('Fox', `Desculpe, ${senderName}, mas eu não posso executar o comando "${command}". Minhas funções são limitadas para garantir a segurança da sala.`);
                foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                return;
            }

            // Check if the sender has admin or mod privileges
            const senderIsAdminOrMod = participants.some(p => p.name === senderName && (p.isAdmin || p.isMod));

            // Now, execute based on the command
            switch (command) {
                case '/clear':
                    if (senderIsAdminOrMod) {
                        if (parts[1] === 'all') {
                            localStorage.removeItem(LOCAL_STORAGE_CHAT_PREFIX + roomID);
                            loadChatMessages();
                            addChatMessage('Fox', 'O histórico do chat foi limpo por solicitação do administrador.');
                        } else {
                            addChatMessage('Fox', 'Para limpar o chat, por favor, especifique "/clear all".');
                        }
                    } else {
                        addChatMessage('Fox', `Desculpe, ${senderName}, eu não posso executar o comando "${command}". Apenas administradores e moderadores podem usar este comando.`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    break;
                case '/reload':
                    if (senderIsAdminOrMod) {
                        if (parts[1] === 'all') {
                            addChatMessage('Fox', 'Recarregando a página para todos na sala por solicitação do administrador...');
                            localStorage.setItem(LOCAL_STORAGE_RELOAD_ALL + roomID, 'true');
                            // Admin's own page will reload via storage event listener
                        } else {
                            addChatMessage('Fox', 'Para recarregar, por favor, especifique "/reload all".');
                        }
                    } else {
                        addChatMessage('Fox', `Desculpe, ${senderName}, eu não posso executar o comando "${command}". Apenas administradores e moderadores podem usar este comando.`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    break;
                case '/code':
                    if (roomID) {
                        addChatMessage('Fox', `O código da sala é: ${roomID}`);
                    } else {
                        addChatMessage('Fox', 'Não estou em uma sala no momento.');
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    break;
                case '/sendlink': // [NOVA FUNCIONALIDADE]: Fox agora pode "enviar" links clicáveis
                    if (parts.length > 1) {
                        const link = parts[1];
                        const { processedUrl, mediaType, mediaName, isValid } = parseMediaLink(link);
                        if (isValid) {
                            addClickableLinkMessage('Fox', link, processedUrl, mediaType, mediaName);
                            addChatMessage('Fox', `Link "${mediaName}" enviado por mim! Clique para reproduzir.`);
                        } else {
                            addChatMessage('Fox', `O link "${link}" parece inválido ou não é um formato de mídia que eu reconheça.`);
                        }
                    } else {
                        addChatMessage('Fox', 'Para enviar um link, use o formato "/sendlink [link]".');
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    break;
                case '/admin': // Fox will report who the admin is
                    const roomState = loadRoomState(roomID);
                    if (roomState) {
                        const adminParticipant = roomState.participants.find(p => p.isAdmin);
                        if (adminParticipant) {
                            addChatMessage('Fox', `O administrador da sala é: ${adminParticipant.name}`);
                        } else {
                            addChatMessage('Fox', 'Não há um administrador definido para esta sala.');
                        }
                    } else {
                        addChatMessage('Fox', 'Não foi possível carregar o estado da sala para encontrar o administrador.');
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    break;
                case '/version':
                    addChatMessage('Fox', 'Versão do Aplicativo: 0.54.2 (Stable)');
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    break;
                case '/kick':
                    if (senderIsAdminOrMod) {
                        const targetUser = parts[1];
                        const reason = parts.slice(2).join(' ');
                        if (targetUser) {
                            kickUser(targetUser, reason);
                            addChatMessage('Fox', `Comando de expulsão executado para ${targetUser} por solicitação de ${senderName}.`);
                        } else {
                            addChatMessage('Fox', `Para expulsar, por favor, especifique o nome do usuário: "/kick [Nome] [Motivo (opcional)]".`);
                        }
                    } else {
                        addChatMessage('Fox', `Desculpe, ${senderName}, eu não posso executar comandos de moderação diretamente. Por favor, peça ao administrador para usar o comando "/kick ${parts[1]} ${parts.slice(2).join(' ')}".`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    break;
                case '/ban':
                    if (senderIsAdminOrMod) {
                        const targetUser = parts[1];
                        let banReason = parts.slice(2).join(' ');
                        let banDuration = 0; // 0 for permanent

                        // Check if the last part is a duration (e.g., 10m, 2h)
                        const lastPart = parts[parts.length - 1];
                        const durationMatch = lastPart.match(/^(\d+)([mh])$/);
                        if (durationMatch) {
                            const value = parseInt(durationMatch[1]);
                            const unit = durationMatch[2];
                            if (unit === 'm') {
                                banDuration = value;
                            } else if (unit === 'h') {
                                banDuration = value * 60;
                            }
                            banReason = parts.slice(2, parts.length - 1).join(' '); // Remove duration from reason
                        }
                        if (targetUser) {
                            banUser(targetUser, banReason, banDuration);
                            addChatMessage('Fox', `Comando de banimento executado para ${targetUser} por solicitação de ${senderName}.`);
                        } else {
                            addChatMessage('Fox', `Para banir, por favor, especifique o nome do usuário: "/ban [Nome] [Motivo (opcional)] [Tempo (ex: 10m, 2h, 0 para permanente)]".`);
                        }
                    } else {
                        addChatMessage('Fox', `Desculpe, ${senderName}, eu não posso executar comandos de moderação diretamente. Por favor, peça ao administrador para usar o comando "/ban ${parts[1]} ${parts.slice(2).join(' ')}".`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    break;
                case '/mute':
                    if (senderIsAdminOrMod) {
                        const targetUser = parts[1];
                        if (targetUser) {
                            muteUser(targetUser);
                            addChatMessage('Fox', `Comando de silenciar executado para ${targetUser} por solicitação de ${senderName}.`);
                        } else {
                            addChatMessage('Fox', `Para silenciar, por favor, especifique o nome do usuário: "/mute [Nome]".`);
                        }
                    } else {
                        addChatMessage('Fox', `Desculpe, ${senderName}, eu não posso executar comandos de moderação diretamente. Por favor, peça ao administrador para usar o comando "/mute ${parts[1]}".`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    break;
                case '/stop': // [NOVA FUNCIONALIDADE]: Comando /stop para parar a mídia
                    if (senderIsAdminOrMod) {
                        stopMedia();
                        addChatMessage('Fox', `Comando de parar mídia executado por solicitação de ${senderName}.`);
                    } else {
                        addChatMessage('Fox', `Desculpe, ${senderName}, eu não posso executar o comando "${command}". Apenas administradores e moderadores podem usar este comando.`);
                    }
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    break;
                default:
                    addChatMessage('Fox', `Desculpe, ${senderName}, não entendi o comando "${fullCommand}". Posso te ajudar com outras coisas ou você pode digitar "/help" para ver meus comandos.`);
                    foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                    foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
                    break;
            }
        }


        function showParticipantActionsModal(userName) {
            const modal = document.getElementById('participantActionsModal');
            document.getElementById('actionUserName').textContent = userName;

            // Update mute button text based on user's current mute status
            const targetUser = participants.find(p => p.name === userName);
            const muteButton = document.getElementById('muteUserBtn');
            if (targetUser && targetUser.isMuted) {
                muteButton.textContent = 'Dessilenciar';
                muteButton.style.backgroundColor = '#28a745'; // Green for unmute
            } else {
                muteButton.textContent = 'Silenciar';
                muteButton.style.backgroundColor = '#007bff'; // Blue for mute
            }

            // Set up button actions
            document.getElementById('kickUserBtn').onclick = () => {
                kickUser(userName);
                modal.style.display = 'none';
                foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
            };
            document.getElementById('banUserBtn').onclick = () => {
                banUser(userName);
                modal.style.display = 'none';
                foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
            };
            document.getElementById('muteUserBtn').onclick = () => {
                muteUser(userName);
                modal.style.display = 'none';
                foxAwaitingMediaSelection = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia
                foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação
            };

            modal.style.display = 'flex';
        }


        function handleCommand(command) {
            const parts = command.split(' ');
            const cmd = parts[0].toLowerCase();
            const aiSubCommand = parts[1] ? parts[1].toLowerCase() : '';
            const targetUser = parts[1];
            const reason = parts.slice(2).join(' '); // Para motivos de kick/ban
            let duration = 0; // Para banimento

            // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de seleção de mídia ao executar um comando
            foxAwaitingMediaSelection = null;
            foxAwaitingConfirmationForPlay = null; // [NOVA FUNCIONALIDADE - CONTEXTO DA IA]: Limpa o contexto de confirmação

            switch (cmd) {
                case '/help':
                    addPrivateMessage('Comandos disponíveis:');
                    addPrivateMessage('/Version - Exibe a versão do aplicativo.');
                    addPrivateMessage('/Admin - Mostra quem é o admin da sala.');
                    addPrivateMessage('/sendlink [link] - Envia um link (visível para todos).');
                    addPrivateMessage('/code - Mostra o código da sala.');
                    addPrivateMessage('/exit - Sai da sala.');
                    addPrivateMessage('/stop - Para a mídia atual no player.'); // [NOVA FUNCIONALIDADE]: Adicionado ao help
                    addPrivateMessage('/AI sleep - Faz a Fox parar de interagir com o chat.');
                    addPrivateMessage('/AI wake - Faz a Fox voltar a interagir no chat.');
                    addPrivateMessage('/AI exit - Faz a Fox sair da sala.');
                    addPrivateMessage('/AI screencast - Pede ajuda da Fox para analisar sua tela.');
                    addPrivateMessage('/AI gerar enquete [pergunta]? [Opção 1]; [Opção 2]; ... - Cria uma enquete.');
                    addPrivateMessage('/AI fechar enquete - Encerra a enquete ativa.');
                    addPrivateMessage('/AI analisar sentimento - A Fox analisa o humor do chat.');
                    addPrivateMessage('/AI ideia criativa - A Fox gera uma ideia criativa.');
                    addPrivateMessage('/AI curiosidade - A Fox gera uma pergunta de curiosidade/quiz.'); // New command
                    addPrivateMessage('/AI humor - A Fox sugere mídia baseada no humor do chat.'); // New command
                    if (isAdmin || isMod(myName)) { // Admins and Mods can use these
                        addPrivateMessage('Comandos de Admin/Mod:');
                        addPrivateMessage('/Clear All - Limpa o chat para todos.');
                        addPrivateMessage('/Kick [Nome] [Motivo] - Expulsa um usuário.');
                        addPrivateMessage('/Ban [Nome] [Motivo] [Tempo] - Bane um usuário (ex: 10m, 2h, 0 para permanente).');
                        addPrivateMessage('/Mute [Nome] - Silencia/Dessilencia um usuário.');
                        addPrivateMessage('/reload all - Recarrega a página para todos na sala.');
                    }
                    if (isAdmin) { // Only Admins can use these
                        addPrivateMessage('Comandos de Admin (apenas):');
                        addPrivateMessage('/Admin [Nome] - Concede admin a alguém.');
                        addPrivateMessage('/Revoke-Admin [Nome] - Remove admin de alguém.');
                        addPrivateMessage('/Mod [Nome] - Concede moderador a alguém.');
                        addPrivateMessage('/Revoke-Mod [Nome] - Remove moderador de alguém.');
                        addPrivateMessage('/exitall - Tira todos da sala.');
                    }
                    break;
                case '/version':
                    addSystemMessage('Versão do Aplicativo: 0.54.2 (Stable)');
                    break;
                case '/admin':
                    const roomState = loadRoomState(roomID);
                    if (roomState) {
                        const adminParticipant = roomState.participants.find(p => p.isAdmin);
                        if (adminParticipant) {
                            addSystemMessage(`O administrador da sala é: ${adminParticipant.name}`);
                        } else {
                            addSystemMessage('Não há um administrador definido para esta sala.');
                        }
                    } else {
                        addSystemMessage('Não foi possível carregar o estado da sala para encontrar o administrador.');
                    }
                    break;
                case '/sendlink': // [NOVA FUNCIONALIDADE]: Implementação do /sendlink com link clicável
                    if (parts.length > 1) {
                        const link = parts[1];
                        const { processedUrl, mediaType, mediaName, isValid } = parseMediaLink(link);
                        if (isValid) {
                            addClickableLinkMessage(myName, link, processedUrl, mediaType, mediaName);
                        } else {
                            addPrivateMessage('Link inválido ou não suportado. Certifique-se de que é uma URL completa e válida de um serviço suportado (YouTube, Twitch, Vimeo, DailyMotion, ou link direto para MP4/MP3/etc.).', true);
                        }
                    } else {
                        addPrivateMessage('Uso: /sendlink [link]', true);
                    }
                    break;
                case '/code':
                    if (roomID) {
                        addPrivateMessage(`O código da sala é: ${roomID}`);
                    } else {
                        addPrivateMessage('Você não está em uma sala.', true);
                    }
                    break;
                case '/exit':
                    addSystemMessage(`${myName} saiu da sala.`);
                    // Remove o participante da lista
                    participants = participants.filter(p => p.name !== myName);
                    updateRoomStateInLocalStorage(); // Sincroniza a remoção
                    // Redireciona para a tela inicial
                    showScreen('menuSetup');
                    roomID = '';
                    myName = '';
                    isAdmin = false;
                    waitingForApproval = false;
                    currentJoinRequestId = null;
                    clearTimeout(approvalTimeout);
                    currentRoomAgeRestricted = false; // Reseta a flag de restrição de idade
                    aiSleeping = false; // Reset AI sleeping state
                    aiChatbotActive = false; // Reset AI active state
                    updateAIBottonVisibility(); // Garante que os botões de IA voltem ao normal no menu
                    updateMediaControlsVisibility(); // Hide media controls
                    break;
                case '/clear':
                    if ((isAdmin || isMod(myName)) && parts[1] && parts[1].toLowerCase() === 'all') {
                        localStorage.removeItem(LOCAL_STORAGE_CHAT_PREFIX + roomID);
                        loadChatMessages(); // Limpa o chat na UI
                        addSystemMessage('O chat foi limpo por um administrador.');
                    } else if (!isAdmin && !isMod(myName)) {
                        addPrivateMessage('Você não tem permissão para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Clear All', true);
                    }
                    break;
                case '/kick':
                    if ((isAdmin || isMod(myName)) && targetUser) {
                        kickUser(targetUser, reason);
                    } else if (!isAdmin && !isMod(myName)) {
                        addPrivateMessage('Você não tem permissão para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Kick [Nome] [Motivo (opcional)]', true);
                    }
                    break;
                case '/ban':
                    if ((isAdmin || isMod(myName)) && targetUser) {
                        let banReason = parts.slice(2).join(' ');
                        let banDuration = 0; // 0 for permanent

                        // Check if the last part is a duration (e.g., 10m, 2h)
                        const lastPart = parts[parts.length - 1];
                        const durationMatch = lastPart.match(/^(\d+)([mh])$/);
                        if (durationMatch) {
                            const value = parseInt(durationMatch[1]);
                            const unit = durationMatch[2];
                            if (unit === 'm') {
                                banDuration = value;
                            } else if (unit === 'h') {
                                banDuration = value * 60;
                            }
                            banReason = parts.slice(2, parts.length - 1).join(' '); // Remove duration from reason
                        }

                        banUser(targetUser, banReason, banDuration);
                    } else if (!isAdmin && !isMod(myName)) {
                        addPrivateMessage('Você não tem permissão para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Ban [Nome] [Motivo (opcional)] [Tempo (ex: 10m, 2h, 0 para permanente)]', true);
                    }
                    break;
                case '/mute':
                    if ((isAdmin || isMod(myName)) && targetUser) {
                        muteUser(targetUser);
                    } else if (!isAdmin && !isMod(myName)) {
                        addPrivateMessage('Você não tem permissão para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Mute [Nome]', true);
                    }
                    break;
                case '/reload':
                    if ((isAdmin || isMod(myName)) && parts[1] && parts[1].toLowerCase() === 'all') {
                        addSystemMessage('Um administrador solicitou o recarregamento da página para todos.');
                        localStorage.setItem(LOCAL_STORAGE_RELOAD_ALL + roomID, 'true');
                        // Força o recarregamento da própria aba do admin também
                        window.location.reload();
                    } else if (!isAdmin && !isMod(myName)) {
                        addPrivateMessage('Você não tem permissão para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /reload all', true);
                    }
                    break;
                case '/admin':
                    if (isAdmin && targetUser) {
                        setParticipantRole(targetUser, 'isAdmin', true);
                    } else if (!isAdmin) {
                        addPrivateMessage('Você não tem permissão para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Admin [Nome]', true);
                    }
                    break;
                case '/revoke-admin':
                    if (isAdmin && targetUser) {
                        setParticipantRole(targetUser, 'isAdmin', false);
                    } else if (!isAdmin) {
                        addPrivateMessage('Você não tem permissão para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Revoke-Admin [Nome]', true);
                    }
                    break;
                case '/mod':
                    if (isAdmin && targetUser) {
                        setParticipantRole(targetUser, 'isMod', true);
                    } else if (!isAdmin) {
                        addPrivateMessage('Você não tem permissão para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Mod [Nome]', true);
                    }
                    break;
                case '/revoke-mod':
                    if (isAdmin && targetUser) {
                        setParticipantRole(targetUser, 'isMod', false);
                    } else if (!isAdmin) {
                        addPrivateMessage('Você não tem permissão para usar este comando.', true);
                    } else {
                        addPrivateMessage('Uso: /Revoke-Mod [Nome]', true);
                    }
                    break;
                case '/exitall':
                    if (isAdmin) {
                        addSystemMessage('Um administrador tirou todos da sala.');
                        // Envia um "kick" para todos os participantes, exceto o próprio admin
                        participants.forEach(p => {
                            if (p.name !== myName) {
                                let requests = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PENDING_REQUESTS) || '[]');
                                const kickNotificationId = `kick-${p.name}-${roomID}-${Date.now()}`;
                                requests.push({ id: kickNotificationId, roomID: roomID, name: p.name, status: 'rejected', reason: 'Você foi removido da sala pelo administrador.' });
                                localStorage.setItem(LOCAL_STORAGE_PENDING_REQUESTS, JSON.stringify(requests));
                            }
                        });
                        // Opcional: O admin também pode sair ou permanecer. Por enquanto, ele permanece.
                    } else {
                        addPrivateMessage('Você não tem permissão para usar este comando.', true);
                    }
                    break;
                case '/me':
                    if (parts.length > 1) {
                        const action = parts.slice(1).join(' ');
                        addSystemMessage(`${myName} ${action}`);
                        saveChatMessage(`${myName} ${action}`, 'system');
                    } else {
                        addPrivateMessage('Uso: /me [sua ação]', true);
                    }
                    break;
                case '/nick':
                    if (parts.length > 1) {
                        const newName = parts.slice(1).join(' ').trim();
                        if (newName && newName !== myName) {
                            // Verifica se o novo nome já está em uso por outro participante na sala atual
                            if (participants.some(p => p.name === newName)) {
                                addPrivateMessage(`O nome "${newName}" já está em uso nesta sala.`, true);
                            } else {
                                addSystemMessage(`${myName} mudou seu nome para ${newName}.`);
                                // Atualiza o nome na lista de participantes
                                const myParticipant = participants.find(p => p.name === myName);
                                if (myParticipant) {
                                    myParticipant.name = newName;
                                }
                                myName = newName;
                                updateParticipantList(); // Isso irá forçar a atualização para todos via localStorage
                                saveChatMessage(`${myName} mudou seu nome para ${newName}.`, 'system');
                            }
                        } else {
                            addPrivateMessage('Uso: /nick [novo_nome]', true);
                        }
                    } else {
                        addPrivateMessage('Uso: /nick [novo_nome]', true);
                    }
                    break;
                case '/ai':
                    if (currentRoomAgeRestricted) {
                        addPrivateMessage('Funcionalidades de IA estão desativadas em salas com restrição de idade.', true);
                        return;
                    }
                    if (aiSubCommand === 'sleep') {
                        if (!aiChatbotActive) {
                            addPrivateMessage('A Fox não está ativa no momento para dormir. Mencione-a com "@Fox" para ativá-la.', true);
                            return;
                        }
                        aiSleeping = true;
                        updateAIFoxDisplay(); // Update display to show sleeping status
                        addSystemMessage('A Fox foi dormir. Ela não responderá a mensagens até que seja acordada.');
                    } else if (aiSubCommand === 'wake') {
                        if (!aiChatbotActive) {
                            addPrivateMessage('A Fox não está ativa no momento para acordar. Mencione-a com "@Fox" para ativá-la.', true);
                            return;
                        }
                        aiSleeping = false;
                        updateAIFoxDisplay(); // Update display to show awake status
                        addSystemMessage('A Fox acordou e está pronta para interagir novamente!');
                    } else if (aiSubCommand === 'exit') {
                        if (!aiChatbotActive) {
                            addPrivateMessage('A Fox não está ativa no momento para sair.', true);
                            return;
                        }
                        // Remove Fox from participants
                        participants = participants.filter(p => !p.isAI); // Filter out the AI participant
                        aiChatbotActive = false;
                        aiSleeping = false; // Reset sleeping state
                        updateParticipantList(); // Update UI and save state
                        addSystemMessage('A Fox saiu da sala. Sentirei saudades! 😢');
                    } else if (aiSubCommand === 'screencast') {
                        addChatMessage('Fox', `Para eu te ajudar com o que está na sua tela, por favor, descreva o que você gostaria que eu analisasse ou sobre o que você quer ajuda. Por exemplo: 'Fox, o que você acha dessa planilha?' ou 'Fox, me ajude a encontrar informações sobre o que está no meu navegador agora.'`);
                    }
                    else if (aiSubCommand === 'gerar' && parts[2] === 'enquete') {
                        if (activePoll) {
                            customAlert('Já existe uma enquete ativa. Feche a enquete atual antes de criar uma nova.');
                            return;
                        }
                        const pollContent = parts.slice(3).join(' '); // Get the rest of the command
                        if (pollContent.includes('?') && pollContent.includes(';')) {
                            const [questionPart, optionsPart] = pollContent.split('?');
                            const question = questionPart.trim();
                            const options = optionsPart.split(';').map(opt => opt.trim()).filter(opt => opt.length > 0);

                            if (question && options.length >= 2) {
                                activePoll = {
                                    id: `poll-${Date.now()}`,
                                    question: question,
                                    options: options.map(opt => ({ text: opt, votes: 0, voters: [] }))
                                };
                                savePollState();
                                displayPollInChat();
                                addSystemMessage('Nova enquete criada!');
                            } else {
                                addPrivateMessage('Uso: /AI gerar enquete [sua pergunta]? [Opção 1]; [Opção 2]; [Opção 3]; ...', true);
                            }
                        } else {
                            addPrivateMessage('Uso: /AI gerar enquete [sua pergunta]? [Opção 1]; [Opção 2]; [Opção 3]; ...', true);
                        }
                    } else if (aiSubCommand === 'fechar' && parts[2] === 'enquete') {
                        if (activePoll) {
                            activePoll = null;
                            savePollState(); // Clear from localStorage
                            removePollFromChat(); // Remove from UI
                            addSystemMessage('Enquete encerrada.');
                        } else {
                            addPrivateMessage('Não há enquete ativa para fechar.', true);
                        }
                    } else if (aiSubCommand === 'analisar' && parts[2] === 'sentimento') {
                        analyzeChatSentiment();
                    } else if (aiSubCommand === 'ideia' && parts[2] === 'criativa') {
                        generateCreativePrompt();
                    } else if (aiSubCommand === 'curiosidade') { // New command handler
                        document.getElementById('generateTriviaBtn').click(); // Trigger the button click
                    } else if (aiSubCommand === 'humor') { // New command handler
                        document.getElementById('suggestMoodMediaBtn').click(); // Trigger the button click
                    }
                    else {
                        addPrivateMessage(`Subcomando /AI desconhecido: ${aiSubCommand}. Use '/AI sleep', '/AI wake', '/AI exit', '/AI screencast', '/AI gerar enquete', '/AI fechar enquete', '/AI analisar sentimento', '/AI ideia criativa', '/AI curiosidade', ou '/AI humor'.`, true);
                    }
                    break;
                case '/acuriosidadematouogato': // Hidden command
                    // 1 in 200 chance to execute
                    if (Math.floor(Math.random() * 200) === 0) {
                        addSystemMessage('A curiosidade matou o gato... e talvez esta aba. 😼');
                        // Attempt to close the window/tab.
                        // Note: window.close() only works for tabs/windows opened by script.
                        // For user-opened tabs, it might be ignored or prompt the user.
                        // [BUG/UX]: `window.close()` geralmente não funciona para abas que não foram abertas via `window.open()`.
                        // Isso pode levar a uma experiência inconsistente.
                        setTimeout(() => {
                            window.close();
                        }, 2000); // Give a moment for the message to show
                    } else {
                        addSystemMessage('A curiosidade não matou o gato desta vez. 😼');
                    }
                    break;
                default:
                    addPrivateMessage(`Comando desconhecido: ${command}. Digite /help para ver os comandos disponíveis.`, true);
            }
        }

        // Inicializa a limpeza de chats antigos ao carregar a página
        document.addEventListener('DOMContentLoaded', () => {
            cleanOldChatMessages();
            // Exibir o aviso beta inicial
            const betaModal = document.getElementById('betaNoticeModal');
            if (betaModal) {
                betaModal.style.display = 'flex';
                // Opcional: fechar o modal após alguns segundos
                setTimeout(() => {
                    betaModal.style.display = 'none';
                }, 5000); // Exibe por 5 segundos
            }
            // Initialize AI states on load
            aiSleeping = false;
            aiChatbotActive = false;
            updateAIBottonVisibility(); // Garante que os botões de IA estejam ocultos no início se a sala for restrita
            updateMediaControlsVisibility(); // Hide media controls initially
            loadPollState(); // Carrega o estado da enquete ao iniciar

            // Adiciona event listeners para os botões de modal
            document.getElementById('chooseMediaBtn').onclick = () => {
                document.getElementById('fileMenuModal').style.display = 'flex';
            };
            document.getElementById('showPlaylistBtn').onclick = () => {
                document.getElementById('playlistModal').style.display = 'flex';
            };
            document.getElementById('showParticipantsBtn').onclick = () => {
                document.getElementById('participantListModal').style.display = 'flex';
            };
        });

        // Fechar o modal beta
        document.getElementById('betaNoticeContent').addEventListener('click', () => {
            document.getElementById('betaNoticeModal').style.display = 'none';
        });

        // --- Firebase Google Login Integration ---
        // Configuração do Firebase
        // SUBSTITUA ESTE OBJETO COM AS SUAS PRÓPRIAS CREDENCIAIS DO FIREBASE
        // Você as encontra no console do Firebase, em "Configurações do Projeto" -> "Seus apps"
        const firebaseConfig = {
            apiKey: "AIzaSyCNP_7tTErDAq6Tzo_n9vloMUSSpBvqbfQ", // <<<<<<< COLOQUE SUA CHAVE DA API DO FIREBASE AQUI >>>>>>>
            authDomain: "player-android01.firebaseapp.com",
            projectId: "player-android01",
            storageBucket: "player-android01.firebasestorage.app",
            messagingSenderId: "310557222580",
            appId: "1:310557222580:web:a2d6ad7f9b93aad6b3d9e1"
        };

        // Inicializa o Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const googleProvider = new firebase.auth.GoogleAuthProvider();

        // Referências aos elementos HTML de autenticação
        const googleAuthStatus = document.getElementById('google-auth-status');
        const googleSignInButton = document.getElementById('google-signin-button');
        const googleSignOutButton = document.getElementById('google-signout-button');
        const nicknameInput = document.getElementById('nickname');

        // Listener para o estado de autenticação do Firebase
        auth.onAuthStateChanged(user => {
            if (user) {
                // Usuário logado
                googleAuthStatus.textContent = `Logado como: ${user.displayName || user.email}`;
                googleSignInButton.classList.add('hidden');
                googleSignOutButton.classList.remove('hidden');

                // Preenche o nickname com o nome do Google se o campo estiver vazio
                if (!nicknameInput.value.trim()) {
                    nicknameInput.value = user.displayName || user.email || '';
                }
            } else {
                // Usuário deslogado
                googleAuthStatus.textContent = 'Faça login para usar seu nome Google.';
                googleSignInButton.classList.remove('hidden');
                googleSignOutButton.classList.add('hidden');
                // Não limpa o nickname se o usuário já digitou algo
            }
        });

        // Função para login com Google
        googleSignInButton.addEventListener('click', () => {
            auth.signInWithPopup(googleProvider)
                .then((result) => {
                    // Login bem-sucedido
                    console.log("Usuário logado via Google:", result.user.displayName);
                    // O onAuthStateChanged cuidará de atualizar a UI e o nickname
                })
                .catch((error) => {
                    // Erro no login
                    console.error("Erro no login com Google:", error);
                    customAlert(`Erro no login com Google: ${error.message}`);
                });
        });

        // Função para logout
        googleSignOutButton.addEventListener('click', () => {
            auth.signOut()
                .then(() => {
                    // Logout bem-sucedido
                    console.log("Usuário deslogado do Google.");
                    // O onAuthStateChanged cuidará de atualizar a UI
                })
                .catch((error) => {
                    // Erro no logout
                    console.error("Erro no logout:", error);
                    customAlert(`Erro no logout: ${error.message}`);
                });
        });

    </script>
</body>
</html>
